#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <dirent.h>
#include <ctype.h>
#include <stdarg.h>
typedef struct Command Command;typedef struct vec_u8 vec_u8;typedef struct vec_Expr vec_Expr;typedef struct TokenKind TokenKind;typedef struct Token Token;typedef struct vec_Token vec_Token;typedef struct Color Color;typedef struct arr_u8 arr_u8;typedef struct File File;typedef struct vec_PathPart vec_PathPart;typedef struct vec_FieldInst vec_FieldInst;typedef struct PathPart PathPart;typedef struct FieldInst FieldInst;typedef struct ExprKind ExprKind;typedef struct Expr Expr;typedef struct Location Location;void command_help(uint8_t* n,uint8_t* d,uint8_t* o);Command get_command(int32_t argc,uint8_t** argv);vec_u8 vec_u8_new(int32_t cap);void vec_u8_push(vec_u8* this,uint8_t item);void generate_vector(vec_Expr ast);int32_t get_token_length(TokenKind kind);uint8_t* get_token_name(TokenKind kind);void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal);TokenKind get_keyword(uint8_t* value);uint8_t is_binary_operator(TokenKind kind);vec_Token lex(File file);vec_Token vec_Token_new(int32_t cap);void vec_u8_empty(vec_u8* this);void vec_Token_push(vec_Token* this,Token item);void print_tokens(vec_Token tokens);int32_t main(int32_t argc,uint8_t** argv);uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv);void set_color(Color color);void lex_parse_recursive(uint8_t* path);arr_u8 arr_u8_new(int32_t len);void REMOVE_ME();vec_PathPart vec_PathPart_new(int32_t cap);vec_FieldInst vec_FieldInst_new(int32_t cap);vec_Expr parse(File file,vec_Token tokens);vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local);vec_Expr vec_Expr_new(int32_t cap);void vec_Expr_push(vec_Expr* this,Expr item);uint8_t optional_token(Token token,TokenKind kind,int32_t* index);Expr parse_local(File file,vec_Token tokens,int32_t* index);Expr parse_global(File file,vec_Token tokens,int32_t* index);Expr parse_path(File file,vec_Token tokens,int32_t* index);void vec_PathPart_push(vec_PathPart* this,PathPart item);void print_exprs(vec_Expr exprs);void print_expr_vec(vec_Expr exprs,int32_t depth);void print_opt_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name,uint8_t _next);void print_expr(Expr expr,int32_t depth);uint8_t* get_expr_name(ExprKind kind);void indent(int32_t depth);Location get_location(uint8_t* file,int32_t index);void print_snippet(arr_u8 file,Location location);void throw(File file,int32_t index,uint8_t* error,...);void push_char(vec_u8* v,uint8_t c);union CommandUnion{char _;};struct Command{int type;union CommandUnion u;};struct vec_u8{uint8_t* buf;int32_t len;int32_t cap;};struct vec_Expr{Expr* buf;int32_t len;int32_t cap;};union TokenKindUnion{char _;};struct TokenKind{int type;union TokenKindUnion u;};struct Token{TokenKind kind;int32_t index;uint8_t* value;};struct vec_Token{Token* buf;int32_t len;int32_t cap;};union ColorUnion{char _;};struct Color{int type;union ColorUnion u;};struct arr_u8{uint8_t* buf;int32_t len;};struct File{uint8_t* name;arr_u8 data;};struct vec_PathPart{PathPart* buf;int32_t len;int32_t cap;};struct vec_FieldInst{FieldInst* buf;int32_t len;int32_t cap;};struct PathPart{uint8_t* name;vec_Expr gens;};struct FieldInst{uint8_t* name;Expr* value;};typedef struct{uint8_t* name;vec_Expr args;}ExprKind_Tag;typedef struct{vec_PathPart path;}ExprKind_Path;typedef struct{Expr* path;vec_Expr body;}ExprKind_TagDef;typedef struct{vec_Expr body;}ExprKind_Block;typedef struct{Expr* path;}ExprKind_Mod;typedef struct{Expr* path;}ExprKind_Use;typedef struct{Expr* _type;uint8_t* name;}ExprKind_Field;typedef struct{Expr* path;vec_Expr fields;vec_Expr body;}ExprKind_Comp;typedef struct{Expr* path;vec_Expr fields;vec_Expr opts;vec_Expr body;}ExprKind_Enum;typedef struct{uint8_t* name;vec_Expr fields;}ExprKind_Option;typedef struct{Expr* path;vec_Expr body;}ExprKind_Prop;typedef struct{Expr* _prop;Expr* target;}ExprKind_Def;typedef struct{Expr* ret_type;Expr* path;vec_Expr args;vec_Expr body;}ExprKind_SubDef;typedef struct{Expr* _type;Expr* path;Expr* value;}ExprKind_VarDef;typedef struct{Expr* _type;uint8_t* name;Expr* value;}ExprKind_LocalVarDef;typedef struct{Expr* path;vec_Expr args;}ExprKind_SubCall;typedef struct{Expr* path;}ExprKind_VarUse;typedef struct{Expr* path;vec_FieldInst fields;}ExprKind_CompInst;typedef struct{uint8_t* value;}ExprKind_StringLit;typedef struct{uint8_t* value;}ExprKind_CharLit;typedef struct{uint8_t* value;}ExprKind_IntLit;typedef struct{uint8_t* value;}ExprKind_FloatLit;typedef struct{uint8_t value;}ExprKind_BoolLit;typedef struct{vec_Expr body;}ExprKind_LocalBlock;typedef struct{Expr* cond;vec_Expr body;}ExprKind_If;typedef struct{Expr* cond;vec_Expr body;}ExprKind_Elif;typedef struct{vec_Expr body;}ExprKind_Else;typedef struct{vec_Expr body;}ExprKind_Loop;typedef struct{Expr* cond;vec_Expr body;}ExprKind_While;typedef struct{vec_Expr iter;Expr* cond;vec_Expr _next;vec_Expr body;}ExprKind_For;typedef struct{uint8_t* iter;Expr* value;vec_Expr body;}ExprKind_Each;typedef struct{Expr* value;vec_Expr cases;}ExprKind_Match;typedef struct{vec_Expr values;vec_Expr body;}ExprKind_Case;typedef struct{uint8_t* label;Expr* value;}ExprKind_Ret;typedef struct{uint8_t* label;}ExprKind_Next;typedef struct{uint8_t* label;}ExprKind_Jump;typedef struct{uint8_t* label;Expr* value;}ExprKind_Try;typedef struct{Expr* value;TokenKind kind;}ExprKind_UnaryOp;typedef struct{Expr* lhs;Expr* rhs;TokenKind kind;}ExprKind_BinaryOp;typedef struct{Expr* cond;Expr* valueA;Expr* valueB;}ExprKind_TernaryOp;union ExprKindUnion{ExprKind_Tag u0;ExprKind_Path u1;ExprKind_TagDef u2;ExprKind_Block u3;ExprKind_Mod u4;ExprKind_Use u5;ExprKind_Field u6;ExprKind_Comp u7;ExprKind_Enum u8;ExprKind_Option u9;ExprKind_Prop u10;ExprKind_Def u11;ExprKind_SubDef u12;ExprKind_VarDef u13;ExprKind_LocalVarDef u14;ExprKind_SubCall u15;ExprKind_VarUse u16;ExprKind_CompInst u17;ExprKind_StringLit u18;ExprKind_CharLit u19;ExprKind_IntLit u20;ExprKind_FloatLit u21;ExprKind_BoolLit u22;ExprKind_LocalBlock u25;ExprKind_If u26;ExprKind_Elif u27;ExprKind_Else u28;ExprKind_Loop u29;ExprKind_While u30;ExprKind_For u31;ExprKind_Each u32;ExprKind_Match u33;ExprKind_Case u34;ExprKind_Ret u35;ExprKind_Next u36;ExprKind_Jump u37;ExprKind_Try u38;ExprKind_UnaryOp u39;ExprKind_BinaryOp u40;ExprKind_TernaryOp u41;char _;};struct ExprKind{int type;union ExprKindUnion u;};struct Expr{ExprKind kind;vec_Expr tags;uint8_t* label;};struct Location{int32_t line;int32_t column;};typedef struct dirent dirent;vec_u8 vec_u8_new(int32_t cap){return (vec_u8){.buf=malloc(sizeof(uint8_t)*cap),.len=0,.cap=cap,};};void vec_u8_push(vec_u8* this,uint8_t item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(uint8_t)*((*this).cap));}};vec_Token vec_Token_new(int32_t cap){return (vec_Token){.buf=malloc(sizeof(Token)*cap),.len=0,.cap=cap,};};void vec_u8_empty(vec_u8* this){(((*this).buf)[0])=(((*this).len)=0);};void vec_Token_push(vec_Token* this,Token item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Token)*((*this).cap));}};arr_u8 arr_u8_new(int32_t len){return (arr_u8){.buf=malloc(sizeof(uint8_t)*len),.len=len,};};vec_PathPart vec_PathPart_new(int32_t cap){return (vec_PathPart){.buf=malloc(sizeof(PathPart)*cap),.len=0,.cap=cap,};};vec_FieldInst vec_FieldInst_new(int32_t cap){return (vec_FieldInst){.buf=malloc(sizeof(FieldInst)*cap),.len=0,.cap=cap,};};vec_Expr vec_Expr_new(int32_t cap){return (vec_Expr){.buf=malloc(sizeof(Expr)*cap),.len=0,.cap=cap,};};void vec_Expr_push(vec_Expr* this,Expr item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Expr)*((*this).cap));}};void vec_PathPart_push(vec_PathPart* this,PathPart item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(PathPart)*((*this).cap));}};void command_help(uint8_t* n,uint8_t* d,uint8_t* o){printf(d);printf("\n\nUSAGE:\n    cup ");printf(n);printf(" [OPTIONS]\n\nOPTIONS:");printf(o);printf("\n");};uint8_t* command_options_empty="\n    No options are available for this command";uint8_t* command_options_compile="\n    -i, --input     Specify the input file name\n    -o, --output    Specify the output file name\n    -cg, --gcc     Use GCC as a compiler\n    -cm, --msvc    Use MSVC as a compiler\n    -cc, --clang   use Clang as a compiler\n    -ct, --tcc     Use TinyCC as a compiler";Command get_command(int32_t argc,uint8_t** argv){if (argc==1) {return (Command){1};}uint8_t is_command=0;vec_u8 vector=vec_u8_new(16);for(int i=1;i<argc;i+=1) {if (i==4) {goto brk_l;}if (((argv[i])[0])=='-') {if (is_command) {goto brk_l;}goto l;}is_command=1;int32_t length=strlen(argv[i]);for(int c=0;c<length;c+=1) {vec_u8_push((&vector),(argv[i])[c]);}l:}brk_l:vec_u8_push((&vector),'\0');uint8_t* input=vector.buf;if (strcmp(input,"help")==0) {return (Command){1};} else if (strcmp(input,"helprun")==0) {return (Command){2};} else if (strcmp(input,"helpbuild")==0) {return (Command){3};} else if (strcmp(input,"helpcheck")==0) {return (Command){4};} else if (strcmp(input,"helpupdate")==0) {return (Command){6};} else if (strcmp(input,"helpadd")==0) {return (Command){7};} else if (strcmp(input,"helpremove")==0) {return (Command){8};} else if (strcmp(input,"helpgendocs")==0) {return (Command){9};} else if (strcmp(input,"helpgenbinds")==0) {return (Command){10};} else if (strcmp(input,"helpselfupdate")==0) {return (Command){11};} else if (strcmp(input,"helpselfinstall")==0) {return (Command){12};} else if (strcmp(input,"helpselfuninstall")==0) {return (Command){13};} else if (strcmp(input,"run")==0) {return (Command){14};} else if (strcmp(input,"build")==0) {return (Command){15};} else if (strcmp(input,"check")==0) {return (Command){16};} else if (strcmp(input,"update")==0) {return (Command){18};} else if (strcmp(input,"add")==0) {return (Command){19};} else if (strcmp(input,"remove")==0) {return (Command){20};} else if (strcmp(input,"gendocs")==0) {return (Command){21};} else if (strcmp(input,"genbinds")==0) {return (Command){22};} else if (strcmp(input,"selfupdate")==0) {return (Command){23};} else if (strcmp(input,"selfinstall")==0) {return (Command){24};} else if (strcmp(input,"selfuninstall")==0) {return (Command){25};}return (Command){0};};void generate_vector(vec_Expr ast){};int32_t get_token_length(TokenKind kind){if(kind.type==7){return 4;}else if(kind.type==8){return 5;}else if(kind.type==9){return 4;}else if(kind.type==10){return 4;}else if(kind.type==11){return 4;}else if(kind.type==12){return 3;}else if(kind.type==13){return 3;}else if(kind.type==14){return 3;}else if(kind.type==15){return 4;}else if(kind.type==16){return 4;}else if(kind.type==17){return 4;}else if(kind.type==18){return 3;}else if(kind.type==19){return 3;}else if(kind.type==20){return 3;}else if(kind.type==21){return 5;}else if(kind.type==22){return 2;}else if(kind.type==23){return 4;}else if(kind.type==24){return 4;}else if(kind.type==25){return 4;}else if(kind.type==26){return 5;}else if(kind.type==27){return 3;}else if(kind.type==28){return 4;}else if(kind.type==29){return 5;}else if(kind.type==30){return 3;}else if(kind.type==31){return 4;}else if(kind.type==32){return 4;}else if(kind.type==33){return 3;}else if(kind.type==34){return 2;}else if(kind.type==35){return 3;}else if(kind.type==36){return 1;}else if(kind.type==37){return 1;}else if(kind.type==38){return 1;}else if(kind.type==39){return 1;}else if(kind.type==40){return 1;}else if(kind.type==41){return 1;}else if(kind.type==42){return 1;}else if(kind.type==43){return 1;}else if(kind.type==44){return 1;}else if(kind.type==45){return 1;}else if(kind.type==46){return 1;}else if(kind.type==47){return 1;}else if(kind.type==48){return 1;}else if(kind.type==49){return 1;}else if(kind.type==50){return 1;}else if(kind.type==51){return 1;}else if(kind.type==52){return 2;}else if(kind.type==53){return 1;}else if(kind.type==54){return 2;}else if(kind.type==55){return 1;}else if(kind.type==56){return 1;}else if(kind.type==57){return 1;}else if(kind.type==58){return 2;}else if(kind.type==59){return 1;}else if(kind.type==60){return 2;}else if(kind.type==61){return 1;}else if(kind.type==62){return 2;}else if(kind.type==63){return 1;}else if(kind.type==64){return 2;}else if(kind.type==65){return 1;}else if(kind.type==66){return 2;}else if(kind.type==67){return 1;}else if(kind.type==68){return 2;}else if(kind.type==69){return 1;}else if(kind.type==70){return 2;}};uint8_t* get_token_name(TokenKind kind){if(kind.type==1){return "EMPTY";}else if(kind.type==2){return "IDENT";}else if(kind.type==3){return "STRING_LIT";}else if(kind.type==4){return "CHAR_LIT";}else if(kind.type==5){return "INT_LIT";}else if(kind.type==6){return "FLOAT_LIT";}else if(kind.type==7){return "TRUE";}else if(kind.type==8){return "FALSE";}else if(kind.type==9){return "NONE";}else if(kind.type==10){return "THIS";}else if(kind.type==11){return "TYPE";}else if(kind.type==12){return "TAG";}else if(kind.type==13){return "MOD";}else if(kind.type==14){return "USE";}else if(kind.type==15){return "COMP";}else if(kind.type==16){return "ENUM";}else if(kind.type==17){return "PROP";}else if(kind.type==18){return "DEF";}else if(kind.type==19){return "SUB";}else if(kind.type==20){return "VAR";}else if(kind.type==21){return "WHERE";}else if(kind.type==22){return "IF";}else if(kind.type==23){return "ELIF";}else if(kind.type==24){return "ELSE";}else if(kind.type==25){return "LOOP";}else if(kind.type==26){return "WHILE";}else if(kind.type==27){return "FOR";}else if(kind.type==28){return "EACH";}else if(kind.type==29){return "MATCH";}else if(kind.type==30){return "RET";}else if(kind.type==31){return "NEXT";}else if(kind.type==32){return "JUMP";}else if(kind.type==33){return "TRY";}else if(kind.type==34){return "AS";}else if(kind.type==35){return "HAS";}else if(kind.type==36){return "SEMICOLON";}else if(kind.type==37){return "COLON";}else if(kind.type==38){return "COMMA";}else if(kind.type==39){return "DOT";}else if(kind.type==40){return "QUESTION_MARK";}else if(kind.type==41){return "TILDE";}else if(kind.type==42){return "HASH";}else if(kind.type==43){return "LEFT_PAREN";}else if(kind.type==44){return "RIGHT_PAREN";}else if(kind.type==45){return "LEFT_BRACE";}else if(kind.type==46){return "RIGHT_BRACE";}else if(kind.type==47){return "LEFT_BRACKET";}else if(kind.type==48){return "RIGHT_BRACKET";}else if(kind.type==49){return "DEREF";}else if(kind.type==50){return "ADDRESS";}else if(kind.type==51){return "ASSIGN";}else if(kind.type==52){return "EQUAL";}else if(kind.type==53){return "NOT";}else if(kind.type==54){return "NOT_EQUAL";}else if(kind.type==55){return "AND";}else if(kind.type==56){return "OR";}else if(kind.type==57){return "LESS";}else if(kind.type==58){return "LESS_EQUAL";}else if(kind.type==59){return "GREATER";}else if(kind.type==60){return "GREATER_EQUAL";}else if(kind.type==61){return "ADD";}else if(kind.type==62){return "ADD_ASSIGN";}else if(kind.type==63){return "SUBTRACT";}else if(kind.type==64){return "SUBTRACT_ASSIGN";}else if(kind.type==65){return "MULTIPLY";}else if(kind.type==66){return "MULTIPLY_ASSIGN";}else if(kind.type==67){return "DIVIDE";}else if(kind.type==68){return "DIVIDE_ASSIGN";}else if(kind.type==69){return "MODULO";}else if(kind.type==70){return "MODULO_ASSIGN";}};void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal){if ((is_literal==2)&&(((*value).len)==4)) {throw(file,i,"too many characters in character literal");}push_char(value,c);};TokenKind get_keyword(uint8_t* value){if (strcmp(value,"tag")==0) {return (TokenKind){12};} else if (strcmp(value,"mod")==0) {return (TokenKind){13};} else if (strcmp(value,"use")==0) {return (TokenKind){14};} else if (strcmp(value,"comp")==0) {return (TokenKind){15};} else if (strcmp(value,"enum")==0) {return (TokenKind){16};} else if (strcmp(value,"prop")==0) {return (TokenKind){17};} else if (strcmp(value,"def")==0) {return (TokenKind){18};} else if (strcmp(value,"sub")==0) {return (TokenKind){19};} else if (strcmp(value,"var")==0) {return (TokenKind){20};} else if (strcmp(value,"this")==0) {return (TokenKind){10};} else if (strcmp(value,"type")==0) {return (TokenKind){11};} else if (strcmp(value,"where")==0) {return (TokenKind){21};} else if (strcmp(value,"true")==0) {return (TokenKind){7};} else if (strcmp(value,"false")==0) {return (TokenKind){8};} else if (strcmp(value,"none")==0) {return (TokenKind){9};} else if (strcmp(value,"if")==0) {return (TokenKind){22};} else if (strcmp(value,"elif")==0) {return (TokenKind){23};} else if (strcmp(value,"else")==0) {return (TokenKind){24};} else if (strcmp(value,"loop")==0) {return (TokenKind){25};} else if (strcmp(value,"while")==0) {return (TokenKind){26};} else if (strcmp(value,"for")==0) {return (TokenKind){27};} else if (strcmp(value,"each")==0) {return (TokenKind){28};} else if (strcmp(value,"match")==0) {return (TokenKind){29};} else if (strcmp(value,"ret")==0) {return (TokenKind){30};} else if (strcmp(value,"next")==0) {return (TokenKind){31};} else if (strcmp(value,"jump")==0) {return (TokenKind){32};} else if (strcmp(value,"try")==0) {return (TokenKind){33};} else if (strcmp(value,"as")==0) {return (TokenKind){34};} else if (strcmp(value,"has")==0) {return (TokenKind){35};}return (TokenKind){1};};uint8_t is_binary_operator(TokenKind kind){if(kind.type==43){return 1;}else if(kind.type==51){return 1;}else if(kind.type==52){return 1;}else if(kind.type==54){return 1;}else if(kind.type==55){return 1;}else if(kind.type==56){return 1;}else if(kind.type==57){return 1;}else if(kind.type==58){return 1;}else if(kind.type==59){return 1;}else if(kind.type==60){return 1;}else if(kind.type==61){return 1;}else if(kind.type==62){return 1;}else if(kind.type==63){return 1;}else if(kind.type==64){return 1;}else if(kind.type==65){return 1;}else if(kind.type==66){return 1;}else if(kind.type==67){return 1;}else if(kind.type==68){return 1;}else if(kind.type==69){return 1;}else if(kind.type==70){return 1;}else if(kind.type==34){return 1;}else if(kind.type==35){return 1;}else{return 0;}};vec_Token lex(File file){vec_Token tokens=vec_Token_new(32);uint8_t is_comment=0;uint8_t is_literal=0;vec_u8 value=vec_u8_new(8);vec_u8_empty((&value));for(int i=0;i<=((file.data).len);i+=1) {uint8_t c=((file.data).buf)[i];if (((((is_literal!=1)&&(is_literal!=2))&&(is_literal!=3))&&(is_literal!=4))&&(c=='`')) {is_comment=1;goto l;}if (is_comment!=0) {if (c=='\n') {is_comment=0;}goto l;}TokenKind kind=(TokenKind){0};if ((is_literal==3)||(is_literal==4)) {is_literal-=2;}if ((is_literal==1)||(is_literal==2)) {if (c==0) {if (is_literal==1) {throw(file,i-1,"expected end of %s literal","string");} else {throw(file,i-1,"expected end of %s literal","char");}} else if ((is_literal==1)&&(c=='"')) {} else if ((is_literal==2)&&(c==39)) {} else {add_to_value(file,(&value),i,c,is_literal);goto l;}}if ((c==0)||isspace(c)) {kind=(TokenKind){1};} else {if (c=='"') {if (is_literal==1) {kind=(TokenKind){3};is_literal=0;} else {kind=(TokenKind){1};is_literal=3;}} else if (c==39) {if (is_literal==2) {kind=(TokenKind){4};is_literal=0;} else {kind=(TokenKind){1};is_literal=4;}} else if (c==';') {kind=(TokenKind){36};} else if (c==':') {kind=(TokenKind){37};} else if (c==',') {kind=(TokenKind){38};} else if (c=='.') {uint8_t n=((file.data).buf)[(i+1)];if ((is_literal!=5)||((n=='_')||isalpha(n))) {kind=(TokenKind){39};}} else if (c=='?') {kind=(TokenKind){40};} else if (c=='~') {kind=(TokenKind){41};} else if (c=='#') {kind=(TokenKind){42};} else if (c=='(') {kind=(TokenKind){43};} else if (c==')') {kind=(TokenKind){44};} else if (c=='{') {kind=(TokenKind){45};} else if (c=='}') {kind=(TokenKind){46};} else if (c=='[') {kind=(TokenKind){47};} else if (c==']') {kind=(TokenKind){48};} else if (c=='@') {kind=(TokenKind){49};} else if (c=='$') {kind=(TokenKind){50};} else if (c=='&') {kind=(TokenKind){55};} else if (c=='|') {kind=(TokenKind){56};} else if (c=='=') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){52};i+=1;} else {kind=(TokenKind){51};}} else if (c=='!') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){54};i+=1;} else {kind=(TokenKind){53};}} else if (c=='<') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){58};i+=1;} else {kind=(TokenKind){57};}} else if (c=='>') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){60};i+=1;} else {kind=(TokenKind){59};}} else if (c=='+') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){62};i+=1;} else {kind=(TokenKind){61};}} else if (c=='-') {if (is_binary_operator(((tokens.buf)[((tokens.len)-1)]).kind)&&isdigit(((file.data).buf)[(i+1)])) {goto brk_ll;}if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){64};i+=1;} else {kind=(TokenKind){63};}} else if (c=='*') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){66};i+=1;} else {kind=(TokenKind){65};}} else if (c=='/') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){68};i+=1;} else {kind=(TokenKind){67};}} else if (c=='%') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){70};i+=1;} else {kind=(TokenKind){69};}}}brk_ll:if(kind.type==0){if (((((c=='-')||(c=='_'))||(c=='.'))||(c==':'))||isalnum(c)) {if ((((value.len)==0)&&isdigit(c))||(c=='-')) {is_literal=5;} else if ((is_literal==5)||(is_literal==6)) {if ((c=='.')&&(is_literal==5)) {is_literal=6;} else if ((c=='_')||isdigit(c)) {} else {throw(file,i-(value.len),"invalid identifier name starting with a digit");}}if (((is_literal!=5)&&(is_literal!=6))||(c!='_')) {add_to_value(file,(&value),i,c,is_literal);}} else {throw(file,i,"unexpected symbol %c",c);}}else{if ((value.len)>0) {if(kind.type==3){}else if(kind.type==4){}else{TokenKind value_kind=get_keyword(value.buf);if(value_kind.type==1){Token token;if (is_literal==5) {(token.kind)=(TokenKind){5};} else if (is_literal==6) {(token.kind)=(TokenKind){6};if (((value.buf)[((value.len)-1)])=='.') {throw(file,i-1,"expected a value after the decimal point");}} else {(token.kind)=(TokenKind){2};}(token.index)=(i-(value.len));(token.value)=(value.buf);vec_Token_push((&tokens),token);}else{Token token=(Token){.kind=value_kind,.index=i-get_token_length(value_kind),};vec_Token_push((&tokens),token);}value=vec_u8_new(8);vec_u8_empty((&value));is_literal=0;}}if(kind.type==1){}else{Token token=(Token){.kind=kind,};if(kind.type==3){(token.value)=(value.buf);(token.index)=(i-(value.len));vec_u8_empty((&value));}else if(kind.type==4){(token.value)=(value.buf);(token.index)=(i-(value.len));vec_u8_empty((&value));}else{(token.index)=((i-get_token_length(kind))+1);}vec_Token_push((&tokens),token);}}l:}brk_l:Token last;(last.index)=0;(last.kind)=(TokenKind){1};vec_Token_push((&tokens),last);return tokens;};void print_tokens(vec_Token tokens){printf("Tokens:\n");for(int i=0;i<(tokens.len);i+=1) {TokenKind kind=((tokens.buf)[i]).kind;set_color((Color){1});printf("  %s",get_token_name(kind));set_color((Color){0});if(kind.type==2){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==3){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==4){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==5){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==6){printf("(%s)",((tokens.buf)[i]).value);}putchar('\n');}putchar('\n');};int32_t main(int32_t argc,uint8_t** argv){Command command=get_command(argc,argv);if(command.type==0){set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such command: '%s",argv[1]);for(int i=2;i<argc;i+=1) {printf(" %s",argv[i]);}printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;}else if(command.type==14){goto brk_m;}else if(command.type==15){goto brk_m;}else if(command.type==16){return 1;}else if(command.type==17){return 1;}else if(command.type==18){return 1;}else if(command.type==19){return 1;}else if(command.type==20){return 1;}else if(command.type==21){return 1;}else if(command.type==22){return 1;}else if(command.type==23){return 1;}else if(command.type==24){return 1;}else if(command.type==25){return 1;}else if(command.type==1){printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;}else if(command.type==2){command_help("run","Compile and run the current package",command_options_compile);return 0;}else if(command.type==3){command_help("build","Compile the current package",command_options_compile);return 0;}else if(command.type==4){command_help("check","Analyze the current package",command_options_empty);return 0;}else if(command.type==5){command_help("new","Create a new package",command_options_empty);return 0;}else if(command.type==6){command_help("update","Update given dependency",command_options_empty);return 0;}else if(command.type==7){command_help("add","Adds given dependency",command_options_empty);return 0;}else if(command.type==8){command_help("remove","Removes given dependency",command_options_empty);return 0;}else if(command.type==9){command_help("gen docs","Generate documentation for the current package",command_options_empty);return 0;}else if(command.type==10){command_help("gen binds","Generate bindings for a given C header file",command_options_empty);return 0;}else if(command.type==11){command_help("self update","Update the Cup Toolkit",command_options_empty);return 0;}else if(command.type==12){command_help("self install","Install the Cup Toolkit",command_options_empty);return 0;}else if(command.type==13){command_help("self uninstall","Uninstall the Cup Toolkite",command_options_empty);return 0;}brk_m:uint8_t* input=(void*)0;uint8_t* output=(void*)0;for(int i=2;i<argc;i+=1) {if (((argv[i])[0])=='-') {if (((argv[i])[1])=='i') {if (input==(void*)0) {input=get_option((&i),argc,argv);}} else if (((argv[i])[1])=='o') {if (output==(void*)0) {output=get_option((&i),argc,argv);}}} else {set_color((Color){3});printf("error: ");set_color((Color){0});printf("invalid option '%s'",argv[i]);}}if (input==(void*)0) {input=".";}if (output==(void*)0) {output="out.c";}lex_parse_recursive(input);printf("Compilation ");set_color((Color){2});printf("successful");set_color((Color){0});printf(" (%.1lfs elapsed)\n",((double)clock())/CLOCKS_PER_SEC);return 0;};uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv){if (strlen(argv[(*index)])>2) {return (argv[(*index)])+1;} else if (argc>(*index)) {return argv[((*index)+=1)];}return (void*)0;};void set_color(Color color){if(color.type==0){printf("\033[0m");}else if(color.type==1){printf("\033[35m");}else if(color.type==2){printf("\033[32m");}else if(color.type==3){printf("\033[0;31m");}};void lex_parse_recursive(uint8_t* path){DIR* dir=opendir(path);if (dir==(void*)0) {set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such file or directory: '%s'\n",path);exit(1);}dirent* ent;while((ent=readdir(dir))!=(void*)0) {int32_t new_length=strlen((*ent).d_name);if ((new_length==1)&&((((*ent).d_name)[0])=='.')) {} else if (((new_length==2)&&((((*ent).d_name)[0])=='.'))&&((((*ent).d_name)[1])=='.')) {} else {int32_t length=strlen(path);uint8_t* new_path=malloc(((length+1)+new_length)+1);memcpy(new_path,path,length);(new_path[length])='/';memcpy((new_path+length)+1,(*ent).d_name,new_length);(new_path[((length+new_length)+1)])='\0';if (((*ent).d_type)==DT_DIR) {lex_parse_recursive(new_path);} else if (((*ent).d_type)==DT_REG) {FILE* file_point=fopen(new_path,"rb");fseek(file_point,(int32_t)0,SEEK_END);arr_u8 file=arr_u8_new(ftell(file_point)+1);rewind(file_point);(file.len)-=1;fread(file.buf,file.len,1,file_point);((file.buf)[(file.len)])='\0';fclose(file_point);printf("Compiling %s:\n",new_path);File abc=(File){.name=new_path,.data=file,};vec_Token tokens=lex(abc);print_tokens(tokens);vec_Expr exprs=parse(abc,tokens);print_exprs(exprs);free(file.buf);}free(new_path);}}closedir(dir);};void REMOVE_ME(){vec_PathPart_new(0);vec_FieldInst_new(0);};vec_Expr parse(File file,vec_Token tokens){int32_t index=0;return parse_block(file,tokens,(&index),0);};vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local){vec_Expr exprs=vec_Expr_new(4);while((*index)<(tokens.len)) {if(((tokens.buf)[(*index)]).kind.type==46){(*index)+=1;return exprs;}else if(((tokens.buf)[(*index)]).kind.type==1){(*index)+=1;return exprs;}Expr expr;if (local) {expr=parse_local(file,tokens,index);} else {expr=parse_global(file,tokens,index);}vec_Expr_push((&exprs),expr);}return exprs;};uint8_t optional_token(Token token,TokenKind kind,int32_t* index){if(token.kind.type==0){}else if(token.kind.type==-1){(*index)+=1;return 1;}else{return 0;}};Expr parse_local(File file,vec_Token tokens,int32_t* index){return (Expr){};};Expr parse_global(File file,vec_Token tokens,int32_t* index){Expr expr;((expr.tags).len)=0;Token token=(tokens.buf)[(*index)];if(token.kind.type==14){token=((tokens.buf)[((*index)+=1)]);if(token.kind.type==2){Expr* path=malloc(sizeof(Expr));(*path)=parse_path(file,tokens,index);(expr.kind)=(ExprKind){.type=5,.u={.u5={.path=path,}}};}else{throw(file,token.index,"expected identifier");}}return expr;};Expr parse_path(File file,vec_Token tokens,int32_t* index){vec_PathPart path=vec_PathPart_new(2);uint8_t need_colon=0;for(;;) {Token token=(tokens.buf)[(*index)];if (need_colon) {if(token.kind.type==37){need_colon=0;}else{goto brk_l;}} else {if(token.kind.type==2){printf("%s",token.value);PathPart part=(PathPart){.name=token.value,.gens=vec_Expr_new(2),};if(((tokens.buf)[((*index)+1)]).kind.type==57){token=((tokens.buf)[((*index)+=2)]);for(;;) {if(token.kind.type==59){goto brk_ll;}else{}vec_Expr gens=part.gens;vec_Expr_push((&gens),parse_path(file,tokens,index));optional_token(token,(TokenKind){38},index);ll:}brk_ll:}vec_PathPart_push((&path),part);need_colon=1;}else{if ((path.len)>0) {throw(file,token.index,"expected identifier after ':'");} else {goto brk_l;}}}(*index)+=1;l:}brk_l:Expr expr;(expr.kind)=(ExprKind){.type=1,.u={.u1={.path=path,}}};((expr.tags).len)=0;(expr.label)=(void*)0;return expr;};void print_exprs(vec_Expr exprs){printf("Exprs:");print_expr_vec(exprs,0);putchar('\n');};void print_expr_vec(vec_Expr exprs,int32_t depth){for(int i=0;i<(exprs.len);i+=1) {putchar('\n');indent(depth);set_color((Color){2});printf("%s",get_expr_name(((exprs.buf)[i]).kind));set_color((Color){0});print_expr((exprs.buf)[i],depth);}putchar('\n');};void print_opt_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name,uint8_t _next){if ((exprs.len)>0) {if (_next) {printf(", ");}printf("%s = [",name);print_expr_vec(exprs,depth+1);indent(depth);putchar(']');}};void print_expr(Expr expr,int32_t depth){putchar('(');print_opt_expr_vec(expr.tags,0,"tags",0);if (((expr.tags).len)!=0) {printf(", ");}if(expr.kind.type==0){uint8_t* name=expr.kind.u.u0.name;vec_Expr args=expr.kind.u.u0.args;printf("name = %s",name);print_opt_expr_vec(args,depth,"args",1);}else if(expr.kind.type==1){vec_PathPart path=expr.kind.u.u1.path;for(int i=0;i<(path.len);i+=1) {PathPart part=(path.buf)[i];printf("name = %s, ",part.name);print_opt_expr_vec(part.gens,depth,"gens",1);}}else if(expr.kind.type==2){Expr* path=expr.kind.u.u2.path;vec_Expr body=expr.kind.u.u2.body;print_expr((*path),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==3){vec_Expr body=expr.kind.u.u3.body;print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==4){Expr* path=expr.kind.u.u4.path;printf("path = ");print_expr((*path),depth);}else if(expr.kind.type==5){Expr* path=expr.kind.u.u5.path;printf("path = ");print_expr((*path),depth);}else if(expr.kind.type==6){Expr* _type=expr.kind.u.u6._type;uint8_t* name=expr.kind.u.u6.name;print_expr((*_type),depth);printf("name = %s",name);}else if(expr.kind.type==7){Expr* path=expr.kind.u.u7.path;vec_Expr fields=expr.kind.u.u7.fields;vec_Expr body=expr.kind.u.u7.body;print_expr((*path),depth);print_opt_expr_vec(fields,depth,"fields",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==8){Expr* path=expr.kind.u.u8.path;vec_Expr fields=expr.kind.u.u8.fields;vec_Expr opts=expr.kind.u.u8.opts;vec_Expr body=expr.kind.u.u8.body;print_expr((*path),depth);print_opt_expr_vec(fields,depth,"fields",1);print_opt_expr_vec(opts,depth,"opts",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==9){uint8_t* name=expr.kind.u.u9.name;vec_Expr fields=expr.kind.u.u9.fields;printf("name = %s",name);print_opt_expr_vec(fields,depth,"fields",1);}else if(expr.kind.type==10){Expr* path=expr.kind.u.u10.path;vec_Expr body=expr.kind.u.u10.body;print_expr((*path),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==11){Expr* _prop=expr.kind.u.u11._prop;Expr* target=expr.kind.u.u11.target;print_expr((*_prop),depth);print_expr((*target),depth);}else if(expr.kind.type==12){Expr* ret_type=expr.kind.u.u12.ret_type;Expr* path=expr.kind.u.u12.path;vec_Expr args=expr.kind.u.u12.args;vec_Expr body=expr.kind.u.u12.body;print_expr((*ret_type),depth);print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==13){Expr* _type=expr.kind.u.u13._type;Expr* path=expr.kind.u.u13.path;Expr* value=expr.kind.u.u13.value;print_expr((*_type),depth);print_expr((*path),depth);print_expr((*value),depth);}else if(expr.kind.type==14){Expr* _type=expr.kind.u.u14._type;uint8_t* name=expr.kind.u.u14.name;Expr* value=expr.kind.u.u14.value;print_expr((*_type),depth);printf("name = %s",name);print_expr((*value),depth);}else if(expr.kind.type==15){Expr* path=expr.kind.u.u15.path;vec_Expr args=expr.kind.u.u15.args;print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);}else if(expr.kind.type==16){Expr* path=expr.kind.u.u16.path;print_expr((*path),depth);}else if(expr.kind.type==17){Expr* path=expr.kind.u.u17.path;vec_FieldInst body=expr.kind.u.u17.fields;print_expr((*path),depth);for(int i=0;i<(body.len);i+=1) {FieldInst field=(body.buf)[i];printf("name = %s",field.name);print_expr((*(field.value)),depth);}}else if(expr.kind.type==18){uint8_t* value=expr.kind.u.u18.value;printf("name = %s",value);}else if(expr.kind.type==19){uint8_t* value=expr.kind.u.u19.value;printf("name = %s",value);}else if(expr.kind.type==20){uint8_t* value=expr.kind.u.u20.value;printf("name = %s",value);}else if(expr.kind.type==21){uint8_t* value=expr.kind.u.u21.value;printf("name = %s",value);}else if(expr.kind.type==22){uint8_t value=expr.kind.u.u22.value;if (value) {printf("value = true");} else {printf("value = false");}}else if(expr.kind.type==23){}else if(expr.kind.type==24){}else if(expr.kind.type==25){vec_Expr body=expr.kind.u.u25.body;print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==26){Expr* cond=expr.kind.u.u26.cond;vec_Expr body=expr.kind.u.u26.body;print_expr((*cond),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==27){Expr* cond=expr.kind.u.u27.cond;vec_Expr body=expr.kind.u.u27.body;print_expr((*cond),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==28){vec_Expr body=expr.kind.u.u28.body;print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==29){vec_Expr body=expr.kind.u.u29.body;print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==30){Expr* cond=expr.kind.u.u30.cond;vec_Expr body=expr.kind.u.u30.body;print_expr((*cond),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==31){vec_Expr iter=expr.kind.u.u31.iter;Expr* cond=expr.kind.u.u31.cond;vec_Expr _next=expr.kind.u.u31._next;vec_Expr body=expr.kind.u.u31.body;print_opt_expr_vec(iter,depth,"iter",1);print_expr((*cond),depth);print_opt_expr_vec(_next,depth,"next",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==32){uint8_t* iter=expr.kind.u.u32.iter;Expr* value=expr.kind.u.u32.value;vec_Expr body=expr.kind.u.u32.body;printf("iter = %s",iter);print_expr((*value),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==33){Expr* value=expr.kind.u.u33.value;vec_Expr cases=expr.kind.u.u33.cases;}else if(expr.kind.type==34){vec_Expr values=expr.kind.u.u34.values;vec_Expr body=expr.kind.u.u34.body;}else if(expr.kind.type==35){uint8_t* label=expr.kind.u.u35.label;Expr* value=expr.kind.u.u35.value;printf("label = %s",label);print_expr((*value),depth);}else if(expr.kind.type==36){uint8_t* label=expr.kind.u.u36.label;printf("label = %s",label);}else if(expr.kind.type==37){uint8_t* label=expr.kind.u.u37.label;printf("label = %s",label);}else if(expr.kind.type==38){uint8_t* label=expr.kind.u.u38.label;Expr* value=expr.kind.u.u38.value;printf("label = %s",label);print_expr((*value),depth);}else if(expr.kind.type==39){Expr* value=expr.kind.u.u39.value;TokenKind kind=expr.kind.u.u39.kind;print_expr((*value),depth);}else if(expr.kind.type==40){Expr* lhs=expr.kind.u.u40.lhs;Expr* rhs=expr.kind.u.u40.rhs;TokenKind kind=expr.kind.u.u40.kind;print_expr((*lhs),depth);print_expr((*rhs),depth);}else if(expr.kind.type==41){Expr* cond=expr.kind.u.u41.cond;Expr* valueA=expr.kind.u.u41.valueA;Expr* valueB=expr.kind.u.u41.valueB;print_expr((*cond),depth);print_expr((*valueA),depth);print_expr((*valueB),depth);}putchar(')');};uint8_t* get_expr_name(ExprKind kind){if(kind.type==0){return "TAG";}else if(kind.type==1){return "PATH";}else if(kind.type==2){return "TAG_DEF";}else if(kind.type==4){return "MOD";}else if(kind.type==5){return "USE";}else if(kind.type==7){return "COMP";}else if(kind.type==8){return "ENUM";}else if(kind.type==10){return "PROP";}else if(kind.type==11){return "DEF";}else if(kind.type==12){return "SUB_DEF";}else if(kind.type==13){return "VAR_DEF";}else if(kind.type==14){return "LOCAL_VAR_DEF";}else if(kind.type==15){return "SUB_CALL";}else if(kind.type==16){return "VAR_USE";}else if(kind.type==17){return "COMP_INST";}else if(kind.type==18){return "STRING_LIT";}else if(kind.type==19){return "CHAR_LIT";}else if(kind.type==20){return "INT_LIT";}else if(kind.type==21){return "FLOAT_LIT";}else if(kind.type==22){return "BOOL_LIT";}else if(kind.type==23){return "THIS_LIT";}else if(kind.type==24){return "TYPE_LIT";}else if(kind.type==25){return "LOCAL_BLOCK";}else if(kind.type==26){return "IF";}else if(kind.type==27){return "ELIF";}else if(kind.type==28){return "ELSE";}else if(kind.type==29){return "LOOP";}else if(kind.type==30){return "WHILE";}else if(kind.type==31){return "FOR";}else if(kind.type==32){return "EACH";}else if(kind.type==33){return "MATCH";}else if(kind.type==35){return "RET";}else if(kind.type==36){return "NEXT";}else if(kind.type==37){return "JUMP";}else if(kind.type==38){return "TRY";}else if(kind.type==39){return "UNARY_OP";}else if(kind.type==40){return "BINARY_OP";}else if(kind.type==41){return "TERNARY_OP";}};void indent(int32_t depth){for(int i=0;i<=depth;i+=1) {printf("  ");}};Location get_location(uint8_t* file,int32_t index){Location loc;(loc.line)=1;(loc.column)=1;for(int i=0;i<index;i+=1) {if ((file[i])=='\n') {(loc.line)+=1;(loc.column)=1;} else {(loc.column)+=1;}}return loc;};void print_snippet(arr_u8 file,Location location){printf(" %i | ",location.line);int32_t i=location.line;int32_t length=2;while(i!=0) {length+=1;i/=10;}int32_t line_index=1;for(int i=0;i<(file.len);i+=1) {uint8_t c=(file.buf)[i];if (c=='\n') {line_index+=1;if (line_index>(location.line)) {goto brk_l;}} else if (line_index==(location.line)) {putchar(c);}l:}brk_l:putchar('\n');for(int i=0;i<length;i+=1) {putchar(' ');}putchar('|');for(int i=0;i<(location.column);i+=1) {putchar(' ');}set_color((Color){3});putchar('^');set_color((Color){0});putchar('\n');};void throw(File file,int32_t index,uint8_t* error,...){va_list args;va_start(args,error);Location loc=get_location((file.data).buf,index);printf("%s:%i:%i: ",file.name,loc.line,loc.column);set_color((Color){3});printf("error: ");set_color((Color){0});vprintf(error,args);printf("\n");print_snippet(file.data,loc);exit(1);va_end(args);};void push_char(vec_u8* v,uint8_t c){(((*v).buf)[((*v).len)])=c;((*v).len)+=1;if (((*v).len)==((*v).cap)) {((*v).cap)*=2;((*v).buf)=realloc((*v).buf,sizeof(uint8_t)*((*v).cap));}(((*v).buf)[((*v).len)])=0;};