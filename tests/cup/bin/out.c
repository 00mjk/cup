#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <dirent.h>
#include <ctype.h>
#include <stdarg.h>
typedef struct Command Command;typedef struct vec_u8 vec_u8;typedef struct vec_Expr vec_Expr;typedef struct TokenKind TokenKind;typedef struct Token Token;typedef struct vec_Token vec_Token;typedef struct Color Color;typedef struct arr_u8 arr_u8;typedef struct File File;typedef struct vec_PathPart vec_PathPart;typedef struct vec_VarName vec_VarName;typedef struct PathPart PathPart;typedef struct VarName VarName;typedef struct ExprKind ExprKind;typedef struct Expr Expr;typedef struct Location Location;void command_help(uint8_t* n,uint8_t* d,uint8_t* o);Command get_command(int32_t argc,uint8_t** argv);vec_u8 vec_u8_new(int32_t cap);void vec_u8_push(vec_u8* this,uint8_t item);void generate_vector(vec_Expr ast);int32_t get_token_length(TokenKind kind);uint8_t* get_token_name(TokenKind kind);void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal);TokenKind get_keyword(uint8_t* value);uint8_t is_binary_operator(TokenKind kind);vec_Token lex(File file);vec_Token vec_Token_new(int32_t cap);void vec_u8_empty(vec_u8* this);void vec_Token_push(vec_Token* this,Token item);void print_tokens(vec_Token tokens);int32_t main(int32_t argc,uint8_t** argv);uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv);void set_color(Color color);void lex_parse_recursive(uint8_t* path);arr_u8 arr_u8_new(int32_t len);void REMOVE_ME();vec_PathPart vec_PathPart_new(int32_t cap);vec_VarName vec_VarName_new(int32_t cap);vec_Expr parse(File file,vec_Token tokens);vec_Expr vec_Expr_new(int32_t cap);void vec_Expr_push(vec_Expr* this,Expr item);vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local);Token expect_token(File file,vec_Token tokens,int32_t* index,TokenKind kind,uint8_t* error);uint8_t opt_token(vec_Token tokens,int32_t* index,TokenKind kind);Expr parse_local(File file,vec_Token tokens,int32_t* index,int32_t op_level);Expr* alloc_Expr(Expr obj);void vec_VarName_push(vec_VarName* this,VarName item);Expr parse_global(File file,vec_Token tokens,int32_t* index);uint8_t* parse_label(File file,vec_Token tokens,int32_t* index,uint8_t opt);vec_Expr parse_tags(File file,vec_Token tokens,int32_t* index);Expr parse_path(File file,vec_Token tokens,int32_t* index);Expr parse_opt_path(File file,vec_Token tokens,int32_t* index);void vec_PathPart_push(vec_PathPart* this,PathPart item);vec_Expr parse_fields(File file,vec_Token tokens,int32_t* index);vec_Expr parse_options(File file,vec_Token tokens,int32_t* index);void print_exprs(vec_Expr exprs);void print_expr_vec(vec_Expr exprs,int32_t depth);void print_opt_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name,uint8_t _next);void print_expr(Expr expr,int32_t depth);uint8_t* get_expr_name(ExprKind kind);void indent(int32_t depth);Location get_location(uint8_t* file,int32_t index);void print_snippet(arr_u8 file,Location location);void throw(File file,int32_t index,uint8_t* error,...);void push_char(vec_u8* v,uint8_t c);union CommandUnion{char _;};struct Command{int type;union CommandUnion u;};struct vec_u8{uint8_t* buf;int32_t len;int32_t cap;};struct vec_Expr{Expr* buf;int32_t len;int32_t cap;};union TokenKindUnion{char _;};struct TokenKind{int type;union TokenKindUnion u;};struct Token{TokenKind kind;int32_t index;uint8_t* value;};struct vec_Token{Token* buf;int32_t len;int32_t cap;};union ColorUnion{char _;};struct Color{int type;union ColorUnion u;};struct arr_u8{uint8_t* buf;int32_t len;};struct File{uint8_t* name;arr_u8 data;};struct vec_PathPart{PathPart* buf;int32_t len;int32_t cap;};struct vec_VarName{VarName* buf;int32_t len;int32_t cap;};struct PathPart{uint8_t* name;vec_Expr gens;};struct VarName{uint8_t* name;};typedef struct{uint8_t* name;vec_Expr args;}ExprKind_Tag;typedef struct{vec_PathPart path;}ExprKind_Path;typedef struct{Expr* path;vec_Expr args;vec_Expr body;}ExprKind_TagDef;typedef struct{vec_Expr body;}ExprKind_Block;typedef struct{Expr* path;}ExprKind_Mod;typedef struct{Expr* path;}ExprKind_Use;typedef struct{Expr* _type;uint8_t* name;}ExprKind_Field;typedef struct{Expr* path;vec_Expr fields;vec_Expr body;}ExprKind_Comp;typedef struct{Expr* path;vec_Expr fields;vec_Expr opts;vec_Expr body;}ExprKind_Enum;typedef struct{uint8_t* name;vec_Expr fields;}ExprKind_Option;typedef struct{Expr* path;vec_Expr body;}ExprKind_Prop;typedef struct{Expr* _prop;Expr* target;vec_Expr body;}ExprKind_Def;typedef struct{Expr* ret_type;Expr* path;vec_Expr args;vec_Expr body;}ExprKind_SubDef;typedef struct{Expr* _type;Expr* path;Expr* value;}ExprKind_VarDef;typedef struct{Expr* _type;uint8_t* name;Expr* value;}ExprKind_LocalVarDef;typedef struct{Expr* path;vec_Expr args;}ExprKind_SubCall;typedef struct{Expr* path;}ExprKind_VarUse;typedef struct{uint8_t* value;}ExprKind_StringLit;typedef struct{uint8_t* value;}ExprKind_CharLit;typedef struct{uint8_t* value;}ExprKind_IntLit;typedef struct{uint8_t* value;}ExprKind_FloatLit;typedef struct{uint8_t value;}ExprKind_BoolLit;typedef struct{vec_Expr body;}ExprKind_LocalBlock;typedef struct{Expr* _if;vec_Expr _elif;Expr* _else;}ExprKind_If;typedef struct{Expr* cond;vec_Expr body;}ExprKind_IfBranch;typedef struct{vec_Expr body;}ExprKind_ElseBranch;typedef struct{vec_Expr body;}ExprKind_Loop;typedef struct{Expr* cond;vec_Expr body;}ExprKind_While;typedef struct{uint8_t* iter;Expr* iter_value;Expr* cond;vec_Expr _next;vec_Expr body;}ExprKind_For;typedef struct{vec_VarName vars;Expr* iter;vec_Expr body;}ExprKind_Each;typedef struct{Expr* value;vec_Expr cases;}ExprKind_Match;typedef struct{vec_Expr values;vec_Expr body;}ExprKind_Case;typedef struct{uint8_t* label;Expr* value;}ExprKind_Ret;typedef struct{uint8_t* label;}ExprKind_Next;typedef struct{uint8_t* label;}ExprKind_Jump;typedef struct{uint8_t* label;Expr* value;}ExprKind_Try;typedef struct{Expr* value;TokenKind kind;}ExprKind_UnaryOp;typedef struct{Expr* lhs;Expr* rhs;TokenKind kind;}ExprKind_BinaryOp;typedef struct{Expr* cond;Expr* valueA;Expr* valueB;}ExprKind_TernaryOp;union ExprKindUnion{ExprKind_Tag u0;ExprKind_Path u1;ExprKind_TagDef u2;ExprKind_Block u3;ExprKind_Mod u4;ExprKind_Use u5;ExprKind_Field u6;ExprKind_Comp u7;ExprKind_Enum u8;ExprKind_Option u9;ExprKind_Prop u10;ExprKind_Def u11;ExprKind_SubDef u12;ExprKind_VarDef u13;ExprKind_LocalVarDef u14;ExprKind_SubCall u15;ExprKind_VarUse u16;ExprKind_StringLit u17;ExprKind_CharLit u18;ExprKind_IntLit u19;ExprKind_FloatLit u20;ExprKind_BoolLit u21;ExprKind_LocalBlock u24;ExprKind_If u25;ExprKind_IfBranch u26;ExprKind_ElseBranch u27;ExprKind_Loop u28;ExprKind_While u29;ExprKind_For u30;ExprKind_Each u31;ExprKind_Match u32;ExprKind_Case u33;ExprKind_Ret u34;ExprKind_Next u35;ExprKind_Jump u36;ExprKind_Try u37;ExprKind_UnaryOp u38;ExprKind_BinaryOp u39;ExprKind_TernaryOp u40;char _;};struct ExprKind{int type;union ExprKindUnion u;};struct Expr{ExprKind kind;vec_Expr tags;uint8_t* label;};struct Location{int32_t line;int32_t column;};typedef struct dirent dirent;vec_u8 vec_u8_new(int32_t cap){return (vec_u8){.buf=malloc(sizeof(uint8_t)*cap),.len=0,.cap=cap,};};void vec_u8_push(vec_u8* this,uint8_t item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(uint8_t)*((*this).cap));}};vec_Token vec_Token_new(int32_t cap){return (vec_Token){.buf=malloc(sizeof(Token)*cap),.len=0,.cap=cap,};};void vec_u8_empty(vec_u8* this){(((*this).buf)[0])=(((*this).len)=0);};void vec_Token_push(vec_Token* this,Token item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Token)*((*this).cap));}};arr_u8 arr_u8_new(int32_t len){return (arr_u8){.buf=malloc(sizeof(uint8_t)*len),.len=len,};};vec_PathPart vec_PathPart_new(int32_t cap){return (vec_PathPart){.buf=malloc(sizeof(PathPart)*cap),.len=0,.cap=cap,};};vec_VarName vec_VarName_new(int32_t cap){return (vec_VarName){.buf=malloc(sizeof(VarName)*cap),.len=0,.cap=cap,};};vec_Expr vec_Expr_new(int32_t cap){return (vec_Expr){.buf=malloc(sizeof(Expr)*cap),.len=0,.cap=cap,};};void vec_Expr_push(vec_Expr* this,Expr item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Expr)*((*this).cap));}};Expr* alloc_Expr(Expr obj){Expr* foo=malloc(sizeof(Expr));(*foo)=obj;return foo;};void vec_VarName_push(vec_VarName* this,VarName item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(VarName)*((*this).cap));}};void vec_PathPart_push(vec_PathPart* this,PathPart item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(PathPart)*((*this).cap));}};void command_help(uint8_t* n,uint8_t* d,uint8_t* o){printf(d);printf("\n\nUSAGE:\n    cup ");printf(n);printf(" [OPTIONS]\n\nOPTIONS:");printf(o);printf("\n");};uint8_t* command_options_empty="\n    No options are available for this command";uint8_t* command_options_compile="\n    -i, --input     Specify the input file name\n    -o, --output    Specify the output file name\n    -cg, --gcc     Use GCC as a compiler\n    -cm, --msvc    Use MSVC as a compiler\n    -cc, --clang   use Clang as a compiler\n    -ct, --tcc     Use TinyCC as a compiler";Command get_command(int32_t argc,uint8_t** argv){if (argc==1) {return (Command){1};}uint8_t is_command=0;vec_u8 vector=vec_u8_new(16);for(int i=1;i<argc;i+=1) {if (i==4) {goto brk_l;}if (((argv[i])[0])=='-') {if (is_command) {goto brk_l;}goto l;}is_command=1;int32_t length=strlen(argv[i]);for(int c=0;c<length;c+=1) {vec_u8_push((&vector),(argv[i])[c]);}l:}brk_l:vec_u8_push((&vector),'\0');uint8_t* input=vector.buf;if (strcmp(input,"help")==0) {return (Command){1};} else if (strcmp(input,"helprun")==0) {return (Command){2};} else if (strcmp(input,"helpbuild")==0) {return (Command){3};} else if (strcmp(input,"helpcheck")==0) {return (Command){4};} else if (strcmp(input,"helpupdate")==0) {return (Command){6};} else if (strcmp(input,"helpadd")==0) {return (Command){7};} else if (strcmp(input,"helpremove")==0) {return (Command){8};} else if (strcmp(input,"helpgendocs")==0) {return (Command){9};} else if (strcmp(input,"helpgenbinds")==0) {return (Command){10};} else if (strcmp(input,"helpselfupdate")==0) {return (Command){11};} else if (strcmp(input,"helpselfinstall")==0) {return (Command){12};} else if (strcmp(input,"helpselfuninstall")==0) {return (Command){13};} else if (strcmp(input,"run")==0) {return (Command){14};} else if (strcmp(input,"build")==0) {return (Command){15};} else if (strcmp(input,"check")==0) {return (Command){16};} else if (strcmp(input,"update")==0) {return (Command){18};} else if (strcmp(input,"add")==0) {return (Command){19};} else if (strcmp(input,"remove")==0) {return (Command){20};} else if (strcmp(input,"gendocs")==0) {return (Command){21};} else if (strcmp(input,"genbinds")==0) {return (Command){22};} else if (strcmp(input,"selfupdate")==0) {return (Command){23};} else if (strcmp(input,"selfinstall")==0) {return (Command){24};} else if (strcmp(input,"selfuninstall")==0) {return (Command){25};}return (Command){0};};void generate_vector(vec_Expr ast){};int32_t get_token_length(TokenKind kind){if(kind.type==7){return 4;}else if(kind.type==8){return 5;}else if(kind.type==9){return 4;}else if(kind.type==10){return 4;}else if(kind.type==11){return 4;}else if(kind.type==12){return 3;}else if(kind.type==13){return 3;}else if(kind.type==14){return 3;}else if(kind.type==15){return 4;}else if(kind.type==16){return 4;}else if(kind.type==17){return 4;}else if(kind.type==18){return 3;}else if(kind.type==19){return 3;}else if(kind.type==20){return 3;}else if(kind.type==21){return 5;}else if(kind.type==22){return 2;}else if(kind.type==23){return 4;}else if(kind.type==24){return 4;}else if(kind.type==25){return 4;}else if(kind.type==26){return 5;}else if(kind.type==27){return 3;}else if(kind.type==28){return 4;}else if(kind.type==29){return 2;}else if(kind.type==30){return 5;}else if(kind.type==31){return 3;}else if(kind.type==32){return 4;}else if(kind.type==33){return 4;}else if(kind.type==34){return 3;}else if(kind.type==35){return 2;}else if(kind.type==36){return 3;}else if(kind.type==37){return 1;}else if(kind.type==38){return 1;}else if(kind.type==39){return 1;}else if(kind.type==40){return 1;}else if(kind.type==41){return 1;}else if(kind.type==42){return 1;}else if(kind.type==43){return 1;}else if(kind.type==44){return 1;}else if(kind.type==45){return 1;}else if(kind.type==46){return 1;}else if(kind.type==47){return 1;}else if(kind.type==48){return 1;}else if(kind.type==49){return 1;}else if(kind.type==50){return 1;}else if(kind.type==51){return 1;}else if(kind.type==52){return 1;}else if(kind.type==53){return 2;}else if(kind.type==54){return 1;}else if(kind.type==55){return 2;}else if(kind.type==56){return 1;}else if(kind.type==57){return 1;}else if(kind.type==58){return 1;}else if(kind.type==59){return 2;}else if(kind.type==60){return 1;}else if(kind.type==61){return 2;}else if(kind.type==62){return 1;}else if(kind.type==63){return 2;}else if(kind.type==64){return 1;}else if(kind.type==65){return 2;}else if(kind.type==66){return 1;}else if(kind.type==67){return 2;}else if(kind.type==68){return 1;}else if(kind.type==69){return 2;}else if(kind.type==70){return 1;}else if(kind.type==71){return 2;}};uint8_t* get_token_name(TokenKind kind){if(kind.type==1){return "EMPTY";}else if(kind.type==2){return "IDENT";}else if(kind.type==3){return "STRING_LIT";}else if(kind.type==4){return "CHAR_LIT";}else if(kind.type==5){return "INT_LIT";}else if(kind.type==6){return "FLOAT_LIT";}else if(kind.type==7){return "TRUE";}else if(kind.type==8){return "FALSE";}else if(kind.type==9){return "NONE";}else if(kind.type==10){return "THIS";}else if(kind.type==11){return "TYPE";}else if(kind.type==12){return "TAG";}else if(kind.type==13){return "MOD";}else if(kind.type==14){return "USE";}else if(kind.type==15){return "COMP";}else if(kind.type==16){return "ENUM";}else if(kind.type==17){return "PROP";}else if(kind.type==18){return "DEF";}else if(kind.type==19){return "SUB";}else if(kind.type==20){return "VAR";}else if(kind.type==21){return "WHERE";}else if(kind.type==22){return "IF";}else if(kind.type==23){return "ELIF";}else if(kind.type==24){return "ELSE";}else if(kind.type==25){return "LOOP";}else if(kind.type==26){return "WHILE";}else if(kind.type==27){return "FOR";}else if(kind.type==28){return "EACH";}else if(kind.type==29){return "IN";}else if(kind.type==30){return "MATCH";}else if(kind.type==31){return "RET";}else if(kind.type==32){return "NEXT";}else if(kind.type==33){return "JUMP";}else if(kind.type==34){return "TRY";}else if(kind.type==35){return "AS";}else if(kind.type==36){return "HAS";}else if(kind.type==37){return "SEMICOLON";}else if(kind.type==38){return "COLON";}else if(kind.type==39){return "COMMA";}else if(kind.type==40){return "DOT";}else if(kind.type==41){return "QUESTION_MARK";}else if(kind.type==42){return "TILDE";}else if(kind.type==43){return "HASH";}else if(kind.type==44){return "LEFT_PAREN";}else if(kind.type==45){return "RIGHT_PAREN";}else if(kind.type==46){return "LEFT_BRACE";}else if(kind.type==47){return "RIGHT_BRACE";}else if(kind.type==48){return "LEFT_BRACKET";}else if(kind.type==49){return "RIGHT_BRACKET";}else if(kind.type==50){return "DEREF";}else if(kind.type==51){return "ADDRESS";}else if(kind.type==52){return "ASSIGN";}else if(kind.type==53){return "EQUAL";}else if(kind.type==54){return "NOT";}else if(kind.type==55){return "NOT_EQUAL";}else if(kind.type==56){return "AND";}else if(kind.type==57){return "OR";}else if(kind.type==58){return "LESS";}else if(kind.type==59){return "LESS_EQUAL";}else if(kind.type==60){return "GREATER";}else if(kind.type==61){return "GREATER_EQUAL";}else if(kind.type==62){return "ADD";}else if(kind.type==63){return "ADD_ASSIGN";}else if(kind.type==64){return "SUBTRACT";}else if(kind.type==65){return "SUBTRACT_ASSIGN";}else if(kind.type==66){return "MULTIPLY";}else if(kind.type==67){return "MULTIPLY_ASSIGN";}else if(kind.type==68){return "DIVIDE";}else if(kind.type==69){return "DIVIDE_ASSIGN";}else if(kind.type==70){return "MODULO";}else if(kind.type==71){return "MODULO_ASSIGN";}};void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal){if ((is_literal==2)&&(((*value).len)==4)) {throw(file,i,"too many characters in character literal");}push_char(value,c);};TokenKind get_keyword(uint8_t* value){if (strcmp(value,"tag")==0) {return (TokenKind){12};} else if (strcmp(value,"mod")==0) {return (TokenKind){13};} else if (strcmp(value,"use")==0) {return (TokenKind){14};} else if (strcmp(value,"comp")==0) {return (TokenKind){15};} else if (strcmp(value,"enum")==0) {return (TokenKind){16};} else if (strcmp(value,"prop")==0) {return (TokenKind){17};} else if (strcmp(value,"def")==0) {return (TokenKind){18};} else if (strcmp(value,"sub")==0) {return (TokenKind){19};} else if (strcmp(value,"var")==0) {return (TokenKind){20};} else if (strcmp(value,"this")==0) {return (TokenKind){10};} else if (strcmp(value,"type")==0) {return (TokenKind){11};} else if (strcmp(value,"where")==0) {return (TokenKind){21};} else if (strcmp(value,"true")==0) {return (TokenKind){7};} else if (strcmp(value,"false")==0) {return (TokenKind){8};} else if (strcmp(value,"none")==0) {return (TokenKind){9};} else if (strcmp(value,"if")==0) {return (TokenKind){22};} else if (strcmp(value,"elif")==0) {return (TokenKind){23};} else if (strcmp(value,"else")==0) {return (TokenKind){24};} else if (strcmp(value,"loop")==0) {return (TokenKind){25};} else if (strcmp(value,"while")==0) {return (TokenKind){26};} else if (strcmp(value,"for")==0) {return (TokenKind){27};} else if (strcmp(value,"each")==0) {return (TokenKind){28};} else if (strcmp(value,"in")==0) {return (TokenKind){29};} else if (strcmp(value,"match")==0) {return (TokenKind){30};} else if (strcmp(value,"ret")==0) {return (TokenKind){31};} else if (strcmp(value,"next")==0) {return (TokenKind){32};} else if (strcmp(value,"jump")==0) {return (TokenKind){33};} else if (strcmp(value,"try")==0) {return (TokenKind){34};} else if (strcmp(value,"as")==0) {return (TokenKind){35};} else if (strcmp(value,"has")==0) {return (TokenKind){36};}return (TokenKind){1};};uint8_t is_binary_operator(TokenKind kind){if(kind.type==44){return 1;}else if(kind.type==52){return 1;}else if(kind.type==53){return 1;}else if(kind.type==55){return 1;}else if(kind.type==56){return 1;}else if(kind.type==57){return 1;}else if(kind.type==58){return 1;}else if(kind.type==59){return 1;}else if(kind.type==60){return 1;}else if(kind.type==61){return 1;}else if(kind.type==62){return 1;}else if(kind.type==63){return 1;}else if(kind.type==64){return 1;}else if(kind.type==65){return 1;}else if(kind.type==66){return 1;}else if(kind.type==67){return 1;}else if(kind.type==68){return 1;}else if(kind.type==69){return 1;}else if(kind.type==70){return 1;}else if(kind.type==71){return 1;}else if(kind.type==35){return 1;}else if(kind.type==36){return 1;}else{return 0;}};vec_Token lex(File file){vec_Token tokens=vec_Token_new(32);uint8_t is_comment=0;uint8_t is_literal=0;vec_u8 value=vec_u8_new(8);vec_u8_empty((&value));for(int i=0;i<=((file.data).len);i+=1) {uint8_t c=((file.data).buf)[i];if (((((is_literal!=1)&&(is_literal!=2))&&(is_literal!=3))&&(is_literal!=4))&&(c=='`')) {is_comment=1;goto l;}if (is_comment!=0) {if (c=='\n') {is_comment=0;}goto l;}TokenKind kind=(TokenKind){0};if ((is_literal==3)||(is_literal==4)) {is_literal-=2;}if ((is_literal==1)||(is_literal==2)) {if (c==0) {if (is_literal==1) {throw(file,i-1,"expected end of string literal");} else {throw(file,i-1,"expected end of char literal");}} else if ((is_literal==1)&&(c=='"')) {} else if ((is_literal==2)&&(c==39)) {} else {add_to_value(file,(&value),i,c,is_literal);goto l;}}if ((c==0)||isspace(c)) {kind=(TokenKind){1};} else {if (c=='"') {if (is_literal==1) {kind=(TokenKind){3};is_literal=0;} else {kind=(TokenKind){1};is_literal=3;}} else if (c==39) {if (is_literal==2) {kind=(TokenKind){4};is_literal=0;} else {kind=(TokenKind){1};is_literal=4;}} else if (c==';') {kind=(TokenKind){37};} else if (c==':') {kind=(TokenKind){38};} else if (c==',') {kind=(TokenKind){39};} else if (c=='.') {uint8_t n=((file.data).buf)[(i+1)];if ((is_literal!=5)||((n=='_')||isalpha(n))) {kind=(TokenKind){40};}} else if (c=='?') {kind=(TokenKind){41};} else if (c=='~') {kind=(TokenKind){42};} else if (c=='#') {kind=(TokenKind){43};} else if (c=='(') {kind=(TokenKind){44};} else if (c==')') {kind=(TokenKind){45};} else if (c=='{') {kind=(TokenKind){46};} else if (c=='}') {kind=(TokenKind){47};} else if (c=='[') {kind=(TokenKind){48};} else if (c==']') {kind=(TokenKind){49};} else if (c=='@') {kind=(TokenKind){50};} else if (c=='$') {kind=(TokenKind){51};} else if (c=='&') {kind=(TokenKind){56};} else if (c=='|') {kind=(TokenKind){57};} else if (c=='=') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){53};i+=1;} else {kind=(TokenKind){52};}} else if (c=='!') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){55};i+=1;} else {kind=(TokenKind){54};}} else if (c=='<') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){59};i+=1;} else {kind=(TokenKind){58};}} else if (c=='>') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){61};i+=1;} else {kind=(TokenKind){60};}} else if (c=='+') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){63};i+=1;} else {kind=(TokenKind){62};}} else if (c=='-') {if (is_binary_operator(((tokens.buf)[((tokens.len)-1)]).kind)&&isdigit(((file.data).buf)[(i+1)])) {goto brk_ll;}if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){65};i+=1;} else {kind=(TokenKind){64};}} else if (c=='*') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){67};i+=1;} else {kind=(TokenKind){66};}} else if (c=='/') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){69};i+=1;} else {kind=(TokenKind){68};}} else if (c=='%') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){71};i+=1;} else {kind=(TokenKind){70};}}}brk_ll:if(kind.type==0){if (((((c=='-')||(c=='_'))||(c=='.'))||(c==':'))||isalnum(c)) {if ((((value.len)==0)&&isdigit(c))||(c=='-')) {is_literal=5;} else if ((is_literal==5)||(is_literal==6)) {if ((c=='.')&&(is_literal==5)) {is_literal=6;} else if ((c=='_')||isdigit(c)) {} else {throw(file,i-(value.len),"invalid identifier name starting with a digit");}}if (((is_literal!=5)&&(is_literal!=6))||(c!='_')) {add_to_value(file,(&value),i,c,is_literal);}} else {throw(file,i,"unexpected symbol %c",c);}}else{if ((value.len)>0) {if(kind.type==3){}else if(kind.type==4){}else{TokenKind value_kind=get_keyword(value.buf);if(value_kind.type==1){Token token;if (is_literal==5) {(token.kind)=(TokenKind){5};} else if (is_literal==6) {(token.kind)=(TokenKind){6};if (((value.buf)[((value.len)-1)])=='.') {throw(file,i-1,"expected a value after the decimal point");}} else {(token.kind)=(TokenKind){2};}(token.index)=(i-(value.len));(token.value)=(value.buf);vec_Token_push((&tokens),token);}else{Token token=(Token){.kind=value_kind,.index=i-get_token_length(value_kind),};vec_Token_push((&tokens),token);}value=vec_u8_new(8);vec_u8_empty((&value));is_literal=0;}}if(kind.type==1){}else{Token token=(Token){.kind=kind,};if(kind.type==3){(token.value)=(value.buf);(token.index)=(i-(value.len));value=vec_u8_new(8);vec_u8_empty((&value));}else if(kind.type==4){(token.value)=(value.buf);(token.index)=(i-(value.len));value=vec_u8_new(8);vec_u8_empty((&value));}else{(token.index)=((i-get_token_length(kind))+1);}vec_Token_push((&tokens),token);}}l:}brk_l:Token last;if ((tokens.len)>0) {last=((tokens.buf)[((tokens.len)-1)]);(last.index)=((last.index)+get_token_length(last.kind));} else {(last.index)=0;}(last.kind)=(TokenKind){1};vec_Token_push((&tokens),last);return tokens;};void print_tokens(vec_Token tokens){printf("Tokens:\n");for(int i=0;i<(tokens.len);i+=1) {TokenKind kind=((tokens.buf)[i]).kind;set_color((Color){1});printf("  %s",get_token_name(kind));set_color((Color){0});if(kind.type==2){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==3){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==4){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==5){printf("(%s)",((tokens.buf)[i]).value);}else if(kind.type==6){printf("(%s)",((tokens.buf)[i]).value);}putchar('\n');}putchar('\n');};int32_t main(int32_t argc,uint8_t** argv){Command command=get_command(argc,argv);if(command.type==0){set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such command: '%s",argv[1]);for(int i=2;i<argc;i+=1) {printf(" %s",argv[i]);}printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;}else if(command.type==14){goto brk_m;}else if(command.type==15){goto brk_m;}else if(command.type==16){return 1;}else if(command.type==17){return 1;}else if(command.type==18){return 1;}else if(command.type==19){return 1;}else if(command.type==20){return 1;}else if(command.type==21){return 1;}else if(command.type==22){return 1;}else if(command.type==23){return 1;}else if(command.type==24){return 1;}else if(command.type==25){return 1;}else if(command.type==1){printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;}else if(command.type==2){command_help("run","Compile and run the current package",command_options_compile);return 0;}else if(command.type==3){command_help("build","Compile the current package",command_options_compile);return 0;}else if(command.type==4){command_help("check","Analyze the current package",command_options_empty);return 0;}else if(command.type==5){command_help("new","Create a new package",command_options_empty);return 0;}else if(command.type==6){command_help("update","Update given dependency",command_options_empty);return 0;}else if(command.type==7){command_help("add","Adds given dependency",command_options_empty);return 0;}else if(command.type==8){command_help("remove","Removes given dependency",command_options_empty);return 0;}else if(command.type==9){command_help("gen docs","Generate documentation for the current package",command_options_empty);return 0;}else if(command.type==10){command_help("gen binds","Generate bindings for a given C header file",command_options_empty);return 0;}else if(command.type==11){command_help("self update","Update the Cup Toolkit",command_options_empty);return 0;}else if(command.type==12){command_help("self install","Install the Cup Toolkit",command_options_empty);return 0;}else if(command.type==13){command_help("self uninstall","Uninstall the Cup Toolkite",command_options_empty);return 0;}brk_m:uint8_t* input=(void*)0;uint8_t* output=(void*)0;for(int i=2;i<argc;i+=1) {if (((argv[i])[0])=='-') {if (((argv[i])[1])=='i') {if (input==(void*)0) {input=get_option((&i),argc,argv);}} else if (((argv[i])[1])=='o') {if (output==(void*)0) {output=get_option((&i),argc,argv);}}} else {set_color((Color){3});printf("error: ");set_color((Color){0});printf("invalid option '%s'",argv[i]);}}if (input==(void*)0) {input=".";}if (output==(void*)0) {output="out.c";}lex_parse_recursive(input);printf("Compilation ");set_color((Color){2});printf("successful");set_color((Color){0});printf(" (%.1lfs elapsed)\n",((double)clock())/CLOCKS_PER_SEC);return 0;};uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv){if (strlen(argv[(*index)])>2) {return (argv[(*index)])+1;} else if (argc>(*index)) {return argv[((*index)+=1)];}return (void*)0;};void set_color(Color color){if(color.type==0){printf("\033[0m");}else if(color.type==1){printf("\033[35m");}else if(color.type==2){printf("\033[32m");}else if(color.type==3){printf("\033[0;31m");}};void lex_parse_recursive(uint8_t* path){DIR* dir=opendir(path);if (dir==(void*)0) {set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such file or directory: '%s'\n",path);exit(1);}dirent* ent;while((ent=readdir(dir))!=(void*)0) {int32_t new_length=strlen((*ent).d_name);if ((new_length==1)&&((((*ent).d_name)[0])=='.')) {} else if (((new_length==2)&&((((*ent).d_name)[0])=='.'))&&((((*ent).d_name)[1])=='.')) {} else {int32_t length=strlen(path);uint8_t* new_path=malloc(((length+1)+new_length)+1);memcpy(new_path,path,length);(new_path[length])='/';memcpy((new_path+length)+1,(*ent).d_name,new_length);(new_path[((length+new_length)+1)])='\0';if (((*ent).d_type)==DT_DIR) {lex_parse_recursive(new_path);} else if (((*ent).d_type)==DT_REG) {FILE* file_point=fopen(new_path,"rb");fseek(file_point,(int32_t)0,SEEK_END);arr_u8 file=arr_u8_new(ftell(file_point)+1);rewind(file_point);(file.len)-=1;fread(file.buf,file.len,1,file_point);((file.buf)[(file.len)])='\0';fclose(file_point);printf("Compiling %s:\n",new_path);File abc=(File){.name=new_path,.data=file,};vec_Token tokens=lex(abc);print_tokens(tokens);vec_Expr exprs=parse(abc,tokens);print_exprs(exprs);free(file.buf);}free(new_path);}}closedir(dir);};void REMOVE_ME(){vec_PathPart_new(0);vec_VarName_new(0);};vec_Expr parse(File file,vec_Token tokens){int32_t index=0;vec_Expr exprs=vec_Expr_new(16);for(;;) {if(((tokens.buf)[index]).kind.type==1){return exprs;}vec_Expr_push((&exprs),parse_global(file,tokens,(&index)));if(((tokens.buf)[index]).kind.type==37){}else if(((tokens.buf)[index]).kind.type==1){return exprs;}else{throw(file,((tokens.buf)[index]).index,"unexpected token after last expr");}index+=1;}};vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local){vec_Expr exprs=vec_Expr_new(4);for(;;) {if(((tokens.buf)[(*index)]).kind.type==47){(*index)+=1;return exprs;}Expr expr;if (local) {expr=parse_local(file,tokens,index,0);} else {expr=parse_global(file,tokens,index);}vec_Expr_push((&exprs),expr);if(((tokens.buf)[(*index)]).kind.type==37){}else if(((tokens.buf)[(*index)]).kind.type==47){(*index)+=1;return exprs;}else{throw(file,((tokens.buf)[(*index)]).index,"unexpected token after last expr");}(*index)+=1;}};Token expect_token(File file,vec_Token tokens,int32_t* index,TokenKind kind,uint8_t* error){Token token=(tokens.buf)[(*index)];if(token.kind.type==0){}else if(token.kind.type==kind.type){}else{throw(file,token.index,error);}(*index)+=1;return token;};uint8_t opt_token(vec_Token tokens,int32_t* index,TokenKind kind){if(((tokens.buf)[(*index)]).kind.type==0){}else if(((tokens.buf)[(*index)]).kind.type==kind.type){(*index)+=1;return 1;}else{return 0;}};Expr parse_local(File file,vec_Token tokens,int32_t* index,int32_t op_level){Expr expr;(expr.label)=parse_label(file,tokens,index,1);(expr.tags)=parse_tags(file,tokens,index);Token token=(tokens.buf)[(*index)];if(token.kind.type==2){Expr* path=alloc_Expr(parse_path(file,tokens,index));if (opt_token(tokens,index,(TokenKind){44})) {vec_Expr args=vec_Expr_new(2);for(;;) {if (opt_token(tokens,index,(TokenKind){45})) {goto brk_ll;}vec_Expr_push((&args),parse_local(file,tokens,index,0));if (opt_token(tokens,index,(TokenKind){39})==0) {expect_token(file,tokens,index,(TokenKind){45},"expected ')' after last argument");goto brk_ll;}ll:}brk_ll:(expr.kind)=(ExprKind){.type=15,.u={.u15={.path=path,.args=args,}}};goto brk_l;}if (opt_token(tokens,index,(TokenKind){2})) {uint8_t* name=((tokens.buf)[((*index)-1)]).value;Expr* value=(void*)0;if (opt_token(tokens,index,(TokenKind){52})) {value=alloc_Expr(parse_local(file,tokens,index,0));}(expr.kind)=(ExprKind){.type=14,.u={.u14={._type=path,.name=name,.value=value,}}};goto brk_l;}(expr.kind)=(ExprKind){.type=16,.u={.u16={.path=path,}}};}else if(token.kind.type==20){(*index)+=1;uint8_t* name=expect_token(file,tokens,index,(TokenKind){2},"expected identifier after 'var' keyword").value;Expr* value=(void*)0;if (opt_token(tokens,index,(TokenKind){52})) {value=alloc_Expr(parse_local(file,tokens,index,0));}(expr.kind)=(ExprKind){.type=14,.u={.u14={._type=(void*)0,.name=name,.value=value,}}};}else if(token.kind.type==3){(expr.kind)=(ExprKind){.type=17,.u={.u17={.value=token.value,}}};(*index)+=1;}else if(token.kind.type==4){(expr.kind)=(ExprKind){.type=18,.u={.u18={.value=token.value,}}};(*index)+=1;}else if(token.kind.type==5){(expr.kind)=(ExprKind){.type=19,.u={.u19={.value=token.value,}}};(*index)+=1;}else if(token.kind.type==6){(expr.kind)=(ExprKind){.type=20,.u={.u20={.value=token.value,}}};(*index)+=1;}else if(token.kind.type==7){(expr.kind)=(ExprKind){.type=21,.u={.u21={.value=1,}}};(*index)+=1;}else if(token.kind.type==8){(expr.kind)=(ExprKind){.type=21,.u={.u21={.value=0,}}};(*index)+=1;}else if(token.kind.type==10){(expr.kind)=(ExprKind){22};(*index)+=1;}else if(token.kind.type==11){(expr.kind)=(ExprKind){23};(*index)+=1;}else if(token.kind.type==46){(*index)+=1;vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){.type=24,.u={.u24={.body=body,}}};}else if(token.kind.type==22){(*index)+=1;Expr* cond=alloc_Expr(parse_local(file,tokens,index,0));expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'if' condition");vec_Expr body=parse_block(file,tokens,index,1);Expr* _if=alloc_Expr((Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){.type=26,.u={.u26={.cond=cond,.body=body,}}},});vec_Expr _elif=vec_Expr_new(1);while(opt_token(tokens,index,(TokenKind){23})) {cond=alloc_Expr(parse_local(file,tokens,index,0));expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'elif' condition");vec_Expr body=parse_block(file,tokens,index,1);vec_Expr_push((&_elif),(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){.type=26,.u={.u26={.cond=cond,.body=body,}}},});}if (opt_token(tokens,index,(TokenKind){24})) {expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'else' keyword");vec_Expr body=parse_block(file,tokens,index,1);vec_Expr_push((&_elif),(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){.type=27,.u={.u27={.body=body,}}},});}(expr.kind)=(ExprKind){.type=25,.u={.u25={._if=_if,._elif=_elif,._else=(void*)0,}}};}else if(token.kind.type==25){(*index)+=1;expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'loop' keyword");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){.type=28,.u={.u28={.body=body,}}};}else if(token.kind.type==26){(*index)+=1;Expr* cond=alloc_Expr(parse_local(file,tokens,index,0));expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'while' condition");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){.type=29,.u={.u29={.cond=cond,.body=body,}}};}else if(token.kind.type==27){(*index)+=1;uint8_t* iter=expect_token(file,tokens,index,(TokenKind){2},"expected 'for' iterator name").value;Expr* iter_value=(void*)0;if (opt_token(tokens,index,(TokenKind){52})) {iter_value=alloc_Expr(parse_local(file,tokens,index,0));}expect_token(file,tokens,index,(TokenKind){39},"expected a ',' after 'for' iterator name");Expr* cond=alloc_Expr(parse_local(file,tokens,index,0));expect_token(file,tokens,index,(TokenKind){39},"expected a ',' after 'for' condition");Expr* _next=alloc_Expr(parse_local(file,tokens,index,0));expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'for' next");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){.type=30,.u={.u30={.iter=iter,.iter_value=iter_value,.cond=cond,._next=_next,.body=body,}}};}else if(token.kind.type==28){(*index)+=1;vec_VarName vars=vec_VarName_new(2);while(opt_token(tokens,index,(TokenKind){2})) {vec_VarName_push((&vars),(VarName){.name=tokens.buf[(*index)-1].value,});opt_token(tokens,index,(TokenKind){39});}if ((vars.len)==0) {throw(file,((tokens.buf)[((*index)-1)]).index,"expected sex");}expect_token(file,tokens,index,(TokenKind){29},"expected 'in' keyword after 'each' variables");Expr* iter=alloc_Expr(parse_local(file,tokens,index,0));expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'each' iterator");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){.type=31,.u={.u31={.vars=vars,.iter=iter,.body=body,}}};}else if(token.kind.type==30){(*index)+=1;Expr* value=alloc_Expr(parse_local(file,tokens,index,0));expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'match' value");vec_Expr body=vec_Expr_new(4);for(;;) {if (opt_token(tokens,index,(TokenKind){47})) {(expr.kind)=(ExprKind){.type=32,.u={.u32={.value=value,.cases=body,}}};goto brk_l;}vec_Expr values=vec_Expr_new(2);for(;;) {if (opt_token(tokens,index,(TokenKind){46})) {goto b;}vec_Expr_push((&values),parse_local(file,tokens,index,0));if (opt_token(tokens,index,(TokenKind){39})==0) {goto brk_llll;}llll:}brk_llll:expect_token(file,tokens,index,(TokenKind){46},"expected '{' after 'match' case value");while(0) {b:}brk_b:vec_Expr case_body=parse_block(file,tokens,index,1);vec_Expr_push((&body),(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){.type=33,.u={.u33={.values=values,.body=case_body,}}},});if (opt_token(tokens,index,(TokenKind){39})==0) {goto brk_lll;}lll:}brk_lll:expect_token(file,tokens,index,(TokenKind){47},"expected '}' after 'match' body");(expr.kind)=(ExprKind){.type=32,.u={.u32={.value=value,.cases=body,}}};}else if(token.kind.type==31){(*index)+=1;uint8_t* label=parse_label(file,tokens,index,0);Expr* value=alloc_Expr(parse_local(file,tokens,index,0));(expr.kind)=(ExprKind){.type=34,.u={.u34={.label=label,.value=value,}}};}else if(token.kind.type==32){(*index)+=1;(expr.kind)=(ExprKind){.type=35,.u={.u35={.label=parse_label(file,tokens,index,0),}}};}else if(token.kind.type==33){(*index)+=1;(expr.kind)=(ExprKind){.type=36,.u={.u36={.label=parse_label(file,tokens,index,0),}}};}else if(token.kind.type==34){(*index)+=1;uint8_t* label=parse_label(file,tokens,index,0);Expr* value=alloc_Expr(parse_local(file,tokens,index,0));(expr.kind)=(ExprKind){.type=37,.u={.u37={.label=label,.value=value,}}};}else{throw(file,token.index,"expected a local expression");}brk_l:for(;;) {int32_t new_op_level=0;if(((tokens.buf)[(*index)]).kind.type==52){new_op_level=6;}else if(((tokens.buf)[(*index)]).kind.type==63){new_op_level=6;}else if(((tokens.buf)[(*index)]).kind.type==65){new_op_level=6;}else if(((tokens.buf)[(*index)]).kind.type==67){new_op_level=6;}else if(((tokens.buf)[(*index)]).kind.type==69){new_op_level=6;}else if(((tokens.buf)[(*index)]).kind.type==71){new_op_level=6;}else if(((tokens.buf)[(*index)]).kind.type==35){new_op_level=5;}else if(((tokens.buf)[(*index)]).kind.type==58){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==56){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==57){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==59){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==60){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==61){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==53){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==55){new_op_level=4;}else if(((tokens.buf)[(*index)]).kind.type==62){new_op_level=3;}else if(((tokens.buf)[(*index)]).kind.type==64){new_op_level=3;}else if(((tokens.buf)[(*index)]).kind.type==66){new_op_level=2;}else if(((tokens.buf)[(*index)]).kind.type==68){new_op_level=2;}else if(((tokens.buf)[(*index)]).kind.type==70){new_op_level=2;}else if(((tokens.buf)[(*index)]).kind.type==40){new_op_level=1;}else if(((tokens.buf)[(*index)]).kind.type==54){new_op_level=1;}else if(((tokens.buf)[(*index)]).kind.type==50){new_op_level=1;}else if(((tokens.buf)[(*index)]).kind.type==51){new_op_level=1;}if ((new_op_level==0)||((op_level!=0)&&(new_op_level>=op_level))) {goto brk_o;}(*index)+=1;expr=(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){.type=39,.u={.u39={.lhs=alloc_Expr(expr),.rhs=alloc_Expr(parse_local(file,tokens,index,new_op_level)),.kind=(TokenKind){40},}}},};o:}brk_o:return expr;};Expr parse_global(File file,vec_Token tokens,int32_t* index){Expr expr;(expr.label)=parse_label(file,tokens,index,1);(expr.tags)=parse_tags(file,tokens,index);Token token=(tokens.buf)[(*index)];if(token.kind.type==12){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){44},"expected '(' after 'tag' path");vec_Expr args=parse_fields(file,tokens,index);vec_Expr body;if (opt_token(tokens,index,(TokenKind){46})) {body=parse_block(file,tokens,index,1);} else {(body.len)=0;}(expr.kind)=(ExprKind){.type=2,.u={.u2={.path=path,.args=args,.body=body,}}};}else if(token.kind.type==46){(*index)+=1;(expr.kind)=(ExprKind){.type=3,.u={.u3={.body=parse_block(file,tokens,index,0),}}};}else if(token.kind.type==13){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));(expr.kind)=(ExprKind){.type=4,.u={.u4={.path=path,}}};}else if(token.kind.type==14){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));(expr.kind)=(ExprKind){.type=5,.u={.u5={.path=path,}}};}else if(token.kind.type==15){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){44},"expected '(' after 'comp' path");vec_Expr fields=parse_fields(file,tokens,index);vec_Expr body;if (opt_token(tokens,index,(TokenKind){46})) {body=parse_block(file,tokens,index,1);} else {(body.len)=0;}(expr.kind)=(ExprKind){.type=7,.u={.u7={.path=path,.fields=fields,.body=body,}}};}else if(token.kind.type==16){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){44},"expected '(' after 'comp' path");vec_Expr opts=parse_options(file,tokens,index);vec_Expr body;if (opt_token(tokens,index,(TokenKind){46})) {body=parse_block(file,tokens,index,1);} else {(body.len)=0;}(expr.kind)=(ExprKind){.type=8,.u={.u8={.path=path,.fields=opts,.opts=body,}}};}else if(token.kind.type==17){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));vec_Expr body;if (opt_token(tokens,index,(TokenKind){46})) {body=parse_block(file,tokens,index,0);} else {(body.len)=0;}(expr.kind)=(ExprKind){.type=10,.u={.u10={.path=path,.body=body,}}};}else if(token.kind.type==18){(*index)+=1;Expr* _prop=alloc_Expr(parse_path(file,tokens,index));Expr* _target=(void*)0;if (opt_token(tokens,index,(TokenKind){39})) {_target=alloc_Expr(parse_path(file,tokens,index));}vec_Expr body;if (opt_token(tokens,index,(TokenKind){46})) {body=parse_block(file,tokens,index,0);} else {(body.len)=0;}(expr.kind)=(ExprKind){.type=11,.u={.u11={._prop=_prop,.target=_target,.body=body,}}};}else if(token.kind.type==19){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){44},"expected '(' after 'sub' path");vec_Expr args=parse_fields(file,tokens,index);vec_Expr body;if (opt_token(tokens,index,(TokenKind){46})) {body=parse_block(file,tokens,index,1);} else {(body.len)=0;}(expr.kind)=(ExprKind){.type=12,.u={.u12={.ret_type=(void*)0,.path=path,.args=args,.body=body,}}};}else if(token.kind.type==20){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));Expr* value=(void*)0;if (opt_token(tokens,index,(TokenKind){52})) {(*index)+=1;value=alloc_Expr(parse_local(file,tokens,index,0));}(expr.kind)=(ExprKind){.type=13,.u={.u13={._type=(void*)0,.path=path,.value=value,}}};}else if(token.kind.type==2){Expr* _type=alloc_Expr(parse_path(file,tokens,index));Expr* path=alloc_Expr(parse_path(file,tokens,index));token=((tokens.buf)[(*index)]);if(token.kind.type==44){(*index)+=1;vec_Expr args=parse_fields(file,tokens,index);vec_Expr body;if (opt_token(tokens,index,(TokenKind){46})) {body=parse_block(file,tokens,index,1);} else {(body.len)=0;}(expr.kind)=(ExprKind){.type=12,.u={.u12={.ret_type=_type,.path=path,.args=args,.body=body,}}};}else{Expr* value=(void*)0;if (opt_token(tokens,index,(TokenKind){52})) {(*index)+=1;value=alloc_Expr(parse_local(file,tokens,index,0));}(expr.kind)=(ExprKind){.type=13,.u={.u13={._type=_type,.path=path,.value=value,}}};}}else{throw(file,token.index,"expected a global expression");}return expr;};uint8_t* parse_label(File file,vec_Token tokens,int32_t* index,uint8_t opt){if (opt&&(opt_token(tokens,index,(TokenKind){42})==0)) {return (void*)0;} else if (opt==0) {expect_token(file,tokens,index,(TokenKind){42},"expected a label");}uint8_t* label=expect_token(file,tokens,index,(TokenKind){2},"expected identifier after label declaration").value;return label;};vec_Expr parse_tags(File file,vec_Token tokens,int32_t* index){vec_Expr tags=vec_Expr_new(2);for(;;) {if(((tokens.buf)[(*index)]).kind.type==43){Token token=(tokens.buf)[((*index)+=1)];if(token.kind.type==2){vec_Expr args=vec_Expr_new(1);Expr _tag=(Expr){.kind=(ExprKind){.type=0,.u={.u0={.name=token.value,.args=args,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,};token=((tokens.buf)[((*index)+=1)]);if(token.kind.type==44){for(;;) {token=((tokens.buf)[((*index)+=1)]);if(token.kind.type==45){goto brk_ll;}throw(file,token.index,"unexpected smth in 'tag' declaration");ll:}brk_ll:vec_Expr_push((&tags),_tag);(*index)+=1;}else{vec_Expr_push((&tags),_tag);goto l;}}else{throw(file,token.index,"expected identifier after tag declaration");}}else{goto brk_l;}l:}brk_l:return tags;};Expr parse_path(File file,vec_Token tokens,int32_t* index){if(((tokens.buf)[(*index)]).kind.type==2){return parse_opt_path(file,tokens,index);}else{throw(file,((tokens.buf)[(*index)]).index,"expected a path");}};Expr parse_opt_path(File file,vec_Token tokens,int32_t* index){vec_PathPart path=vec_PathPart_new(2);uint8_t need_colon=0;for(;;) {Token token=(tokens.buf)[(*index)];if (need_colon) {if(token.kind.type==38){need_colon=0;}else{goto brk_l;}} else {if(token.kind.type==2){PathPart part=(PathPart){.name=token.value,.gens=vec_Expr_new(2),};if(((tokens.buf)[((*index)+1)]).kind.type==58){int32_t old_index=(*index);(*index)+=2;for(;;) {token=((tokens.buf)[(*index)]);if(token.kind.type==60){goto brk_ll;}else{}Expr gen=parse_opt_path(file,tokens,index);if(gen.kind.type==1){vec_PathPart gen_path=gen.kind.u.u1.path;if ((gen_path.len)==0) {printf("sadasdsd!!\n");(*index)=old_index;goto brk_ll;}}vec_Expr_push((&(part.gens)),gen);opt_token(tokens,index,(TokenKind){39});ll:}brk_ll:}vec_PathPart_push((&path),part);need_colon=1;}else{if ((path.len)>0) {throw(file,token.index,"expected identifier after ':'");} else {goto brk_l;}}}(*index)+=1;l:}brk_l:return (Expr){.kind=(ExprKind){.type=1,.u={.u1={.path=path,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,};};vec_Expr parse_fields(File file,vec_Token tokens,int32_t* index){vec_Expr fields=vec_Expr_new(2);for(;;) {if (opt_token(tokens,index,(TokenKind){45})) {return fields;}Expr field=(Expr){.kind=(ExprKind){.type=6,.u={.u6={._type=alloc_Expr(parse_path(file,tokens,index)),.name=expect_token(file,tokens,index,(TokenKind){2},"expected field name in 'comp' definition").value,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,};vec_Expr_push((&fields),field);if (opt_token(tokens,index,(TokenKind){39})==0) {goto brk_l;}l:}brk_l:expect_token(file,tokens,index,(TokenKind){45},"expected ')' after last field");return fields;};vec_Expr parse_options(File file,vec_Token tokens,int32_t* index){vec_Expr opts=vec_Expr_new(2);for(;;) {if (opt_token(tokens,index,(TokenKind){45})) {return opts;}uint8_t* name=expect_token(file,tokens,index,(TokenKind){2},"expected option name in 'enum' definition").value;vec_Expr fields;if (opt_token(tokens,index,(TokenKind){44})) {fields=parse_fields(file,tokens,index);} else {(fields.len)=0;}vec_Expr_push((&opts),(Expr){.kind=(ExprKind){.type=9,.u={.u9={.name=name,.fields=fields,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,});if (opt_token(tokens,index,(TokenKind){39})==0) {goto brk_l;}l:}brk_l:expect_token(file,tokens,index,(TokenKind){45},"expected ')' after last option");return opts;};void print_exprs(vec_Expr exprs){printf("Exprs:");print_expr_vec(exprs,0);putchar('\n');};void print_expr_vec(vec_Expr exprs,int32_t depth){for(int i=0;i<(exprs.len);i+=1) {putchar('\n');indent(depth);print_expr((exprs.buf)[i],depth);}putchar('\n');};void print_opt_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name,uint8_t _next){if ((exprs.len)>0) {if (_next) {printf(", ");}printf("%s = [",name);print_expr_vec(exprs,depth+1);indent(depth);putchar(']');}};void print_expr(Expr expr,int32_t depth){set_color((Color){2});printf("%s",get_expr_name(expr.kind));set_color((Color){0});putchar('(');if ((expr.label)!=(void*)0) {printf("label = %s, ",expr.label);}print_opt_expr_vec(expr.tags,0,"tags",0);if (((expr.tags).len)!=0) {printf(", ");}if(expr.kind.type==0){uint8_t* name=expr.kind.u.u0.name;vec_Expr args=expr.kind.u.u0.args;printf("name = %s",name);print_opt_expr_vec(args,depth,"args",1);}else if(expr.kind.type==1){vec_PathPart path=expr.kind.u.u1.path;for(int i=0;i<(path.len);i+=1) {PathPart part=(path.buf)[i];if (i!=0) {printf(", ");}printf("name = %s",part.name);print_opt_expr_vec(part.gens,depth,"gens",1);}}else if(expr.kind.type==2){Expr* path=expr.kind.u.u2.path;vec_Expr args=expr.kind.u.u2.args;vec_Expr body=expr.kind.u.u2.body;print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==3){vec_Expr body=expr.kind.u.u3.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind.type==4){Expr* path=expr.kind.u.u4.path;printf("path = ");print_expr((*path),depth);}else if(expr.kind.type==5){Expr* path=expr.kind.u.u5.path;printf("path = ");print_expr((*path),depth);}else if(expr.kind.type==6){Expr* _type=expr.kind.u.u6._type;uint8_t* name=expr.kind.u.u6.name;printf("type = ");print_expr((*_type),depth);printf(", name = %s",name);}else if(expr.kind.type==7){Expr* path=expr.kind.u.u7.path;vec_Expr fields=expr.kind.u.u7.fields;vec_Expr body=expr.kind.u.u7.body;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(fields,depth,"fields",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==8){Expr* path=expr.kind.u.u8.path;vec_Expr fields=expr.kind.u.u8.fields;vec_Expr opts=expr.kind.u.u8.opts;vec_Expr body=expr.kind.u.u8.body;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(fields,depth,"fields",1);print_opt_expr_vec(opts,depth,"opts",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==9){uint8_t* name=expr.kind.u.u9.name;vec_Expr fields=expr.kind.u.u9.fields;printf("name = %s",name);print_opt_expr_vec(fields,depth,"fields",1);}else if(expr.kind.type==10){Expr* path=expr.kind.u.u10.path;vec_Expr body=expr.kind.u.u10.body;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==11){Expr* _prop=expr.kind.u.u11._prop;Expr* target=expr.kind.u.u11.target;vec_Expr body=expr.kind.u.u11.body;printf("prop = ");print_expr((*_prop),depth);if (target!=(void*)0) {printf(", target = ");print_expr((*target),depth);}print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==12){Expr* ret_type=expr.kind.u.u12.ret_type;Expr* path=expr.kind.u.u12.path;vec_Expr args=expr.kind.u.u12.args;vec_Expr body=expr.kind.u.u12.body;if (ret_type!=(void*)0) {printf("ret_type = ");print_expr((*ret_type),depth);printf(", ");}printf("path = ");print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==13){Expr* _type=expr.kind.u.u13._type;Expr* path=expr.kind.u.u13.path;Expr* value=expr.kind.u.u13.value;if (_type!=(void*)0) {printf("type = ");print_expr((*_type),depth);printf(", ");}printf("path = ");print_expr((*path),depth);if (value!=(void*)0) {printf(", value = ");print_expr((*value),depth);}}else if(expr.kind.type==14){Expr* _type=expr.kind.u.u14._type;uint8_t* name=expr.kind.u.u14.name;Expr* value=expr.kind.u.u14.value;if (_type!=(void*)0) {printf("type = ");print_expr((*_type),depth);printf(", ");}printf("name = %s",name);if (value!=(void*)0) {printf(", value = ");print_expr((*value),depth);}}else if(expr.kind.type==15){Expr* path=expr.kind.u.u15.path;vec_Expr args=expr.kind.u.u15.args;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);}else if(expr.kind.type==16){Expr* path=expr.kind.u.u16.path;printf("path = ");print_expr((*path),depth);}else if(expr.kind.type==17){uint8_t* value=expr.kind.u.u17.value;printf("%s",value);}else if(expr.kind.type==18){uint8_t* value=expr.kind.u.u18.value;printf("%s",value);}else if(expr.kind.type==19){uint8_t* value=expr.kind.u.u19.value;printf("%s",value);}else if(expr.kind.type==20){uint8_t* value=expr.kind.u.u20.value;printf("%s",value);}else if(expr.kind.type==21){uint8_t value=expr.kind.u.u21.value;if (value) {printf("true");} else {printf("false");}}else if(expr.kind.type==22){}else if(expr.kind.type==23){}else if(expr.kind.type==24){vec_Expr body=expr.kind.u.u24.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind.type==25){Expr* _if=expr.kind.u.u25._if;vec_Expr _elif=expr.kind.u.u25._elif;Expr* _else=expr.kind.u.u25._else;printf("if = ");print_expr((*_if),depth);print_opt_expr_vec(_elif,depth,"elif",1);if (_else!=(void*)0) {printf(", else = ");print_expr((*_else),depth);}}else if(expr.kind.type==26){Expr* cond=expr.kind.u.u26.cond;vec_Expr body=expr.kind.u.u26.body;printf("cond = ");print_expr((*cond),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==27){vec_Expr body=expr.kind.u.u27.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind.type==28){vec_Expr body=expr.kind.u.u28.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind.type==29){Expr* cond=expr.kind.u.u29.cond;vec_Expr body=expr.kind.u.u29.body;print_expr((*cond),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==30){uint8_t* iter=expr.kind.u.u30.iter;Expr* iter_value=expr.kind.u.u30.iter_value;Expr* cond=expr.kind.u.u30.cond;vec_Expr _next=expr.kind.u.u30._next;vec_Expr body=expr.kind.u.u30.body;printf("iter = %s",iter);if (iter_value!=(void*)0) {printf(", iter_value = ");print_expr((*iter_value),depth);}printf(", cond = ");print_expr((*cond),depth);print_opt_expr_vec(_next,depth,"next",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==31){vec_VarName vars=expr.kind.u.u31.vars;Expr* iter=expr.kind.u.u31.iter;vec_Expr body=expr.kind.u.u31.body;printf("vars = [");for(int i=0;i<(vars.len);i+=1) {if (i!=0) {printf(", ");}printf("%s",(vars.buf)[i]);}printf("], iter = ");print_expr((*iter),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==32){Expr* value=expr.kind.u.u32.value;vec_Expr cases=expr.kind.u.u32.cases;printf("value = ");print_expr((*value),depth);print_opt_expr_vec(cases,depth,"cases",1);}else if(expr.kind.type==33){vec_Expr values=expr.kind.u.u33.values;vec_Expr body=expr.kind.u.u33.body;print_opt_expr_vec(values,depth,"values",0);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind.type==34){uint8_t* label=expr.kind.u.u34.label;Expr* value=expr.kind.u.u34.value;if (label!=(void*)0) {printf("label = %s, ",label);}printf("value = ");print_expr((*value),depth);}else if(expr.kind.type==35){uint8_t* label=expr.kind.u.u35.label;if (label!=(void*)0) {printf("label = %s",label);}}else if(expr.kind.type==36){uint8_t* label=expr.kind.u.u36.label;if (label!=(void*)0) {printf("label = %s",label);}}else if(expr.kind.type==37){uint8_t* label=expr.kind.u.u37.label;Expr* value=expr.kind.u.u37.value;if (label!=(void*)0) {printf("label = %s, ",label);}printf("value = ");print_expr((*value),depth);}else if(expr.kind.type==38){Expr* value=expr.kind.u.u38.value;TokenKind kind=expr.kind.u.u38.kind;print_expr((*value),depth);}else if(expr.kind.type==39){Expr* lhs=expr.kind.u.u39.lhs;Expr* rhs=expr.kind.u.u39.rhs;TokenKind kind=expr.kind.u.u39.kind;printf("lhs = ");print_expr((*lhs),depth);printf(", rhs = ");print_expr((*rhs),depth);}else if(expr.kind.type==40){Expr* cond=expr.kind.u.u40.cond;Expr* valueA=expr.kind.u.u40.valueA;Expr* valueB=expr.kind.u.u40.valueB;print_expr((*cond),depth);print_expr((*valueA),depth);print_expr((*valueB),depth);}putchar(')');};uint8_t* get_expr_name(ExprKind kind){if(kind.type==0){return "TAG";}else if(kind.type==1){return "PATH";}else if(kind.type==2){return "TAG_DEF";}else if(kind.type==3){return "BLOCK";}else if(kind.type==4){return "MOD";}else if(kind.type==5){return "USE";}else if(kind.type==6){return "FIELD";}else if(kind.type==7){return "COMP";}else if(kind.type==8){return "ENUM";}else if(kind.type==9){return "OPTION";}else if(kind.type==10){return "PROP";}else if(kind.type==11){return "DEF";}else if(kind.type==12){return "SUB_DEF";}else if(kind.type==13){return "VAR_DEF";}else if(kind.type==14){return "LOCAL_VAR_DEF";}else if(kind.type==15){return "SUB_CALL";}else if(kind.type==16){return "VAR_USE";}else if(kind.type==17){return "STRING_LIT";}else if(kind.type==18){return "CHAR_LIT";}else if(kind.type==19){return "INT_LIT";}else if(kind.type==20){return "FLOAT_LIT";}else if(kind.type==21){return "BOOL_LIT";}else if(kind.type==22){return "THIS_LIT";}else if(kind.type==23){return "TYPE_LIT";}else if(kind.type==24){return "LOCAL_BLOCK";}else if(kind.type==25){return "IF";}else if(kind.type==26){return "IF_BRANCH";}else if(kind.type==27){return "ELSE_BRANCH";}else if(kind.type==28){return "LOOP";}else if(kind.type==29){return "WHILE";}else if(kind.type==30){return "FOR";}else if(kind.type==31){return "EACH";}else if(kind.type==32){return "MATCH";}else if(kind.type==33){return "CASE";}else if(kind.type==34){return "RET";}else if(kind.type==35){return "NEXT";}else if(kind.type==36){return "JUMP";}else if(kind.type==37){return "TRY";}else if(kind.type==38){return "UNARY_OP";}else if(kind.type==39){return "BINARY_OP";}else if(kind.type==40){return "TERNARY_OP";}};void indent(int32_t depth){for(int i=0;i<=depth;i+=1) {printf("  ");}};Location get_location(uint8_t* file,int32_t index){Location loc;(loc.line)=1;(loc.column)=1;for(int i=0;i<index;i+=1) {if ((file[i])=='\n') {(loc.line)+=1;(loc.column)=1;} else {(loc.column)+=1;}}return loc;};void print_snippet(arr_u8 file,Location location){printf(" %i | ",location.line);int32_t i=location.line;int32_t length=2;while(i!=0) {length+=1;i/=10;}int32_t line_index=1;for(int i=0;i<(file.len);i+=1) {uint8_t c=(file.buf)[i];if (c=='\n') {line_index+=1;if (line_index>(location.line)) {goto brk_l;}} else if (line_index==(location.line)) {putchar(c);}l:}brk_l:putchar('\n');for(int i=0;i<length;i+=1) {putchar(' ');}putchar('|');for(int i=0;i<(location.column);i+=1) {putchar(' ');}set_color((Color){3});putchar('^');set_color((Color){0});putchar('\n');};void throw(File file,int32_t index,uint8_t* error,...){va_list args;va_start(args,error);Location loc=get_location((file.data).buf,index);printf("%s:%i:%i: ",file.name,loc.line,loc.column);set_color((Color){3});printf("error: ");set_color((Color){0});vprintf(error,args);printf("\n");print_snippet(file.data,loc);exit(1);va_end(args);};void push_char(vec_u8* v,uint8_t c){(((*v).buf)[((*v).len)])=c;((*v).len)+=1;if (((*v).len)==((*v).cap)) {((*v).cap)*=2;((*v).buf)=realloc((*v).buf,sizeof(uint8_t)*((*v).cap));}(((*v).buf)[((*v).len)])=0;};