#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>
typedef struct vec_Expr vec_Expr;void generate_vector(vec_Expr ast);void command_help(uint8_t* n,uint8_t* d,uint8_t* o);typedef struct Command Command;Command get_command(int32_t argc,uint8_t** argv);typedef struct vec_u8 vec_u8;vec_u8 vec_u8_new(int32_t cap);void vec_u8_push(vec_u8* this,uint8_t item);typedef struct Token Token;void add_to_value(vec_u8 value,uint8_t c,uint8_t is_literal);typedef struct vec_Token vec_Token;typedef struct arr_u8 arr_u8;vec_Token lex(arr_u8 file);vec_Token vec_Token_new(int32_t cap);int32_t main(int32_t argc,uint8_t** argv);arr_u8 arr_u8_new(int32_t len);uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv);typedef struct Color Color;void set_color(Color color);typedef struct Expr Expr;vec_Expr parse(vec_Token tokens);vec_Expr vec_Expr_new(int32_t cap);typedef struct Location Location;Location get_location(uint8_t* file,int32_t index);void print_snippet(arr_u8 file,Location location);void throw(arr_u8 file,uint8_t* file_name,int32_t index,uint8_t* error,...);struct vec_Expr{Expr* buf;int32_t len;int32_t cap;};union CommandUnion{char _;};struct Command{int type;union CommandUnion u;};struct vec_u8{uint8_t* buf;int32_t len;int32_t cap;};union TokenUnion{char _;};struct Token{int type;union TokenUnion u;};struct vec_Token{Token* buf;int32_t len;int32_t cap;};struct arr_u8{uint8_t* buf;int32_t len;};union ColorUnion{char _;};struct Color{int type;union ColorUnion u;};struct Expr{uint8_t _;};struct Location{int32_t line;int32_t column;};vec_u8 vec_u8_new(int32_t cap){return (vec_u8){malloc(sizeof(uint8_t)*cap),0,cap,};};void vec_u8_push(vec_u8* this,uint8_t item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(uint8_t)*((*this).cap));}};vec_Token vec_Token_new(int32_t cap){return (vec_Token){malloc(sizeof(Token)*cap),0,cap,};};arr_u8 arr_u8_new(int32_t len){return (arr_u8){malloc(sizeof(uint8_t)*len),len,};};vec_Expr vec_Expr_new(int32_t cap){return (vec_Expr){malloc(sizeof(Expr)*cap),0,cap,};};void generate_vector(vec_Expr ast){};void command_help(uint8_t* n,uint8_t* d,uint8_t* o){printf(d);printf("\n\nUSAGE:\n    cup ");printf(n);printf(" [OPTIONS]\n\nOPTIONS:");printf(o);printf("\n");};uint8_t* command_options_empty="\n    No options are available for this command";uint8_t* command_options_compile="\n    -i, --input     Specify the input file name\n    -o, --output    Specify the output file name\n    -cg, --gcc     Use GCC as a compiler\n    -cm, --msvc    Use MSVC as a compiler\n    -cc, --clang   use Clang as a compiler\n    -ct, --tcc     Use TinyCC as a compiler";Command get_command(int32_t argc,uint8_t** argv){if (argc==1) {return (Command){1};}uint8_t is_command=0;vec_u8 vector=vec_u8_new(16);for(int i=1;i<argc;i+=1) {if (i==4) {goto brk_l;}if (((argv[i])[0])=='-') {if (is_command) {goto brk_l;}goto l;}is_command=1;int32_t length=strlen(argv[i]);for(int c=0;c<length;c+=1) {vec_u8_push((&vector),(argv[i])[c]);}l:}brk_l:vec_u8_push((&vector),'\0');uint8_t* input=vector.buf;if (strcmp(input,"help")==0) {return (Command){1};} else if (strcmp(input,"helprun")==0) {return (Command){2};} else if (strcmp(input,"helpbuild")==0) {return (Command){3};} else if (strcmp(input,"helpcheck")==0) {return (Command){4};} else if (strcmp(input,"helpupdate")==0) {return (Command){6};} else if (strcmp(input,"helpadd")==0) {return (Command){7};} else if (strcmp(input,"helpremove")==0) {return (Command){8};} else if (strcmp(input,"helpgendocs")==0) {return (Command){9};} else if (strcmp(input,"helpgenbinds")==0) {return (Command){10};} else if (strcmp(input,"helpselfupdate")==0) {return (Command){11};} else if (strcmp(input,"helpselfinstall")==0) {return (Command){12};} else if (strcmp(input,"helpselfuninstall")==0) {return (Command){13};} else if (strcmp(input,"run")==0) {return (Command){14};} else if (strcmp(input,"build")==0) {return (Command){15};} else if (strcmp(input,"check")==0) {return (Command){16};} else if (strcmp(input,"update")==0) {return (Command){18};} else if (strcmp(input,"add")==0) {return (Command){19};} else if (strcmp(input,"remove")==0) {return (Command){20};} else if (strcmp(input,"gendocs")==0) {return (Command){21};} else if (strcmp(input,"genbinds")==0) {return (Command){22};} else if (strcmp(input,"selfupdate")==0) {return (Command){23};} else if (strcmp(input,"selfinstall")==0) {return (Command){24};} else if (strcmp(input,"selfuninstall")==0) {return (Command){25};}return (Command){0};};void add_to_value(vec_u8 value,uint8_t c,uint8_t is_literal){if ((is_literal==2)&&((value.len)==4)) {}vec_u8_push((&value),c);};vec_Token lex(arr_u8 file){vec_Token tokens=vec_Token_new(1);uint8_t is_comment=0;uint8_t is_literal=0;vec_u8 value=vec_u8_new(8);for(int i=0;i<=(file.len);i+=1) {uint8_t c=(file.buf)[i];if (((((is_literal!=1)&&(is_literal!=2))&&(is_literal!=3))&&(is_literal!=4))&&(c=='`')) {is_comment=1;goto l;}if (is_comment!=0) {if (c=='\n') {is_comment=0;}}Token kind=(Token){0};if ((is_literal==3)||(is_literal==4)) {is_literal-=2;}if ((is_literal==1)||(is_literal==2)) {if (c==0) {if (is_literal==1) {throw(file,"test_name",i-1,"expected end of %s literal","string");} else {throw(file,"test_name",i-1,"expected end of %s literal","char");}} else if ((is_literal==1)&&(c=='"')) {} else if ((is_literal==2)&&(c==39)) {} else {add_to_value(value,c,is_literal);goto l;}}if (isspace(c)) {kind=(Token){0};} else {if (c=='"') {if (is_literal==1) {kind=(Token){2};is_literal=0;} else {kind=(Token){0};is_literal=3;}} else if (c==39) {if (is_literal==2) {kind=(Token){3};is_literal=0;} else {kind=(Token){0};is_literal=4;}} else if (c==';') {kind=(Token){34};} else if (c==':') {kind=(Token){35};} else if (c==',') {kind=(Token){36};} else if (c=='.') {uint8_t n=(file.buf)[(i+1)];if ((is_literal!=5)||((n=='_')||isalpha(n))) {kind=(Token){37};}} else if (c=='?') {kind=(Token){38};} else if (c=='~') {kind=(Token){39};} else if (c=='#') {kind=(Token){40};} else if (c=='(') {kind=(Token){41};} else if (c==')') {kind=(Token){42};} else if (c=='{') {kind=(Token){43};} else if (c=='}') {kind=(Token){44};} else if (c=='[') {kind=(Token){45};} else if (c==']') {kind=(Token){-1};} else if (c=='@') {kind=(Token){47};} else if (c=='$') {kind=(Token){48};} else if (c=='&') {kind=(Token){53};} else if (c=='|') {kind=(Token){54};} else if (c=='=') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){50};i+=1;} else {kind=(Token){49};}} else if (c=='!') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){52};i+=1;} else {kind=(Token){51};}} else if (c=='<') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){56};i+=1;} else {kind=(Token){55};}} else if (c=='>') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){58};i+=1;} else {kind=(Token){57};}} else if (c=='+') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){60};i+=1;} else {kind=(Token){59};}} else if (c=='-') {} else if (c=='*') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){64};i+=1;} else {kind=(Token){63};}} else if (c=='/') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){66};i+=1;} else {kind=(Token){65};}} else if (c=='%') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(Token){68};i+=1;} else {kind=(Token){67};}}}switch(kind.type){case 0:if (((((c=='-')||(c=='_'))||(c=='.'))||(c==':'))||isalnum(c)) {if ((((value.len)==0)&&isdigit(c))||(c=='-')) {is_literal=5;} else if ((is_literal==5)||(is_literal==6)) {if ((c=='.')&&(is_literal==5)) {is_literal=6;} else if ((c=='_')||isdigit(c)) {} else {throw(file,"test_name",i-(value.len),"invalid identifier name starting with a digit");}}if (((is_literal!=5)&&(is_literal!=6))||(c!='_')) {add_to_value(value,c,is_literal);}} else {throw(file,"test_name",i,"unexpected symbol %c",c);}break;case -1:break;}l:}brk_l:return tokens;};uint8_t* file_name=(void*)0;int32_t file_size;int32_t main(int32_t argc,uint8_t** argv){Command command=get_command(argc,argv);switch(command.type){case 0:set_color((Color){1});printf("error: ");set_color((Color){0});printf("no such command: '%s",argv[1]);for(int i=2;i<argc;i+=1) {printf(" %s",argv[i]);}printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;break;case 14:goto brk_m;break;case 15:goto brk_m;break;case 16:return 1;break;case 17:return 1;break;case 18:return 1;break;case 19:return 1;break;case 20:return 1;break;case 21:return 1;break;case 22:return 1;break;case 23:return 1;break;case 24:return 1;break;case 25:return 1;break;case 1:printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;break;case 2:command_help("run","Compile and run the current package",command_options_compile);return 0;break;case 3:command_help("build","Compile the current package",command_options_compile);return 0;break;case 4:command_help("check","Analyze the current package",command_options_empty);return 0;break;case 5:command_help("new","Create a new package",command_options_empty);return 0;break;case 6:command_help("update","Update given dependency",command_options_empty);return 0;break;case 7:command_help("add","Adds given dependency",command_options_empty);return 0;break;case 8:command_help("remove","Removes given dependency",command_options_empty);return 0;break;case 9:command_help("gen docs","Generate documentation for the current package",command_options_empty);return 0;break;case 10:command_help("gen binds","Generate bindings for a given C header file",command_options_empty);return 0;break;case 11:command_help("self update","Update the Cup Toolkit",command_options_empty);return 0;break;case 12:command_help("self install","Install the Cup Toolkit",command_options_empty);return 0;break;case 13:command_help("self uninstall","Uninstall the Cup Toolkite",command_options_empty);return 0;break;}brk_m:uint8_t* output=(void*)0;for(int i=2;i<argc;i+=1) {if (((argv[i])[0])=='-') {if (((argv[i])[1])=='i') {if (file_name==(void*)0) {file_name=get_option((&i),argc,argv);}} else if (((argv[i])[1])=='o') {if (output==(void*)0) {output=get_option((&i),argc,argv);}}} else {set_color((Color){1});printf("error: ");set_color((Color){0});printf("invalid option '%s'",argv[i]);}}FILE* file_point=fopen(file_name,"rb");if (file_point==(void*)0) {set_color((Color){1});printf("error: ");set_color((Color){0});printf("no such file or directory: '%s'",file_name);return 1;}fseek(file_point,(int32_t)0,SEEK_END);file_size=ftell(file_point);rewind(file_point);arr_u8 file=arr_u8_new(file_size);fread(file.buf,file_size,1,file_point);fclose(file_point);vec_Token tokens=lex(file);vec_Expr ast=parse(tokens);printf("Compilation successful (%.3lfs elapsed)\n",((double)clock())/CLOCKS_PER_SEC);return 0;};uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv){if (strlen(argv[(*index)])>2) {return (argv[(*index)])+1;} else if (argc>(*index)) {return argv[((*index)+=1)];}return (void*)0;};void set_color(Color color){switch(color.type){case 0:printf("\033[0m");break;case 1:printf("\033[0;31m");break;}};vec_Expr parse(vec_Token tokens){return vec_Expr_new(1);};Location get_location(uint8_t* file,int32_t index){Location loc;(loc.line)=1;(loc.column)=1;for(int i=0;i<index;i+=1) {if ((file[i])=='\n') {(loc.line)+=1;(loc.column)=1;} else {(loc.column)+=1;}}return loc;};void print_snippet(arr_u8 file,Location location){printf(" %i | ",location.line);int32_t i=location.line;int32_t length=2;while(i!=0) {length+=1;i/=10;}int32_t line_index=1;for(int i=0;i<(file.len);i+=1) {uint8_t c=(file.buf)[i];if (c=='\n') {line_index+=1;if (line_index>(location.line)) {goto brk_l;}} else if (line_index==(location.line)) {putchar(c);}l:}brk_l:putchar('\n');for(int i=0;i<length;i+=1) {putchar(' ');}putchar('|');for(int i=0;i<(location.column);i+=1) {putchar(' ');}set_color((Color){1});putchar('^');set_color((Color){0});putchar('\n');};void throw(arr_u8 file,uint8_t* file_name,int32_t index,uint8_t* error,...){va_list args;va_start(args,error);Location loc=get_location(file.buf,index);printf("%s:%i:%i: ",file_name,loc.line,loc.column);set_color((Color){1});printf("error: ");set_color((Color){0});vprintf(error,args);printf("\n");print_snippet(file,loc);exit(1);va_end(args);};