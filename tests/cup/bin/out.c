void command_help(str n,str d,str o){printf(d);printf("\n\nUSAGE:\n    cup ");printf(n);printf(" [OPTIONS]\n\nOPTIONS:");printf(o);printf("\n");};void command_options_empty="\n    No options are available for this command";void command_options_compile=(((("\n    -i, --input     Specify the input file name"+"\n    -o, --output    Specify the output file name")+"\n    -cg, --gcc     Use GCC as a compiler")+"\n    -cm, --msvc    Use MSVC as a compiler")+"\n    -cc, --clang   use Clang as a compiler")+"\n    -ct, --tcc     Use TinyCC as a compiler";struct Command_None{}struct Command_Help{}struct Command_HelpRun{}struct Command_HelpBuild{}struct Command_HelpCheck{}struct Command_HelpNewPackage{}struct Command_HelpUpdatePackage{}struct Command_HelpAddPackage{}struct Command_HelpRemovePackage{}struct Command_HelpGenDocs{}struct Command_HelpGenBinds{}struct Command_HelpSelfUpdate{}struct Command_HelpSelfInstall{}struct Command_HelpSelfUninstall{}struct Command_Run{}struct Command_Build{}struct Command_Check{}struct Command_NewPackage{}struct Command_UpdatePackage{}struct Command_AddPackage{}struct Command_RemovePackage{}struct Command_GenDocs{}struct Command_GenBinds{}struct Command_SelfUpdate{}struct Command_SelfInstall{}struct Command_SelfUninstall{}union Command{struct Command_None u0;struct Command_Help u1;struct Command_HelpRun u2;struct Command_HelpBuild u3;struct Command_HelpCheck u4;struct Command_HelpNewPackage u5;struct Command_HelpUpdatePackage u6;struct Command_HelpAddPackage u7;struct Command_HelpRemovePackage u8;struct Command_HelpGenDocs u9;struct Command_HelpGenBinds u10;struct Command_HelpSelfUpdate u11;struct Command_HelpSelfInstall u12;struct Command_HelpSelfUninstall u13;struct Command_Run u14;struct Command_Build u15;struct Command_Check u16;struct Command_NewPackage u17;struct Command_UpdatePackage u18;struct Command_AddPackage u19;struct Command_RemovePackage u20;struct Command_GenDocs u21;struct Command_GenBinds u22;struct Command_SelfUpdate u23;struct Command_SelfInstall u24;struct Command_SelfUninstall u25;};typedef struct{int type;union Command u;}Command;Command get_command(int32_t argc,uint8_t** argv){if (argc==1) {return Command_None;}char is_command=0;vec_u8 vector=vec_u8_new(16);vector.push('\0');uint8_t* input=vector.buf;if (strcmp(input,"help")==0) {return Command_Help;} else if (strcmp(input,"helprun")==0) {return Command_HelpRun;} else if (strcmp(input,"helpbuild")==0) {return Command_HelpBuild;} else if (strcmp(input,"helpcheck")==0) {return Command_HelpCheck;} else if (strcmp(input,"helpupdate")==0) {return Command_HelpUpdatePackage;} else if (strcmp(input,"helpadd")==0) {return Command_HelpAddPackage;} else if (strcmp(input,"helpremove")==0) {return Command_HelpRemovePackage;} else if (strcmp(input,"helpgendocs")==0) {return Command_HelpGenDocs;} else if (strcmp(input,"helpgenbinds")==0) {return Command_HelpGenBinds;} else if (strcmp(input,"helpselfupdate")==0) {return Command_HelpSelfUpdate;} else if (strcmp(input,"helpselfinstall")==0) {return Command_HelpSelfInstall;} else if (strcmp(input,"helpselfuninstall")==0) {return Command_HelpSelfUninstall;} else if (strcmp(input,"run")==0) {return Command_Run;} else if (strcmp(input,"build")==0) {return Command_Build;} else if (strcmp(input,"check")==0) {return Command_Check;} else if (strcmp(input,"update")==0) {return Command_UpdatePackage;} else if (strcmp(input,"add")==0) {return Command_AddPackage;} else if (strcmp(input,"remove")==0) {return Command_RemovePackage;} else if (strcmp(input,"gendocs")==0) {return Command_GenDocs;} else if (strcmp(input,"genbinds")==0) {return Command_GenBinds;} else if (strcmp(input,"selfupdate")==0) {return Command_SelfUpdate;} else if (strcmp(input,"selfinstall")==0) {return Command_SelfInstall;} else if (strcmp(input,"selfuninstall")==0) {return Command_SelfUninstall;}return Command_None;};void gen_generate_vector(vec_Expr ast){};typedef struct{}lexer_Token;vec_Token lexer_lex(){return vec_Token_new(1);};int32_t main(int32_t argc,uint8_t** argv){void command=get_command(argc,argv);if ((argc==1)||(command==Command_Help)) {printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;} else if (command==Command_None) {set_color(Color_Red);printf("error: ");set_color(Color_Reset);printf("no such command: '%s",);printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;}uint8_t* output=(void*)0;file_name=get_option(&i,argc,argv);output=get_option(&i,argc,argv);FILE* file_point;if (fopen_s(&file_point,file_name,"rb")) {set_color(Color_Red);printf("error: ");set_color(Color_Reset);printf("no such file or directory: '%s'",file_name);return 1;}fseek(file_point,int32(0),SEEK_END);file_size=ftell(file_point);rewind(file_point);uint8_t* file=mem_alloc(file_size);fread(file,file_size,1,file_point);fclose(file_point);void tokens=lexer_lex();vec_Token ast=parser_parse(tokens);if (output!=(void*)0) {fopen_s(&file_point,output,"w");} else {fopen_s(&file_point,"out.c","w");}fputs("#include <stdint.h>\n",file_point);gen_generate_vector(ast);fclose(file_point);system("cc test/test0/out.c -o test/test0/out");printf("Compilation successful (%.3lfs elapsed)\n",f64(clock())/CLOCKS_PER_SEC);return 0;};uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv){return (void*)0;};struct Color_Reset{}struct Color_Red{}union Color{struct Color_Reset u0;struct Color_Red u1;};typedef struct{int type;union Color u;}Color;void set_color(){void color_code=;printf(color_code);};typedef struct{u8* buf;int32_t size;int32_t cap;}vec_u8;typedef struct{Expr* buf;int32_t size;int32_t cap;}vec_Expr;typedef struct{Token* buf;int32_t size;int32_t cap;}vec_Token;vec_T vec_new(int32_t cap){return (vec){mem_alloc(mem_size_T()*cap),0,cap,};};void vec_push(T item){(.)=item;(.size)+=1;if ((.size)==(.capacity)) {(.capacity)*=2;(.buf)=mem_realloc(v.buf,mem_size_T()*(.capacity));}};typedef struct{}parser_Expr;vec_Expr parser_parse(vec_Token tokens){return vec_Expr_new(1);};