#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <dirent.h>
#include <ctype.h>
#include <stdarg.h>
typedef struct Command Command;typedef struct vec_u8 vec_u8;typedef struct vec_Expr vec_Expr;typedef struct TokenKind TokenKind;typedef struct Token Token;typedef struct vec_Token vec_Token;typedef struct Color Color;typedef struct arr_u8 arr_u8;typedef struct File File;typedef struct ExprKind ExprKind;typedef struct Expr Expr;typedef struct Location Location;void command_help(uint8_t* n,uint8_t* d,uint8_t* o);Command get_command(int32_t argc,uint8_t** argv);vec_u8 vec_u8_new(int32_t cap);void vec_u8_push(vec_u8* this,uint8_t item);void generate_vector(vec_Expr ast);int32_t get_token_length(TokenKind kind);uint8_t* get_token_name(TokenKind kind);void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal);TokenKind get_keyword(uint8_t* value);uint8_t is_binary_operator(TokenKind kind);vec_Token lex(File file);vec_Token vec_Token_new(int32_t cap);void vec_Token_push(vec_Token* this,Token item);void print_tokens(vec_Token tokens);int32_t main(int32_t argc,uint8_t** argv);uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv);void set_color(Color color);void lex_parse_recursive(uint8_t* path);arr_u8 arr_u8_new(int32_t len);vec_Expr parse(File file,vec_Token tokens);vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local);vec_Expr vec_Expr_new(int32_t cap);void vec_Expr_push(vec_Expr* this,Expr item);Expr parse_local(File file,vec_Token tokens,int32_t* index);Expr parse_global(File file,vec_Token tokens,int32_t* index);void print_exprs(vec_Expr exprs);void print_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name);void print_expr(Expr expr,int32_t depth);uint8_t* get_expr_name(ExprKind kind);void indent(int32_t depth);Location get_location(uint8_t* file,int32_t index);void print_snippet(arr_u8 file,Location location);void throw(File file,int32_t index,uint8_t* error,...);void push_char(vec_u8* v,uint8_t c);void empty(vec_u8* v);union CommandUnion{char _;};struct Command{int type;union CommandUnion u;};struct vec_u8{uint8_t* buf;int32_t len;int32_t cap;};struct vec_Expr{Expr* buf;int32_t len;int32_t cap;};union TokenKindUnion{char _;};struct TokenKind{int type;union TokenKindUnion u;};struct Token{TokenKind kind;int32_t index;uint8_t* value;};struct vec_Token{Token* buf;int32_t len;int32_t cap;};union ColorUnion{char _;};struct Color{int type;union ColorUnion u;};struct arr_u8{uint8_t* buf;int32_t len;};struct File{uint8_t* name;arr_u8 data;};typedef struct{uint8_t* name;vec_Expr args;}ExprKind_Tag;typedef struct{uint8_t* name;vec_Expr body;}ExprKind_Mod;typedef struct{uint8_t* name;}ExprKind_Use;typedef struct{uint8_t* name;vec_Expr body;}ExprKind_Comp;typedef struct{Expr* _type;uint8_t* name;}ExprKind_CompField;typedef struct{uint8_t* name;vec_Expr body;}ExprKind_Enum;typedef struct{uint8_t* name;vec_Expr args;}ExprKind_Option;typedef struct{Expr* _type;uint8_t* name;}ExprKind_OptionField;typedef struct{uint8_t* name;vec_Expr body;}ExprKind_Prop;typedef struct{Expr* _type;uint8_t* name;vec_Expr body;}ExprKind_SubDef;typedef struct{Expr* _type;uint8_t* name;}ExprKind_Arg;typedef struct{Expr* _type;uint8_t* name;Expr* value;}ExprKind_VarDef;typedef struct{Expr* _type;uint8_t* name;Expr* value;}ExprKind_LocalVarDef;typedef struct{Expr* value;TokenKind kind;}ExprKind_UnaryOp;typedef struct{Expr* lhs;Expr* rhs;TokenKind kind;}ExprKind_BinaryOp;union ExprKindUnion{ExprKind_Tag u0;ExprKind_Mod u5;ExprKind_Use u6;ExprKind_Comp u7;ExprKind_CompField u8;ExprKind_Enum u9;ExprKind_Option u10;ExprKind_OptionField u11;ExprKind_Prop u12;ExprKind_SubDef u14;ExprKind_Arg u15;ExprKind_VarDef u16;ExprKind_LocalVarDef u17;ExprKind_UnaryOp u46;ExprKind_BinaryOp u47;char _;};struct ExprKind{int type;union ExprKindUnion u;};struct Expr{ExprKind kind;vec_Expr tags;uint8_t* label;};struct Location{int32_t line;int32_t column;};typedef struct dirent dirent;vec_u8 vec_u8_new(int32_t cap){return (vec_u8){malloc(sizeof(uint8_t)*cap),0,cap,};};void vec_u8_push(vec_u8* this,uint8_t item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(uint8_t)*((*this).cap));}};vec_Token vec_Token_new(int32_t cap){return (vec_Token){malloc(sizeof(Token)*cap),0,cap,};};void vec_Token_push(vec_Token* this,Token item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Token)*((*this).cap));}};arr_u8 arr_u8_new(int32_t len){return (arr_u8){malloc(sizeof(uint8_t)*len),len,};};vec_Expr vec_Expr_new(int32_t cap){return (vec_Expr){malloc(sizeof(Expr)*cap),0,cap,};};void vec_Expr_push(vec_Expr* this,Expr item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Expr)*((*this).cap));}};void command_help(uint8_t* n,uint8_t* d,uint8_t* o){printf(d);printf("\n\nUSAGE:\n    cup ");printf(n);printf(" [OPTIONS]\n\nOPTIONS:");printf(o);printf("\n");};uint8_t* command_options_empty="\n    No options are available for this command";uint8_t* command_options_compile="\n    -i, --input     Specify the input file name\n    -o, --output    Specify the output file name\n    -cg, --gcc     Use GCC as a compiler\n    -cm, --msvc    Use MSVC as a compiler\n    -cc, --clang   use Clang as a compiler\n    -ct, --tcc     Use TinyCC as a compiler";Command get_command(int32_t argc,uint8_t** argv){if (argc==1) {return (Command){1};}uint8_t is_command=0;vec_u8 vector=vec_u8_new(16);for(int i=1;i<argc;i+=1) {if (i==4) {goto brk_l;}if (((argv[i])[0])=='-') {if (is_command) {goto brk_l;}goto l;}is_command=1;int32_t length=strlen(argv[i]);for(int c=0;c<length;c+=1) {vec_u8_push((&vector),(argv[i])[c]);}l:}brk_l:vec_u8_push((&vector),'\0');uint8_t* input=vector.buf;if (strcmp(input,"help")==0) {return (Command){1};} else if (strcmp(input,"helprun")==0) {return (Command){2};} else if (strcmp(input,"helpbuild")==0) {return (Command){3};} else if (strcmp(input,"helpcheck")==0) {return (Command){4};} else if (strcmp(input,"helpupdate")==0) {return (Command){6};} else if (strcmp(input,"helpadd")==0) {return (Command){7};} else if (strcmp(input,"helpremove")==0) {return (Command){8};} else if (strcmp(input,"helpgendocs")==0) {return (Command){9};} else if (strcmp(input,"helpgenbinds")==0) {return (Command){10};} else if (strcmp(input,"helpselfupdate")==0) {return (Command){11};} else if (strcmp(input,"helpselfinstall")==0) {return (Command){12};} else if (strcmp(input,"helpselfuninstall")==0) {return (Command){13};} else if (strcmp(input,"run")==0) {return (Command){14};} else if (strcmp(input,"build")==0) {return (Command){15};} else if (strcmp(input,"check")==0) {return (Command){16};} else if (strcmp(input,"update")==0) {return (Command){18};} else if (strcmp(input,"add")==0) {return (Command){19};} else if (strcmp(input,"remove")==0) {return (Command){20};} else if (strcmp(input,"gendocs")==0) {return (Command){21};} else if (strcmp(input,"genbinds")==0) {return (Command){22};} else if (strcmp(input,"selfupdate")==0) {return (Command){23};} else if (strcmp(input,"selfinstall")==0) {return (Command){24};} else if (strcmp(input,"selfuninstall")==0) {return (Command){25};}return (Command){0};};void generate_vector(vec_Expr ast){};int32_t get_token_length(TokenKind kind){switch(kind.type){case 7:{return 4;break;}case 8:{return 5;break;}case 9:{return 4;break;}case 10:{return 4;break;}case 11:{return 4;break;}case 12:{return 3;break;}case 13:{return 3;break;}case 14:{return 3;break;}case 15:{return 4;break;}case 16:{return 4;break;}case 17:{return 4;break;}case 18:{return 3;break;}case 19:{return 3;break;}case 20:{return 3;break;}case 21:{return 5;break;}case 22:{return 2;break;}case 23:{return 4;break;}case 24:{return 4;break;}case 25:{return 4;break;}case 26:{return 5;break;}case 27:{return 3;break;}case 28:{return 4;break;}case 29:{return 5;break;}case 30:{return 3;break;}case 31:{return 4;break;}case 32:{return 4;break;}case 33:{return 3;break;}case 34:{return 2;break;}case 35:{return 1;break;}case 36:{return 1;break;}case 37:{return 1;break;}case 38:{return 1;break;}case 39:{return 1;break;}case 40:{return 1;break;}case 41:{return 1;break;}case 42:{return 1;break;}case 43:{return 1;break;}case 44:{return 1;break;}case 45:{return 1;break;}case 46:{return 1;break;}case 47:{return 1;break;}case 48:{return 1;break;}case 49:{return 1;break;}case 50:{return 1;break;}case 51:{return 2;break;}case 52:{return 1;break;}case 53:{return 2;break;}case 54:{return 1;break;}case 55:{return 1;break;}case 56:{return 1;break;}case 57:{return 2;break;}case 58:{return 1;break;}case 59:{return 2;break;}case 60:{return 1;break;}case 61:{return 2;break;}case 62:{return 1;break;}case 63:{return 2;break;}case 64:{return 1;break;}case 65:{return 2;break;}case 66:{return 1;break;}case 67:{return 2;break;}case 68:{return 1;break;}case 69:{return 2;break;}}};uint8_t* get_token_name(TokenKind kind){switch(kind.type){case 2:{return "IDENT";break;}case 3:{return "STRING_LIT";break;}case 4:{return "CHAR_LIT";break;}case 5:{return "INT_LIT";break;}case 6:{return "FLOAT_LIT";break;}case 7:{return "TRUE";break;}case 8:{return "FALSE";break;}case 9:{return "NONE";break;}case 10:{return "THIS";break;}case 11:{return "TYPE";break;}case 12:{return "TAG";break;}case 13:{return "MOD";break;}case 14:{return "USE";break;}case 15:{return "COMP";break;}case 16:{return "ENUM";break;}case 17:{return "PROP";break;}case 18:{return "DEF";break;}case 19:{return "SUB";break;}case 20:{return "VAR";break;}case 21:{return "WHERE";break;}case 22:{return "IF";break;}case 23:{return "ELIF";break;}case 24:{return "ELSE";break;}case 25:{return "LOOP";break;}case 26:{return "WHILE";break;}case 27:{return "FOR";break;}case 28:{return "EACH";break;}case 29:{return "MATCH";break;}case 30:{return "RET";break;}case 31:{return "NEXT";break;}case 32:{return "JUMP";break;}case 33:{return "TRY";break;}case 34:{return "AS";break;}case 35:{return "SEMICOLON";break;}case 36:{return "COLON";break;}case 37:{return "COMMA";break;}case 38:{return "DOT";break;}case 39:{return "QUESTION_MARK";break;}case 40:{return "TILDE";break;}case 41:{return "HASH";break;}case 42:{return "LEFT_PAREN";break;}case 43:{return "RIGHT_PAREN";break;}case 44:{return "LEFT_BRACE";break;}case 45:{return "RIGHT_BRACE";break;}case 46:{return "LEFT_BRACKET";break;}case 47:{return "RIGHT_BRACKET";break;}case 48:{return "DEREF";break;}case 49:{return "ADDRESS";break;}case 50:{return "ASSIGN";break;}case 51:{return "EQUAL";break;}case 52:{return "NOT";break;}case 53:{return "NOT_EQUAL";break;}case 54:{return "AND";break;}case 55:{return "OR";break;}case 56:{return "LESS";break;}case 57:{return "LESS_EQUAL";break;}case 58:{return "GREATER";break;}case 59:{return "GREATER_EQUAL";break;}case 60:{return "ADD";break;}case 61:{return "ADD_ASSIGN";break;}case 62:{return "SUBTRACT";break;}case 63:{return "SUBTRACT_ASSIGN";break;}case 64:{return "MULTIPLY";break;}case 65:{return "MULTIPLY_ASSIGN";break;}case 66:{return "DIVIDE";break;}case 67:{return "DIVIDE_ASSIGN";break;}case 68:{return "MODULO";break;}case 69:{return "MODULO_ASSIGN";break;}}};void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal){if ((is_literal==2)&&(((*value).len)==4)) {throw(file,i,"too many characters in character literal");}push_char(value,c);};TokenKind get_keyword(uint8_t* value){if (strcmp(value,"tag")==0) {return (TokenKind){12};} else if (strcmp(value,"mod")==0) {return (TokenKind){13};} else if (strcmp(value,"use")==0) {return (TokenKind){14};} else if (strcmp(value,"comp")==0) {return (TokenKind){15};} else if (strcmp(value,"enum")==0) {return (TokenKind){16};} else if (strcmp(value,"prop")==0) {return (TokenKind){17};} else if (strcmp(value,"def")==0) {return (TokenKind){18};} else if (strcmp(value,"sub")==0) {return (TokenKind){19};} else if (strcmp(value,"var")==0) {return (TokenKind){20};} else if (strcmp(value,"this")==0) {return (TokenKind){10};} else if (strcmp(value,"type")==0) {return (TokenKind){11};} else if (strcmp(value,"where")==0) {return (TokenKind){21};} else if (strcmp(value,"true")==0) {return (TokenKind){7};} else if (strcmp(value,"false")==0) {return (TokenKind){8};} else if (strcmp(value,"none")==0) {return (TokenKind){9};} else if (strcmp(value,"if")==0) {return (TokenKind){22};} else if (strcmp(value,"elif")==0) {return (TokenKind){23};} else if (strcmp(value,"else")==0) {return (TokenKind){24};} else if (strcmp(value,"loop")==0) {return (TokenKind){25};} else if (strcmp(value,"while")==0) {return (TokenKind){26};} else if (strcmp(value,"for")==0) {return (TokenKind){27};} else if (strcmp(value,"each")==0) {return (TokenKind){28};} else if (strcmp(value,"match")==0) {return (TokenKind){29};} else if (strcmp(value,"ret")==0) {return (TokenKind){30};} else if (strcmp(value,"next")==0) {return (TokenKind){31};} else if (strcmp(value,"jump")==0) {return (TokenKind){32};} else if (strcmp(value,"try")==0) {return (TokenKind){33};} else if (strcmp(value,"as")==0) {return (TokenKind){34};}return (TokenKind){1};};uint8_t is_binary_operator(TokenKind kind){switch(kind.type){case 42:{return 1;break;}case 50:{return 1;break;}case 51:{return 1;break;}case 53:{return 1;break;}case 54:{return 1;break;}case 55:{return 1;break;}case 56:{return 1;break;}case 57:{return 1;break;}case 58:{return 1;break;}case 59:{return 1;break;}case 60:{return 1;break;}case 61:{return 1;break;}case 62:{return 1;break;}case 63:{return 1;break;}case 64:{return 1;break;}case 65:{return 1;break;}case 66:{return 1;break;}case 67:{return 1;break;}case 68:{return 1;break;}case 69:{return 1;break;}case 34:{return 1;break;}default:{return 0;break;}}};vec_Token lex(File file){vec_Token tokens=vec_Token_new(32);uint8_t is_comment=0;uint8_t is_literal=0;vec_u8 value=vec_u8_new(8);empty((&value));for(int i=0;i<=((file.data).len);i+=1) {uint8_t c=((file.data).buf)[i];if (((((is_literal!=1)&&(is_literal!=2))&&(is_literal!=3))&&(is_literal!=4))&&(c=='`')) {is_comment=1;goto l;}if (is_comment!=0) {if (c=='\n') {is_comment=0;}goto l;}TokenKind kind=(TokenKind){0};if ((is_literal==3)||(is_literal==4)) {is_literal-=2;}if ((is_literal==1)||(is_literal==2)) {if (c==0) {if (is_literal==1) {throw(file,i-1,"expected end of %s literal","string");} else {throw(file,i-1,"expected end of %s literal","char");}} else if ((is_literal==1)&&(c=='"')) {} else if ((is_literal==2)&&(c==39)) {} else {add_to_value(file,(&value),i,c,is_literal);goto l;}}if ((c==0)||isspace(c)) {kind=(TokenKind){1};} else {if (c=='"') {if (is_literal==1) {kind=(TokenKind){3};is_literal=0;} else {kind=(TokenKind){1};is_literal=3;}} else if (c==39) {if (is_literal==2) {kind=(TokenKind){4};is_literal=0;} else {kind=(TokenKind){1};is_literal=4;}} else if (c==';') {kind=(TokenKind){35};} else if (c==':') {kind=(TokenKind){36};} else if (c==',') {kind=(TokenKind){37};} else if (c=='.') {uint8_t n=((file.data).buf)[(i+1)];if ((is_literal!=5)||((n=='_')||isalpha(n))) {kind=(TokenKind){38};}} else if (c=='?') {kind=(TokenKind){39};} else if (c=='~') {kind=(TokenKind){40};} else if (c=='#') {kind=(TokenKind){41};} else if (c=='(') {kind=(TokenKind){42};} else if (c==')') {kind=(TokenKind){43};} else if (c=='{') {kind=(TokenKind){44};} else if (c=='}') {kind=(TokenKind){45};} else if (c=='[') {kind=(TokenKind){46};} else if (c==']') {kind=(TokenKind){47};} else if (c=='@') {kind=(TokenKind){48};} else if (c=='$') {kind=(TokenKind){49};} else if (c=='&') {kind=(TokenKind){54};} else if (c=='|') {kind=(TokenKind){55};} else if (c=='=') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){51};i+=1;} else {kind=(TokenKind){50};}} else if (c=='!') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){53};i+=1;} else {kind=(TokenKind){52};}} else if (c=='<') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){57};i+=1;} else {kind=(TokenKind){56};}} else if (c=='>') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){59};i+=1;} else {kind=(TokenKind){58};}} else if (c=='+') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){61};i+=1;} else {kind=(TokenKind){60};}} else if (c=='-') {if (is_binary_operator(((tokens.buf)[((tokens.len)-1)]).kind)&&isdigit(((file.data).buf)[(i+1)])) {goto brk_ll;}if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){63};i+=1;} else {kind=(TokenKind){62};}} else if (c=='*') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){65};i+=1;} else {kind=(TokenKind){64};}} else if (c=='/') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){67};i+=1;} else {kind=(TokenKind){66};}} else if (c=='%') {if (((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')) {kind=(TokenKind){69};i+=1;} else {kind=(TokenKind){68};}}}brk_ll:switch(kind.type){case 0:{if (((((c=='-')||(c=='_'))||(c=='.'))||(c==':'))||isalnum(c)) {if ((((value.len)==0)&&isdigit(c))||(c=='-')) {is_literal=5;} else if ((is_literal==5)||(is_literal==6)) {if ((c=='.')&&(is_literal==5)) {is_literal=6;} else if ((c=='_')||isdigit(c)) {} else {throw(file,i-(value.len),"invalid identifier name starting with a digit");}}if (((is_literal!=5)&&(is_literal!=6))||(c!='_')) {add_to_value(file,(&value),i,c,is_literal);}} else {throw(file,i,"unexpected symbol %c",c);}break;}default:{if ((value.len)>0) {switch(kind.type){case 3:{break;}case 4:{break;}default:{TokenKind value_kind=get_keyword(value.buf);switch(value_kind.type){case 1:{Token token;if (is_literal==5) {(token.kind)=(TokenKind){5};} else if (is_literal==6) {(token.kind)=(TokenKind){6};if (((value.buf)[((value.len)-1)])=='.') {throw(file,i-1,"expected a value after the decimal point");}} else {(token.kind)=(TokenKind){2};}(token.index)=(i-(value.len));(token.value)=(value.buf);vec_Token_push((&tokens),token);break;}default:{Token token=(Token){value_kind,i-get_token_length(value_kind),};vec_Token_push((&tokens),token);break;}}value=vec_u8_new(8);empty((&value));is_literal=0;break;}}}switch(kind.type){case 1:{break;}default:{Token token=(Token){kind,};switch(kind.type){case 3:{(token.value)=(value.buf);(token.index)=(i-(value.len));empty((&value));break;}case 4:{(token.value)=(value.buf);(token.index)=(i-(value.len));empty((&value));break;}default:{(token.index)=((i-get_token_length(kind))+1);break;}}vec_Token_push((&tokens),token);break;}}break;}}l:}brk_l:return tokens;};void print_tokens(vec_Token tokens){printf("Tokens:\n");for(int i=0;i<(tokens.len);i+=1) {TokenKind kind=((tokens.buf)[i]).kind;set_color((Color){1});printf("  %s",get_token_name(kind));set_color((Color){0});switch(kind.type){case 2:{printf("(%s)",((tokens.buf)[i]).value);break;}case 3:{printf("(%s)",((tokens.buf)[i]).value);break;}case 4:{printf("(%s)",((tokens.buf)[i]).value);break;}case 5:{printf("(%s)",((tokens.buf)[i]).value);break;}case 6:{printf("(%s)",((tokens.buf)[i]).value);break;}}putchar('\n');}putchar('\n');};int32_t main(int32_t argc,uint8_t** argv){Command command=get_command(argc,argv);switch(command.type){case 0:{set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such command: '%s",argv[1]);for(int i=2;i<argc;i+=1) {printf(" %s",argv[i]);}printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;break;}case 14:{goto brk_m;break;}case 15:{goto brk_m;break;}case 16:{return 1;break;}case 17:{return 1;break;}case 18:{return 1;break;}case 19:{return 1;break;}case 20:{return 1;break;}case 21:{return 1;break;}case 22:{return 1;break;}case 23:{return 1;break;}case 24:{return 1;break;}case 25:{return 1;break;}case 1:{printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;break;}case 2:{command_help("run","Compile and run the current package",command_options_compile);return 0;break;}case 3:{command_help("build","Compile the current package",command_options_compile);return 0;break;}case 4:{command_help("check","Analyze the current package",command_options_empty);return 0;break;}case 5:{command_help("new","Create a new package",command_options_empty);return 0;break;}case 6:{command_help("update","Update given dependency",command_options_empty);return 0;break;}case 7:{command_help("add","Adds given dependency",command_options_empty);return 0;break;}case 8:{command_help("remove","Removes given dependency",command_options_empty);return 0;break;}case 9:{command_help("gen docs","Generate documentation for the current package",command_options_empty);return 0;break;}case 10:{command_help("gen binds","Generate bindings for a given C header file",command_options_empty);return 0;break;}case 11:{command_help("self update","Update the Cup Toolkit",command_options_empty);return 0;break;}case 12:{command_help("self install","Install the Cup Toolkit",command_options_empty);return 0;break;}case 13:{command_help("self uninstall","Uninstall the Cup Toolkite",command_options_empty);return 0;break;}}brk_m:uint8_t* input=(void*)0;uint8_t* output=(void*)0;for(int i=2;i<argc;i+=1) {if (((argv[i])[0])=='-') {if (((argv[i])[1])=='i') {if (input==(void*)0) {input=get_option((&i),argc,argv);}} else if (((argv[i])[1])=='o') {if (output==(void*)0) {output=get_option((&i),argc,argv);}}} else {set_color((Color){3});printf("error: ");set_color((Color){0});printf("invalid option '%s'",argv[i]);}}if (input==(void*)0) {input=".";}if (output==(void*)0) {output="out.c";}lex_parse_recursive(input);printf("Compilation ");set_color((Color){2});printf("successful");set_color((Color){0});printf(" (%.1lfs elapsed)\n",((double)clock())/CLOCKS_PER_SEC);return 0;};uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv){if (strlen(argv[(*index)])>2) {return (argv[(*index)])+1;} else if (argc>(*index)) {return argv[((*index)+=1)];}return (void*)0;};void set_color(Color color){switch(color.type){case 0:{printf("\033[0m");break;}case 1:{printf("\033[35m");break;}case 2:{printf("\033[32m");break;}case 3:{printf("\033[0;31m");break;}}};void lex_parse_recursive(uint8_t* path){DIR* dir=opendir(path);if (dir==(void*)0) {set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such file or directory: '%s'\n",path);exit(1);}dirent* ent;while((ent=readdir(dir))!=(void*)0) {int32_t new_length=strlen((*ent).d_name);if ((new_length==1)&&((((*ent).d_name)[0])=='.')) {} else if (((new_length==2)&&((((*ent).d_name)[0])=='.'))&&((((*ent).d_name)[1])=='.')) {} else {int32_t length=strlen(path);uint8_t* new_path=malloc(((length+1)+new_length)+1);memcpy(new_path,path,length);(new_path[length])='/';memcpy((new_path+length)+1,(*ent).d_name,new_length);(new_path[((length+new_length)+1)])='\0';if (((*ent).d_type)==DT_DIR) {lex_parse_recursive(new_path);} else if (((*ent).d_type)==DT_REG) {FILE* file_point=fopen(new_path,"rb");fseek(file_point,(int32_t)0,SEEK_END);arr_u8 file=arr_u8_new(ftell(file_point)+1);rewind(file_point);(file.len)-=1;fread(file.buf,file.len,1,file_point);((file.buf)[(file.len)])='\0';fclose(file_point);printf("Compiling %s:\n",new_path);File abc=(File){new_path,file,};vec_Token tokens=lex(abc);print_tokens(tokens);vec_Expr exprs=parse(abc,tokens);print_exprs(exprs);free(file.buf);}free(new_path);}}closedir(dir);};vec_Expr parse(File file,vec_Token tokens){int32_t index=0;return parse_block(file,tokens,(&index),0);};vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local){vec_Expr exprs=vec_Expr_new(4);while((*index)<(tokens.len)) {switch(((tokens.buf)[(*index)]).kind.type){case 45:{(*index)+=1;return exprs;break;}}Expr expr;if (local) {expr=parse_local(file,tokens,index);} else {expr=parse_global(file,tokens,index);}vec_Expr_push((&exprs),expr);}return exprs;};Expr parse_local(File file,vec_Token tokens,int32_t* index){return (Expr){};};Expr parse_global(File file,vec_Token tokens,int32_t* index){Expr expr;((expr.tags).len)=0;Token token=(tokens.buf)[(*index)];switch(token.kind.type){case 14:{token=((tokens.buf)[((*index)+=1)]);switch(token.kind.type){case 2:{(expr.kind)=(ExprKind){6,token.value,};token=((tokens.buf)[((*index)+=1)]);break;}default:{throw(file,token.index,"expected identifier");break;}}break;}}return expr;};void print_exprs(vec_Expr exprs){printf("Exprs:");print_expr_vec(exprs,0,(void*)0);putchar('\n');};void print_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name){for(int i=0;i<(exprs.len);i+=1) {putchar('\n');if (name!=(void*)0) {printf("%s = [",name);}indent(depth);set_color((Color){2});printf("%s",get_expr_name(((exprs.buf)[i]).kind));set_color((Color){0});print_expr((exprs.buf)[i],depth);if (name!=(void*)0) {indent(depth);putchar(']');}}if ((exprs.len)!=0) {putchar('\n');}};void print_expr(Expr expr,int32_t depth){putchar('(');print_expr_vec(expr.tags,0,"tags");if (((expr.tags).len)!=0) {printf(", ");}switch(expr.kind.type){case 0:{uint8_t* name=expr.kind.u.u0.name;vec_Expr args=expr.kind.u.u0.args;printf("name = %s",name);print_expr_vec(args,depth,"args");break;}case 1:{break;}case 2:{break;}case 3:{break;}case 4:{break;}case 5:{break;}case 6:{uint8_t* name=expr.kind.u.u6.name;printf("name = %s",name);break;}case 7:{break;}case 8:{break;}case 9:{break;}case 10:{break;}case 11:{break;}case 12:{break;}case 13:{break;}case 14:{break;}case 15:{break;}case 16:{break;}case 17:{break;}case 18:{break;}case 19:{break;}case 20:{break;}case 21:{break;}case 22:{break;}case 23:{break;}case 24:{break;}case 25:{break;}case 26:{break;}case 27:{break;}case 28:{break;}case 29:{break;}case 30:{break;}case 31:{break;}case 32:{break;}case 33:{break;}case 34:{break;}case 35:{break;}case 36:{break;}case 37:{break;}case 38:{break;}case 39:{break;}case 40:{break;}case 41:{break;}case 42:{break;}case 43:{break;}case 44:{break;}case 45:{break;}case 46:{break;}case 47:{break;}case 48:{break;}}putchar(')');};uint8_t* get_expr_name(ExprKind kind){switch(kind.type){case 0:{return "TAG";break;}case 1:{return "TYPE";break;}case 2:{return "CONSTR_TYPE";break;}case 3:{return "TAG_DEF";break;}case 5:{return "MOD";break;}case 6:{return "USE";break;}case 7:{return "COMP";break;}default:{return "FIELD";break;}case 9:{return "ENUM";break;}case 10:{return "OPTION";break;}case 11:{return "OPTION_FIELD";break;}case 12:{return "PROP";break;}case 13:{return "DEF";break;}case 14:{return "SUB_DEF";break;}case 15:{return "ARG";break;}case 16:{return "VAR_DEF";break;}}};void indent(int32_t depth){for(int i=0;i<=depth;i+=1) {printf("  ");}};Location get_location(uint8_t* file,int32_t index){Location loc;(loc.line)=1;(loc.column)=1;for(int i=0;i<index;i+=1) {if ((file[i])=='\n') {(loc.line)+=1;(loc.column)=1;} else {(loc.column)+=1;}}return loc;};void print_snippet(arr_u8 file,Location location){printf(" %i | ",location.line);int32_t i=location.line;int32_t length=2;while(i!=0) {length+=1;i/=10;}int32_t line_index=1;for(int i=0;i<(file.len);i+=1) {uint8_t c=(file.buf)[i];if (c=='\n') {line_index+=1;if (line_index>(location.line)) {goto brk_l;}} else if (line_index==(location.line)) {putchar(c);}l:}brk_l:putchar('\n');for(int i=0;i<length;i+=1) {putchar(' ');}putchar('|');for(int i=0;i<(location.column);i+=1) {putchar(' ');}set_color((Color){3});putchar('^');set_color((Color){0});putchar('\n');};void throw(File file,int32_t index,uint8_t* error,...){va_list args;va_start(args,error);Location loc=get_location((file.data).buf,index);printf("%s:%i:%i: ",file.name,loc.line,loc.column);set_color((Color){3});printf("error: ");set_color((Color){0});vprintf(error,args);printf("\n");print_snippet(file.data,loc);exit(1);va_end(args);};void push_char(vec_u8* v,uint8_t c){(((*v).buf)[((*v).len)])=c;((*v).len)+=1;if (((*v).len)==((*v).cap)) {((*v).cap)*=2;((*v).buf)=realloc((*v).buf,sizeof(uint8_t)*((*v).cap));}(((*v).buf)[((*v).len)])=0;};void empty(vec_u8* v){(((*v).buf)[0])=(((*v).len)=0);};