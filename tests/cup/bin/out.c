#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <dirent.h>
#include <ctype.h>
#include <stdarg.h>
typedef struct vec_Expr vec_Expr;typedef struct vec_PathPart vec_PathPart;typedef struct vec_GenericType vec_GenericType;typedef struct MangledPath MangledPath;typedef struct vec_vec_MangledPath vec_vec_MangledPath;typedef struct vec_MangledPath vec_MangledPath;typedef struct GenericType GenericType;typedef struct vec_u8 vec_u8;typedef struct Command Command;typedef struct GenericInstance GenericInstance;typedef struct vec_GenericInstance vec_GenericInstance;typedef struct Req Req;typedef struct vec_Req vec_Req;typedef struct TokenKind TokenKind;typedef struct Token Token;typedef struct vec_Token vec_Token;typedef struct Color Color;typedef struct arr_u8 arr_u8;typedef struct File File;typedef struct vec_VarName vec_VarName;typedef struct PathPart PathPart;typedef struct VarName VarName;typedef struct ExprKind ExprKind;typedef struct Expr Expr;typedef struct Location Location;void REMOVE_ME2();vec_Expr vec_Expr_new(int32_t cap);vec_PathPart vec_PathPart_new(int32_t cap);vec_GenericType vec_GenericType_new(int32_t cap);void analyze(vec_Expr ast);vec_vec_MangledPath vec_vec_MangledPath_new(int32_t cap);void analyze_expr_vec(vec_Expr exprs);void analyze_expr(Expr* expr);void vec_PathPart_join_vec(vec_PathPart* this,vec_PathPart other);void vec_PathPart_join_back(vec_PathPart* this,vec_PathPart other);void vec_GenericType_push(vec_GenericType* this,GenericType item);void vec_vec_MangledPath_push(vec_vec_MangledPath* this,vec_MangledPath item);vec_MangledPath vec_MangledPath_new(int32_t cap);void vec_MangledPath_push(vec_MangledPath* this,MangledPath item);uint8_t* mangle(Expr expr,uint8_t gens,uint8_t new);uint8_t* new_mangle(int32_t index);vec_u8 vec_u8_new(int32_t cap);void vec_u8_push(vec_u8* this,uint8_t item);uint8_t compare_paths(vec_PathPart path1,vec_PathPart path2,uint8_t gens);uint8_t compare_gens(vec_Expr gens1,vec_Expr gens2);void command_help(uint8_t* n,uint8_t* d,uint8_t* o);Command get_command(int32_t argc,uint8_t** argv);uint8_t* generate(vec_Expr ast);vec_GenericInstance vec_GenericInstance_new(int32_t cap);vec_Req vec_Req_new(int32_t cap);void vec_u8_join(vec_u8* this,uint8_t* other);void generate_expr_vec(vec_u8* out,vec_Expr exprs,uint8_t semicolon,uint8_t comma);void generate_expr(vec_u8* out,Expr expr,uint8_t last,uint8_t semicolon,int32_t parenths);void vec_Req_push(vec_Req* this,Req item);uint8_t has_generics(Expr expr);void register_path_use(Expr expr);void vec_GenericInstance_push(vec_GenericInstance* this,GenericInstance item);Expr apply_genenerics(Expr expr);int32_t get_token_length(TokenKind kind);uint8_t* get_token_name(TokenKind kind);void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal);TokenKind get_keyword(uint8_t* value);uint8_t is_binary_operator(TokenKind kind);vec_Token lex(File file);vec_Token vec_Token_new(int32_t cap);void vec_u8_empty(vec_u8* this);void vec_Token_push(vec_Token* this,Token item);void print_tokens(vec_Token tokens);int32_t main(int32_t argc,uint8_t** argv);uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv);void set_color(Color color);void lex_parse_recursive(uint8_t* path,vec_Expr* ast);arr_u8 arr_u8_new(int32_t len);void vec_Expr_push(vec_Expr* this,Expr item);void REMOVE_ME();vec_VarName vec_VarName_new(int32_t cap);vec_Expr parse(File file,vec_Token tokens);vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local);Token expect_token(File file,vec_Token tokens,int32_t* index,TokenKind kind,uint8_t* error);uint8_t opt_token(vec_Token tokens,int32_t* index,TokenKind kind);Expr parse_local(File file,vec_Token tokens,int32_t* index,int32_t op_level,uint8_t opt);Expr* alloc_Expr(Expr obj);void vec_VarName_push(vec_VarName* this,VarName item);Expr parse_global(File file,vec_Token tokens,int32_t* index);uint8_t* parse_label(File file,vec_Token tokens,int32_t* index,uint8_t opt);vec_Expr parse_tags(File file,vec_Token tokens,int32_t* index);Expr parse_path(File file,vec_Token tokens,int32_t* index);Expr parse_opt_path(File file,vec_Token tokens,int32_t* index);void vec_PathPart_push(vec_PathPart* this,PathPart item);vec_Expr parse_fields(File file,vec_Token tokens,int32_t* index);vec_Expr parse_options(File file,vec_Token tokens,int32_t* index);void print_exprs(vec_Expr exprs);void print_expr_vec(vec_Expr exprs,int32_t depth);void print_opt_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name,uint8_t _next);void print_expr(Expr expr,int32_t depth);uint8_t* get_expr_name(ExprKind kind);void indent(int32_t depth);Location get_location(uint8_t* file,int32_t index);void print_snippet(arr_u8 file,Location location);void throw(File file,int32_t index,uint8_t* error,...);void push_char(vec_u8* v,uint8_t c);struct vec_Expr{Expr* buf;int32_t len;int32_t cap;};struct vec_PathPart{PathPart* buf;int32_t len;int32_t cap;};struct vec_GenericType{GenericType* buf;int32_t len;int32_t cap;};struct MangledPath{vec_PathPart path;uint8_t* name;};struct vec_MangledPath{MangledPath* buf;int32_t len;int32_t cap;};struct vec_vec_MangledPath{vec_MangledPath* buf;int32_t len;int32_t cap;};struct GenericType{uint8_t* name;Expr* path;Expr* _type;};struct vec_u8{uint8_t* buf;int32_t len;int32_t cap;};union CommandUnion{char _;};struct Command{int _type;union CommandUnion u;};struct GenericInstance{uint8_t* name;Expr* path;};struct vec_GenericInstance{GenericInstance* buf;int32_t len;int32_t cap;};struct Req{uint8_t* name;};struct vec_Req{Req* buf;int32_t len;int32_t cap;};union TokenKindUnion{char _;};struct TokenKind{int _type;union TokenKindUnion u;};struct Token{TokenKind kind;int32_t index;uint8_t* value;};struct vec_Token{Token* buf;int32_t len;int32_t cap;};union ColorUnion{char _;};struct Color{int _type;union ColorUnion u;};struct arr_u8{uint8_t* buf;int32_t len;};struct File{uint8_t* name;arr_u8 data;};struct vec_VarName{VarName* buf;int32_t len;int32_t cap;};struct PathPart{uint8_t* name;vec_Expr gens;};struct VarName{uint8_t* name;};typedef struct{uint8_t* name;vec_Expr args;}ExprKind_Tag;typedef struct{vec_PathPart path;}ExprKind_Path;typedef struct{Expr* path;vec_Expr args;vec_Expr body;}ExprKind_TagDef;typedef struct{vec_Expr body;}ExprKind_Block;typedef struct{Expr* path;vec_Expr body;}ExprKind_Mod;typedef struct{Expr* path;}ExprKind_Use;typedef struct{Expr* _type;uint8_t* name;}ExprKind_Field;typedef struct{Expr* path;vec_Expr fields;vec_Expr body;}ExprKind_Comp;typedef struct{Expr* path;vec_Expr opts;vec_Expr body;}ExprKind_Enum;typedef struct{uint8_t* name;vec_Expr fields;}ExprKind_Option;typedef struct{Expr* path;vec_Expr body;}ExprKind_Prop;typedef struct{Expr* _prop;Expr* target;vec_Expr body;}ExprKind_Def;typedef struct{Expr* ret_type;Expr* path;vec_Expr args;vec_Expr body;}ExprKind_SubDef;typedef struct{Expr* _type;Expr* path;Expr* value;}ExprKind_VarDef;typedef struct{Expr* _type;uint8_t* name;Expr* value;}ExprKind_LocalVarDef;typedef struct{Expr* path;vec_Expr args;}ExprKind_SubCall;typedef struct{Expr* path;}ExprKind_VarUse;typedef struct{uint8_t* value;}ExprKind_StringLit;typedef struct{uint8_t* value;}ExprKind_CharLit;typedef struct{uint8_t* value;}ExprKind_IntLit;typedef struct{uint8_t* value;}ExprKind_FloatLit;typedef struct{uint8_t value;}ExprKind_BoolLit;typedef struct{vec_Expr body;}ExprKind_LocalBlock;typedef struct{Expr* _if;vec_Expr _elif;Expr* _else;}ExprKind_If;typedef struct{Expr* cond;vec_Expr body;}ExprKind_IfBranch;typedef struct{vec_Expr body;}ExprKind_ElseBranch;typedef struct{vec_Expr body;}ExprKind_Loop;typedef struct{Expr* cond;vec_Expr body;}ExprKind_While;typedef struct{uint8_t* iter;Expr* iter_value;Expr* cond;Expr* _next;vec_Expr body;}ExprKind_For;typedef struct{vec_VarName vars;Expr* iter;vec_Expr body;}ExprKind_Each;typedef struct{Expr* value;vec_Expr cases;}ExprKind_Match;typedef struct{vec_Expr values;vec_Expr body;}ExprKind_Case;typedef struct{uint8_t* label;Expr* value;}ExprKind_Ret;typedef struct{uint8_t* label;}ExprKind_Next;typedef struct{uint8_t* label;}ExprKind_Jump;typedef struct{uint8_t* label;Expr* value;}ExprKind_Try;typedef struct{Expr* value;TokenKind kind;}ExprKind_UnaryOp;typedef struct{Expr* lhs;Expr* rhs;TokenKind kind;}ExprKind_BinaryOp;typedef struct{Expr* cond;Expr* valueA;Expr* valueB;}ExprKind_TernaryOp;union ExprKindUnion{ExprKind_Tag u1;ExprKind_Path u2;ExprKind_TagDef u3;ExprKind_Block u4;ExprKind_Mod u5;ExprKind_Use u6;ExprKind_Field u7;ExprKind_Comp u8;ExprKind_Enum u9;ExprKind_Option u10;ExprKind_Prop u11;ExprKind_Def u12;ExprKind_SubDef u13;ExprKind_VarDef u14;ExprKind_LocalVarDef u15;ExprKind_SubCall u16;ExprKind_VarUse u17;ExprKind_StringLit u18;ExprKind_CharLit u19;ExprKind_IntLit u20;ExprKind_FloatLit u21;ExprKind_BoolLit u22;ExprKind_LocalBlock u25;ExprKind_If u26;ExprKind_IfBranch u27;ExprKind_ElseBranch u28;ExprKind_Loop u29;ExprKind_While u30;ExprKind_For u31;ExprKind_Each u32;ExprKind_Match u33;ExprKind_Case u34;ExprKind_Ret u35;ExprKind_Next u36;ExprKind_Jump u37;ExprKind_Try u38;ExprKind_UnaryOp u39;ExprKind_BinaryOp u40;ExprKind_TernaryOp u41;char _;};struct ExprKind{int _type;union ExprKindUnion u;};struct Expr{ExprKind kind;vec_Expr tags;uint8_t* label;};struct Location{int32_t line;int32_t column;};vec_Expr vec_Expr_new(int32_t cap){return (vec_Expr){.buf=malloc(sizeof(Expr)*cap),.len=0,.cap=cap,};};vec_PathPart vec_PathPart_new(int32_t cap){return (vec_PathPart){.buf=malloc(sizeof(PathPart)*cap),.len=0,.cap=cap,};};vec_GenericType vec_GenericType_new(int32_t cap){return (vec_GenericType){.buf=malloc(sizeof(GenericType)*cap),.len=0,.cap=cap,};};vec_vec_MangledPath vec_vec_MangledPath_new(int32_t cap){return (vec_vec_MangledPath){.buf=malloc(sizeof(vec_MangledPath)*cap),.len=0,.cap=cap,};};void vec_PathPart_join_vec(vec_PathPart* this,vec_PathPart other){if((other.len)==0){return;}int32_t old_len=(*this).len;((*this).len)+=(other.len);while(((*this).len)>=((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(PathPart)*((*this).cap));}memcpy(((*this).buf)+old_len,other.buf,(other.len)*sizeof(PathPart));};void vec_PathPart_join_back(vec_PathPart* this,vec_PathPart other){if((other.len)==0){return;}int32_t old_len=(*this).len;((*this).len)+=(other.len);while(((*this).len)>=((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(PathPart)*((*this).cap));}memcpy(((*this).buf)+(other.len),(*this).buf,sizeof(PathPart)*old_len);memcpy((*this).buf,other.buf,sizeof(PathPart)*(other.len));};void vec_GenericType_push(vec_GenericType* this,GenericType item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(GenericType)*((*this).cap));}};void vec_vec_MangledPath_push(vec_vec_MangledPath* this,vec_MangledPath item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(vec_MangledPath)*((*this).cap));}};vec_MangledPath vec_MangledPath_new(int32_t cap){return (vec_MangledPath){.buf=malloc(sizeof(MangledPath)*cap),.len=0,.cap=cap,};};void vec_MangledPath_push(vec_MangledPath* this,MangledPath item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(MangledPath)*((*this).cap));}};vec_u8 vec_u8_new(int32_t cap){return (vec_u8){.buf=malloc(sizeof(uint8_t)*cap),.len=0,.cap=cap,};};void vec_u8_push(vec_u8* this,uint8_t item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(uint8_t)*((*this).cap));}};vec_GenericInstance vec_GenericInstance_new(int32_t cap){return (vec_GenericInstance){.buf=malloc(sizeof(GenericInstance)*cap),.len=0,.cap=cap,};};vec_Req vec_Req_new(int32_t cap){return (vec_Req){.buf=malloc(sizeof(Req)*cap),.len=0,.cap=cap,};};void vec_u8_join(vec_u8* this,uint8_t* other){int32_t old_len=(*this).len;((*this).len)+=strlen(other);while(((*this).len)>=((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(uint8_t)*((*this).cap));}strcpy(((*this).buf)+old_len,other);};void vec_Req_push(vec_Req* this,Req item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Req)*((*this).cap));}};void vec_GenericInstance_push(vec_GenericInstance* this,GenericInstance item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(GenericInstance)*((*this).cap));}};vec_Token vec_Token_new(int32_t cap){return (vec_Token){.buf=malloc(sizeof(Token)*cap),.len=0,.cap=cap,};};void vec_u8_empty(vec_u8* this){(((*this).buf)[0])=(((*this).len)=0);};void vec_Token_push(vec_Token* this,Token item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Token)*((*this).cap));}};arr_u8 arr_u8_new(int32_t len){return (arr_u8){.buf=malloc(sizeof(uint8_t)*len),.len=len,};};void vec_Expr_push(vec_Expr* this,Expr item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Expr)*((*this).cap));}};vec_VarName vec_VarName_new(int32_t cap){return (vec_VarName){.buf=malloc(sizeof(VarName)*cap),.len=0,.cap=cap,};};Expr* alloc_Expr(Expr obj){Expr* foo=malloc(sizeof(Expr));(*foo)=obj;return foo;};void vec_VarName_push(vec_VarName* this,VarName item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(VarName)*((*this).cap));}};void vec_PathPart_push(vec_PathPart* this,PathPart item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if(((*this).len)==((*this).cap)){((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(PathPart)*((*this).cap));}};void REMOVE_ME2(){vec_Expr_new(0);vec_PathPart_new(0);vec_GenericType_new(0);};vec_PathPart mods;int32_t mangle_index=0;vec_vec_MangledPath mangled_paths;vec_GenericType gen_types;void analyze(vec_Expr ast){mods=vec_PathPart_new(4);mangled_paths=vec_vec_MangledPath_new(8);gen_types=vec_GenericType_new(8);analyze_expr_vec(ast);};void analyze_expr_vec(vec_Expr exprs){for(int i=0;i<(exprs.len);i+=1){analyze_expr((exprs.buf)+i);}};void analyze_expr(Expr* expr){Expr* path;if((*expr).kind._type==4){vec_Expr body=(*expr).kind.u.u4.body;analyze_expr_vec(body);return;}else if((*expr).kind._type==5){Expr* path=(*expr).kind.u.u5.path;vec_Expr body=(*expr).kind.u.u5.body;int32_t old_mods_len=mods.len;if((*path).kind._type==2){vec_PathPart _path=(*path).kind.u.u2.path;vec_PathPart_join_vec((&mods),_path);}analyze_expr_vec(body);(mods.len)=old_mods_len;return;}else if((*expr).kind._type==8){Expr* _path=(*expr).kind.u.u8.path;path=_path;}else if((*expr).kind._type==9){Expr* _path=(*expr).kind.u.u9.path;path=_path;}else if((*expr).kind._type==13){Expr* _=(*expr).kind.u.u13.ret_type;Expr* _path=(*expr).kind.u.u13.path;path=_path;}else{return;}vec_PathPart_join_back((&(((((*path).kind).u).u2).path)),mods);if(has_generics((*path))){vec_GenericType_push((&gen_types),(GenericType){.name=mangle((*path),0,0),.path=path,._type=expr,});return;}for(int i=0;i<(((*expr).tags).len);i+=1){if(((((*expr).tags).buf)[i]).kind._type==1){uint8_t* name=((((*expr).tags).buf)[i]).kind.u.u1.name;vec_Expr args=((((*expr).tags).buf)[i]).kind.u.u1.args;if(strcmp(name,"bind")==0){if(((args.buf)[0]).kind._type==18){uint8_t* value=((args.buf)[0]).kind.u.u18.value;vec_PathPart _path=((((*path).kind).u).u2).path;while((_path.len)>(mangled_paths.len)){vec_vec_MangledPath_push((&mangled_paths),vec_MangledPath_new(32));}vec_MangledPath_push((&((mangled_paths.buf)[((_path.len)-1)])),(MangledPath){.path=_path,.name=value,});}}}l:}brk_l:};uint8_t* mangle(Expr expr,uint8_t gens,uint8_t new){vec_PathPart path=(((expr.kind).u).u2).path;if((path.len)<=(mangled_paths.len)){vec_MangledPath paths=(mangled_paths.buf)[((path.len)-1)];for(int i=0;i<(paths.len);i+=1){if(compare_paths(path,((paths.buf)[i]).path,gens)){if(new){return (void*)0;} else{return ((paths.buf)[i]).name;}}l:}brk_l:} else{while((path.len)>(mangled_paths.len)){vec_vec_MangledPath_push((&mangled_paths),vec_MangledPath_new(32));}}uint8_t* name=new_mangle(mangle_index+=1);vec_MangledPath_push((&((mangled_paths.buf)[((path.len)-1)])),(MangledPath){.path=path,.name=name,});return name;};uint8_t* new_mangle(int32_t index){vec_u8 name=vec_u8_new(4);vec_u8_push((&name),'_');while(index>0){int32_t i=index%62;if(i<10){i+=48;} else if(i<36){i+=55;} else{i+=61;}vec_u8_push((&name),i);index/=62;}((name.buf)[(name.len)])='\0';return name.buf;};uint8_t compare_paths(vec_PathPart path1,vec_PathPart path2,uint8_t gens){if((path1.len)!=(path2.len)){return 0;}for(int i=0;i<(path1.len);i+=1){PathPart part1=(path1.buf)[i];PathPart part2=(path2.buf)[i];if(strcmp(part1.name,part2.name)==0){if((gens==0)||compare_gens(part1.gens,part2.gens)){goto l;}}return 0;l:}brk_l:return 1;};uint8_t compare_gens(vec_Expr gens1,vec_Expr gens2){if((gens1.len)!=(gens2.len)){return 0;}for(int i=0;i<(gens1.len);i+=1){vec_PathPart path1=(((((gens1.buf)[i]).kind).u).u2).path;vec_PathPart path2=(((((gens2.buf)[i]).kind).u).u2).path;if(compare_paths(path1,path2,1)==0){return 0;}}return 1;};
typedef struct dirent dirent;
void command_help(uint8_t* n,uint8_t* d,uint8_t* o){printf(d);printf("\n\nUSAGE:\n    cup ");printf(n);printf(" [OPTIONS]\n\nOPTIONS:");printf(o);printf("\n");};uint8_t* command_options_empty="\n    No options are available for this command";uint8_t* command_options_compile="\n    -i, --input     Specify the input file name\n    -o, --output    Specify the output file name\n    -cg, --gcc     Use GCC as a compiler\n    -cm, --msvc    Use MSVC as a compiler\n    -cc, --clang   use Clang as a compiler\n    -ct, --tcc     Use TinyCC as a compiler";Command get_command(int32_t argc,uint8_t** argv){if(argc==1){return (Command){1};}uint8_t is_command=0;vec_u8 vector=vec_u8_new(16);for(int i=1;i<argc;i+=1){if(i==4){goto brk_l;}if(((argv[i])[0])=='-'){if(is_command){goto brk_l;}goto l;}is_command=1;int32_t length=strlen(argv[i]);for(int c=0;c<length;c+=1){vec_u8_push((&vector),(argv[i])[c]);}l:}brk_l:vec_u8_push((&vector),'\0');uint8_t* input=vector.buf;if(strcmp(input,"help")==0){return (Command){1};} else if(strcmp(input,"helprun")==0){return (Command){2};} else if(strcmp(input,"helpbuild")==0){return (Command){3};} else if(strcmp(input,"helpcheck")==0){return (Command){4};} else if(strcmp(input,"helpupdate")==0){return (Command){6};} else if(strcmp(input,"helpadd")==0){return (Command){7};} else if(strcmp(input,"helpremove")==0){return (Command){8};} else if(strcmp(input,"helpgendocs")==0){return (Command){9};} else if(strcmp(input,"helpgenbinds")==0){return (Command){10};} else if(strcmp(input,"helpselfupdate")==0){return (Command){11};} else if(strcmp(input,"helpselfinstall")==0){return (Command){12};} else if(strcmp(input,"helpselfuninstall")==0){return (Command){13};} else if(strcmp(input,"run")==0){return (Command){14};} else if(strcmp(input,"build")==0){return (Command){15};} else if(strcmp(input,"check")==0){return (Command){16};} else if(strcmp(input,"update")==0){return (Command){18};} else if(strcmp(input,"add")==0){return (Command){19};} else if(strcmp(input,"remove")==0){return (Command){20};} else if(strcmp(input,"gendocs")==0){return (Command){21};} else if(strcmp(input,"genbinds")==0){return (Command){22};} else if(strcmp(input,"selfupdate")==0){return (Command){23};} else if(strcmp(input,"selfinstall")==0){return (Command){24};} else if(strcmp(input,"selfuninstall")==0){return (Command){25};}return (Command){0};};vec_GenericInstance gens;vec_Req reqs;vec_u8 types_headers;vec_u8 funcs_headers;vec_u8 types;vec_u8 funcs;uint8_t* generate(vec_Expr ast){gens=vec_GenericInstance_new(2);reqs=vec_Req_new(4);types_headers=vec_u8_new(256);funcs_headers=vec_u8_new(256);types=vec_u8_new(1024);funcs=vec_u8_new(1024);generate_expr_vec((void*)0,ast,0,0);vec_u8 out=vec_u8_new((((((reqs.len)*32)+(types_headers.len))+(funcs_headers.len))+(types.len))+(funcs.len));((types_headers.buf)[(types_headers.len)])=(((funcs_headers.buf)[(funcs_headers.len)])=(((types.buf)[(types.len)])=(((funcs.buf)[(funcs.len)])='\0')));for(int i=0;i<(reqs.len);i+=1){vec_u8_join((&out),"#include ");vec_u8_push((&out),'"');vec_u8_join((&out),((reqs.buf)[i]).name);vec_u8_push((&out),'"');vec_u8_join((&out),"\n");}vec_u8_join((&out),types_headers.buf);vec_u8_join((&out),funcs_headers.buf);vec_u8_join((&out),types.buf);vec_u8_join((&out),funcs.buf);((out.buf)[(out.len)])='\0';return out.buf;};void generate_expr_vec(vec_u8* out,vec_Expr exprs,uint8_t semicolon,uint8_t comma){for(int i=0;i<(exprs.len);i+=1){uint8_t is_last=(i+1)==(exprs.len);generate_expr(out,(exprs.buf)[i],is_last,semicolon,0);if(comma&&(is_last==0)){vec_u8_push(out,',');}}};void generate_expr(vec_u8* out,Expr expr,uint8_t last,uint8_t semicolon,int32_t parenths){for(int i=0;i<((expr.tags).len);i+=1){if((((expr.tags).buf)[i]).kind._type==1){uint8_t* name=(((expr.tags).buf)[i]).kind.u.u1.name;vec_Expr args=(((expr.tags).buf)[i]).kind.u.u1.args;if(strcmp(name,"os")==0){if(((args.buf)[0]).kind._type==18){uint8_t* value=((args.buf)[0]).kind.u.u18.value;
#if defined _WIN32
if(strcmp(value,"win")!=0){return;}
#elif defined __linux__
if(strcmp(value,"linux")!=0){return;}
#elif defined __APPLE__
if(strcmp(value,"mac")!=0){return;}
#endif
0+0;}} else if(strcmp(name,"req")==0){if(((args.buf)[0]).kind._type==18){uint8_t* value=((args.buf)[0]).kind.u.u18.value;for(int ii=0;ii<(reqs.len);ii+=1){if(strcmp(((reqs.buf)[ii]).name,value)==0){goto l;}}vec_Req_push((&reqs),(Req){.name=value,});}} else if(strcmp(name,"raw")==0){if(((args.buf)[0]).kind._type==18){uint8_t* value=((args.buf)[0]).kind.u.u18.value;vec_u8_join(out,value);}} else if(strcmp(name,"bind")==0){return;}}l:}brk_l:if(expr.kind._type==4){vec_Expr body=expr.kind.u.u4.body;generate_expr_vec(out,body,0,0);}else if(expr.kind._type==5){Expr* _=expr.kind.u.u5.path;vec_Expr body=expr.kind.u.u5.body;generate_expr_vec(out,body,0,0);}else if(expr.kind._type==7){Expr* _type=expr.kind.u.u7._type;uint8_t* name=expr.kind.u.u7.name;Expr __type=apply_genenerics((*_type));register_path_use(__type);vec_u8_join(out,mangle(__type,1,0));vec_u8_push(out,' ');vec_u8_join(out,name);if(semicolon){vec_u8_push(out,';');} else if(last==0){vec_u8_push(out,',');}}else if(expr.kind._type==8){Expr* path=expr.kind.u.u8.path;vec_Expr fields=expr.kind.u.u8.fields;vec_Expr body=expr.kind.u.u8.body;uint8_t has_gens=has_generics((*path));if(((gens.len)==0)&&has_gens){return;}Expr _path=apply_genenerics((*path));uint8_t* name=mangle(_path,1,has_gens);if(has_gens&&(name==(void*)0)){return;}vec_u8_join((&types_headers),"typedef struct ");vec_u8_join((&types_headers),name);vec_u8_push((&types_headers),' ');vec_u8_join((&types_headers),name);vec_u8_push((&types_headers),';');vec_u8 comp_out=vec_u8_new(128);vec_u8_join((&comp_out),"typedef struct ");vec_u8_join((&comp_out),name);vec_u8_push((&comp_out),'{');generate_expr_vec((&comp_out),fields,1,0);vec_u8_push((&comp_out),'}');vec_u8_join((&comp_out),name);vec_u8_push((&comp_out),';');((comp_out.buf)[(comp_out.len)])='\0';vec_u8_join((&types),comp_out.buf);free(comp_out.buf);}else if(expr.kind._type==9){Expr* path=expr.kind.u.u9.path;vec_Expr opts=expr.kind.u.u9.opts;vec_Expr body=expr.kind.u.u9.body;uint8_t has_gens=has_generics((*path));if(((gens.len)==0)&&has_gens){return;}Expr _path=apply_genenerics((*path));uint8_t* name=mangle(_path,1,has_gens);if(has_gens&&(name==(void*)0)){return;}vec_u8_join((&types_headers),"typedef struct ");vec_u8_join((&types_headers),name);vec_u8_push((&types_headers),' ');vec_u8_join((&types_headers),name);vec_u8_push((&types_headers),';');vec_u8 enum_out=vec_u8_new(256);vec_u8_join((&enum_out),"typedef struct ");vec_u8_join((&enum_out),name);vec_u8_push((&enum_out),'{');vec_u8_join((&enum_out),"int t;union{");for(int i=0;i<(opts.len);i+=1){vec_u8_join((&enum_out),"struct{");vec_u8_join((&enum_out),"}u");uint8_t* union_name=new_mangle(i+1);vec_u8_join((&enum_out),union_name);free(union_name);vec_u8_push((&enum_out),';');}vec_u8_join((&enum_out),"}u;}");vec_u8_join((&enum_out),name);vec_u8_push((&enum_out),';');((enum_out.buf)[(enum_out.len)])='\0';vec_u8_join((&types),enum_out.buf);free(enum_out.buf);}else if(expr.kind._type==11){}else if(expr.kind._type==12){}else if(expr.kind._type==13){Expr* ret_type=expr.kind.u.u13.ret_type;Expr* path=expr.kind.u.u13.path;vec_Expr args=expr.kind.u.u13.args;vec_Expr body=expr.kind.u.u13.body;uint8_t has_gens=has_generics((*path));if(((gens.len)==0)&&has_gens){return;}Expr _path=apply_genenerics((*path));uint8_t* name=mangle(_path,1,has_gens);if(has_gens&&(name==(void*)0)){return;}vec_u8 sub_out=vec_u8_new(256);if(ret_type!=(void*)0){Expr _ret_type=apply_genenerics((*ret_type));vec_u8_join((&sub_out),mangle(_ret_type,1,0));vec_u8_push((&sub_out),' ');} else{vec_u8_join((&sub_out),"void ");}vec_u8_join((&sub_out),name);vec_u8_push((&sub_out),'(');generate_expr_vec((&sub_out),args,0,0);((sub_out.buf)[(sub_out.len)])='\0';vec_u8_join((&funcs_headers),sub_out.buf);vec_u8_join((&funcs_headers),");");vec_u8_join((&sub_out),"){");generate_expr_vec((&sub_out),body,1,0);vec_u8_join((&sub_out),"};");((sub_out.buf)[(sub_out.len)])='\0';vec_u8_join((&funcs),sub_out.buf);free(sub_out.buf);}else if(expr.kind._type==14){Expr* _type=expr.kind.u.u14._type;Expr* path=expr.kind.u.u14.path;Expr* value=expr.kind.u.u14.value;Expr __type=apply_genenerics((*_type));register_path_use(__type);vec_u8_join(out,mangle(__type,1,0));vec_u8_push(out,' ');Expr _path=apply_genenerics((*path));register_path_use(_path);vec_u8_join(out,mangle(_path,1,0));if(value!=(void*)0){vec_u8_push(out,'=');generate_expr(out,(*value),0,0,0);}vec_u8_push(out,';');}else if(expr.kind._type==15){Expr* _type=expr.kind.u.u15._type;uint8_t* name=expr.kind.u.u15.name;Expr* value=expr.kind.u.u15.value;Expr __type=apply_genenerics((*_type));register_path_use(__type);vec_u8_join(out,mangle(__type,1,0));vec_u8_push(out,' ');vec_u8_join(out,name);if(value!=(void*)0){vec_u8_push(out,'=');generate_expr(out,(*value),0,0,0);}vec_u8_push(out,';');}else if(expr.kind._type==16){Expr* path=expr.kind.u.u16.path;vec_Expr args=expr.kind.u.u16.args;Expr _path=apply_genenerics((*path));register_path_use(_path);vec_u8_join(out,mangle(_path,1,0));vec_u8_push(out,'(');generate_expr_vec(out,args,0,1);vec_u8_push(out,')');if(semicolon){vec_u8_push(out,';');}}else if(expr.kind._type==17){Expr* path=expr.kind.u.u17.path;Expr _path=apply_genenerics((*path));register_path_use(_path);vec_u8_join(out,mangle(_path,1,0));if(semicolon){vec_u8_push(out,';');}}else if(expr.kind._type==18){uint8_t* value=expr.kind.u.u18.value;vec_u8_push(out,'"');vec_u8_join(out,value);vec_u8_push(out,'"');}else if(expr.kind._type==19){uint8_t* value=expr.kind.u.u19.value;vec_u8_push(out,39);vec_u8_join(out,value);vec_u8_push(out,39);}else if(expr.kind._type==20){uint8_t* value=expr.kind.u.u20.value;vec_u8_join(out,value);}else if(expr.kind._type==21){uint8_t* value=expr.kind.u.u21.value;vec_u8_join(out,value);}else if(expr.kind._type==22){uint8_t value=expr.kind.u.u22.value;if(value){vec_u8_push(out,'1');} else{vec_u8_push(out,'0');}}else if(expr.kind._type==25){vec_Expr body=expr.kind.u.u25.body;vec_u8_push(out,'{');generate_expr_vec(out,body,1,0);vec_u8_push(out,'}');}else if(expr.kind._type==26){Expr* _if=expr.kind.u.u26._if;vec_Expr _elif=expr.kind.u.u26._elif;Expr* _else=expr.kind.u.u26._else;generate_expr(out,(*_if),0,0,0);for(int i=0;i<(_elif.len);i+=1){vec_u8_join(out,"else ");generate_expr(out,(_elif.buf)[i],0,0,0);}if(_else!=(void*)0){generate_expr(out,(*_else),0,0,0);}}else if(expr.kind._type==27){Expr* cond=expr.kind.u.u27.cond;vec_Expr body=expr.kind.u.u27.body;vec_u8_join(out,"if(");generate_expr(out,(*cond),0,0,0);vec_u8_join(out,"){");generate_expr_vec(out,body,1,0);vec_u8_push(out,'}');}else if(expr.kind._type==28){vec_Expr body=expr.kind.u.u28.body;vec_u8_join(out,"else{");generate_expr_vec(out,body,1,0);vec_u8_push(out,'}');}else if(expr.kind._type==29){vec_Expr body=expr.kind.u.u29.body;vec_u8_join(out,"for(;;){");generate_expr_vec(out,body,1,0);vec_u8_push(out,'}');}else if(expr.kind._type==30){Expr* cond=expr.kind.u.u30.cond;vec_Expr body=expr.kind.u.u30.body;vec_u8_join(out,"while(");generate_expr(out,(*cond),0,0,0);vec_u8_join(out,"){");generate_expr_vec(out,body,1,0);vec_u8_push(out,'}');}else if(expr.kind._type==31){uint8_t* iter=expr.kind.u.u31.iter;Expr* iter_value=expr.kind.u.u31.iter_value;Expr* cond=expr.kind.u.u31.cond;Expr* _next=expr.kind.u.u31._next;vec_Expr body=expr.kind.u.u31.body;vec_u8_join(out,"for(int ");vec_u8_join(out,iter);if(iter_value!=(void*)0){vec_u8_push(out,'=');generate_expr(out,(*iter_value),0,0,0);}vec_u8_push(out,';');generate_expr(out,(*cond),0,0,0);vec_u8_push(out,';');generate_expr(out,(*_next),0,0,0);vec_u8_join(out,"){");generate_expr_vec(out,body,1,0);vec_u8_push(out,'}');}else if(expr.kind._type==32){}else if(expr.kind._type==33){}else if(expr.kind._type==34){}else if(expr.kind._type==35){uint8_t* label=expr.kind.u.u35.label;Expr* value=expr.kind.u.u35.value;if(label!=(void*)0){vec_u8_join(out,"goto brk_");vec_u8_join(out,label);} else{vec_u8_join(out,"return");}if(value!=(void*)0){vec_u8_push(out,' ');generate_expr(out,(*value),0,0,0);}vec_u8_push(out,';');}else if(expr.kind._type==36){uint8_t* label=expr.kind.u.u36.label;if(label!=(void*)0){vec_u8_join(out,"goto ");vec_u8_join(out,label);vec_u8_push(out,';');} else{vec_u8_join(out,"continue;");}}else if(expr.kind._type==37){uint8_t* label=expr.kind.u.u37.label;vec_u8_join(out,"goto ");vec_u8_join(out,label);vec_u8_push(out,';');}else if(expr.kind._type==38){}else if(expr.kind._type==39){Expr* value=expr.kind.u.u39.value;TokenKind kind=expr.kind.u.u39.kind;vec_u8_push(out,'(');if(kind._type==53){vec_u8_push(out,'!');}else if(kind._type==49){vec_u8_push(out,'*');}else if(kind._type==50){vec_u8_push(out,'&');}generate_expr(out,(*value),0,0,parenths+1);vec_u8_push(out,')');}else if(expr.kind._type==40){Expr* lhs=expr.kind.u.u40.lhs;Expr* rhs=expr.kind.u.u40.rhs;TokenKind kind=expr.kind.u.u40.kind;if(parenths>0){vec_u8_push(out,'(');}if(kind._type==34){vec_u8_push(out,'(');vec_u8_push(out,')');generate_expr(out,(*lhs),0,0,parenths+1);}else{generate_expr(out,(*lhs),0,0,parenths+1);if(kind._type==51){vec_u8_push(out,'=');}else if(kind._type==52){vec_u8_join(out,"==");}else if(kind._type==55){vec_u8_join(out,"&&");}else if(kind._type==56){vec_u8_join(out,"||");}else if(kind._type==57){vec_u8_push(out,'<');}else if(kind._type==58){vec_u8_join(out,"<=");}else if(kind._type==59){vec_u8_push(out,'>');}else if(kind._type==60){vec_u8_join(out,">=");}else if(kind._type==61){vec_u8_push(out,'+');}else if(kind._type==62){vec_u8_join(out,"+=");}else if(kind._type==63){vec_u8_push(out,'-');}else if(kind._type==64){vec_u8_join(out,"-=");}else if(kind._type==65){vec_u8_push(out,'*');}else if(kind._type==66){vec_u8_join(out,"*=");}else if(kind._type==67){vec_u8_push(out,'/');}else if(kind._type==68){vec_u8_join(out,"/=");}else if(kind._type==69){vec_u8_push(out,'%');}else if(kind._type==70){vec_u8_join(out,"%=");}else if(kind._type==54){vec_u8_join(out,"!=");}else if(kind._type==39){vec_u8_push(out,'.');}else if(kind._type==47){vec_u8_push(out,'[');}generate_expr(out,(*rhs),0,0,parenths+1);if(kind._type==47){vec_u8_push(out,']');}}if(parenths>0){vec_u8_push(out,')');}if(semicolon>0){vec_u8_push(out,';');}}else if(expr.kind._type==41){Expr* cond=expr.kind.u.u41.cond;Expr* valueA=expr.kind.u.u41.valueA;Expr* valueB=expr.kind.u.u41.valueB;generate_expr(out,(*cond),0,0,parenths+1);vec_u8_push(out,'?');generate_expr(out,(*valueA),0,0,parenths+1);vec_u8_push(out,':');generate_expr(out,(*valueB),0,0,parenths+1);}};uint8_t has_generics(Expr expr){if(expr.kind._type==2){vec_PathPart path=expr.kind.u.u2.path;for(int i=0;i<(path.len);i+=1){if(((((path.buf)[i]).gens).len)>0){return 1;}}}return 0;};void register_path_use(Expr expr){uint8_t* name=mangle(expr,0,0);for(int i=0;i<(gen_types.len);i+=1){GenericType gen=(gen_types.buf)[i];if((gen.name)==name){if(expr.kind._type==2){vec_PathPart path=expr.kind.u.u2.path;if((*(gen.path)).kind._type==2){vec_PathPart type_path=(*(gen.path)).kind.u.u2.path;int32_t old_gens_len=gens.len;for(int ii=0;ii<(type_path.len);ii+=1){PathPart part=(type_path.buf)[ii];for(int iii=0;iii<((part.gens).len);iii+=1){if((((part.gens).buf)[iii]).kind._type==2){vec_PathPart gen_path=(((part.gens).buf)[iii]).kind.u.u2.path;vec_GenericInstance_push((&gens),(GenericInstance){.name=gen_path.buf[0].name,.path=(&path.buf[ii].gens.buf[iii]),});}}}generate_expr((void*)0,(*(gen._type)),0,0,0);(gens.len)=old_gens_len;}}return;}}};Expr apply_genenerics(Expr expr){if(expr.kind._type==2){vec_PathPart path=expr.kind.u.u2.path;if((path.len)==1){for(int i=0;i<(gens.len);i+=1){if(strcmp(((gens.buf)[i]).name,((path.buf)[0]).name)==0){return (*(((gens.buf)[i]).path));}}}PathPart* new_path=malloc((path.len)*sizeof(PathPart));for(int i=0;i<(path.len);i+=1){PathPart part=(path.buf)[i];((new_path[i]).name)=(part.name);((new_path[i]).gens)=vec_Expr_new((part.gens).len);(((new_path[i]).gens).len)=((part.gens).len);for(int ii=0;ii<((part.gens).len);ii+=1){((((new_path[i]).gens).buf)[ii])=apply_genenerics(((part.gens).buf)[ii]);}}(((((expr.kind).u).u2).path).buf)=new_path;}return expr;};int32_t get_token_length(TokenKind kind){if(kind._type==7){return 4;}else if(kind._type==8){return 5;}else if(kind._type==9){return 4;}else if(kind._type==10){return 4;}else if(kind._type==11){return 3;}else if(kind._type==12){return 3;}else if(kind._type==13){return 3;}else if(kind._type==14){return 4;}else if(kind._type==15){return 4;}else if(kind._type==16){return 4;}else if(kind._type==17){return 3;}else if(kind._type==18){return 3;}else if(kind._type==19){return 3;}else if(kind._type==20){return 5;}else if(kind._type==21){return 2;}else if(kind._type==22){return 4;}else if(kind._type==23){return 4;}else if(kind._type==24){return 4;}else if(kind._type==25){return 5;}else if(kind._type==26){return 3;}else if(kind._type==27){return 4;}else if(kind._type==28){return 2;}else if(kind._type==29){return 5;}else if(kind._type==30){return 3;}else if(kind._type==31){return 4;}else if(kind._type==32){return 4;}else if(kind._type==33){return 3;}else if(kind._type==34){return 2;}else if(kind._type==35){return 3;}else if(kind._type==36){return 1;}else if(kind._type==37){return 1;}else if(kind._type==38){return 1;}else if(kind._type==39){return 1;}else if(kind._type==40){return 1;}else if(kind._type==41){return 1;}else if(kind._type==42){return 1;}else if(kind._type==43){return 1;}else if(kind._type==44){return 1;}else if(kind._type==45){return 1;}else if(kind._type==46){return 1;}else if(kind._type==47){return 1;}else if(kind._type==48){return 1;}else if(kind._type==49){return 1;}else if(kind._type==50){return 1;}else if(kind._type==51){return 1;}else if(kind._type==52){return 2;}else if(kind._type==53){return 1;}else if(kind._type==54){return 2;}else if(kind._type==55){return 1;}else if(kind._type==56){return 1;}else if(kind._type==57){return 1;}else if(kind._type==58){return 2;}else if(kind._type==59){return 1;}else if(kind._type==60){return 2;}else if(kind._type==61){return 1;}else if(kind._type==62){return 2;}else if(kind._type==63){return 1;}else if(kind._type==64){return 2;}else if(kind._type==65){return 1;}else if(kind._type==66){return 2;}else if(kind._type==67){return 1;}else if(kind._type==68){return 2;}else if(kind._type==69){return 1;}else if(kind._type==70){return 2;}};uint8_t* get_token_name(TokenKind kind){if(kind._type==1){return "EMPTY";}else if(kind._type==2){return "IDENT";}else if(kind._type==3){return "STRING_LIT";}else if(kind._type==4){return "CHAR_LIT";}else if(kind._type==5){return "INT_LIT";}else if(kind._type==6){return "FLOAT_LIT";}else if(kind._type==7){return "TRUE";}else if(kind._type==8){return "FALSE";}else if(kind._type==9){return "THIS";}else if(kind._type==10){return "TYPE";}else if(kind._type==11){return "TAG";}else if(kind._type==12){return "MOD";}else if(kind._type==13){return "USE";}else if(kind._type==14){return "COMP";}else if(kind._type==15){return "ENUM";}else if(kind._type==16){return "PROP";}else if(kind._type==17){return "DEF";}else if(kind._type==18){return "SUB";}else if(kind._type==19){return "VAR";}else if(kind._type==20){return "WHERE";}else if(kind._type==21){return "IF";}else if(kind._type==22){return "ELIF";}else if(kind._type==23){return "ELSE";}else if(kind._type==24){return "LOOP";}else if(kind._type==25){return "WHILE";}else if(kind._type==26){return "FOR";}else if(kind._type==27){return "EACH";}else if(kind._type==28){return "IN";}else if(kind._type==29){return "MATCH";}else if(kind._type==30){return "RET";}else if(kind._type==31){return "NEXT";}else if(kind._type==32){return "JUMP";}else if(kind._type==33){return "TRY";}else if(kind._type==34){return "AS";}else if(kind._type==35){return "HAS";}else if(kind._type==36){return "SEMICOLON";}else if(kind._type==37){return "COLON";}else if(kind._type==38){return "COMMA";}else if(kind._type==39){return "DOT";}else if(kind._type==40){return "QUESTION_MARK";}else if(kind._type==41){return "TILDE";}else if(kind._type==42){return "HASH";}else if(kind._type==43){return "LEFT_PAREN";}else if(kind._type==44){return "RIGHT_PAREN";}else if(kind._type==45){return "LEFT_BRACE";}else if(kind._type==46){return "RIGHT_BRACE";}else if(kind._type==47){return "LEFT_BRACKET";}else if(kind._type==48){return "RIGHT_BRACKET";}else if(kind._type==49){return "DEREF";}else if(kind._type==50){return "ADDRESS";}else if(kind._type==51){return "ASSIGN";}else if(kind._type==52){return "EQUAL";}else if(kind._type==53){return "NOT";}else if(kind._type==54){return "NOT_EQUAL";}else if(kind._type==55){return "AND";}else if(kind._type==56){return "OR";}else if(kind._type==57){return "LESS";}else if(kind._type==58){return "LESS_EQUAL";}else if(kind._type==59){return "GREATER";}else if(kind._type==60){return "GREATER_EQUAL";}else if(kind._type==61){return "ADD";}else if(kind._type==62){return "ADD_ASSIGN";}else if(kind._type==63){return "SUBTRACT";}else if(kind._type==64){return "SUBTRACT_ASSIGN";}else if(kind._type==65){return "MULTIPLY";}else if(kind._type==66){return "MULTIPLY_ASSIGN";}else if(kind._type==67){return "DIVIDE";}else if(kind._type==68){return "DIVIDE_ASSIGN";}else if(kind._type==69){return "MODULO";}else if(kind._type==70){return "MODULO_ASSIGN";}};void add_to_value(File file,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal){if((is_literal==2)&&(((*value).len)==4)){throw(file,i,"too many characters in character literal");}push_char(value,c);};TokenKind get_keyword(uint8_t* value){if(strcmp(value,"tag")==0){return (TokenKind){11};} else if(strcmp(value,"mod")==0){return (TokenKind){12};} else if(strcmp(value,"use")==0){return (TokenKind){13};} else if(strcmp(value,"comp")==0){return (TokenKind){14};} else if(strcmp(value,"enum")==0){return (TokenKind){15};} else if(strcmp(value,"prop")==0){return (TokenKind){16};} else if(strcmp(value,"def")==0){return (TokenKind){17};} else if(strcmp(value,"sub")==0){return (TokenKind){18};} else if(strcmp(value,"var")==0){return (TokenKind){19};} else if(strcmp(value,"this")==0){return (TokenKind){9};} else if(strcmp(value,"type")==0){return (TokenKind){10};} else if(strcmp(value,"where")==0){return (TokenKind){20};} else if(strcmp(value,"true")==0){return (TokenKind){7};} else if(strcmp(value,"false")==0){return (TokenKind){8};} else if(strcmp(value,"if")==0){return (TokenKind){21};} else if(strcmp(value,"elif")==0){return (TokenKind){22};} else if(strcmp(value,"else")==0){return (TokenKind){23};} else if(strcmp(value,"loop")==0){return (TokenKind){24};} else if(strcmp(value,"while")==0){return (TokenKind){25};} else if(strcmp(value,"for")==0){return (TokenKind){26};} else if(strcmp(value,"each")==0){return (TokenKind){27};} else if(strcmp(value,"in")==0){return (TokenKind){28};} else if(strcmp(value,"match")==0){return (TokenKind){29};} else if(strcmp(value,"ret")==0){return (TokenKind){30};} else if(strcmp(value,"next")==0){return (TokenKind){31};} else if(strcmp(value,"jump")==0){return (TokenKind){32};} else if(strcmp(value,"try")==0){return (TokenKind){33};} else if(strcmp(value,"as")==0){return (TokenKind){34};} else if(strcmp(value,"has")==0){return (TokenKind){35};}return (TokenKind){1};};uint8_t is_binary_operator(TokenKind kind){if(kind._type==43){return 1;}else if(kind._type==51){return 1;}else if(kind._type==52){return 1;}else if(kind._type==54){return 1;}else if(kind._type==55){return 1;}else if(kind._type==56){return 1;}else if(kind._type==57){return 1;}else if(kind._type==58){return 1;}else if(kind._type==59){return 1;}else if(kind._type==60){return 1;}else if(kind._type==61){return 1;}else if(kind._type==62){return 1;}else if(kind._type==63){return 1;}else if(kind._type==64){return 1;}else if(kind._type==65){return 1;}else if(kind._type==66){return 1;}else if(kind._type==67){return 1;}else if(kind._type==68){return 1;}else if(kind._type==69){return 1;}else if(kind._type==70){return 1;}else if(kind._type==34){return 1;}else if(kind._type==35){return 1;}else{return 0;}};vec_Token lex(File file){vec_Token tokens=vec_Token_new(32);uint8_t is_comment=0;uint8_t is_literal=0;vec_u8 value=vec_u8_new(8);vec_u8_empty((&value));for(int i=0;i<=((file.data).len);i+=1){uint8_t c=((file.data).buf)[i];if(((((is_literal!=1)&&(is_literal!=2))&&(is_literal!=3))&&(is_literal!=4))&&(c=='`')){is_comment=1;goto l;}if(is_comment!=0){if(c=='\n'){is_comment=0;}goto l;}TokenKind kind=(TokenKind){0};if((is_literal==3)||(is_literal==4)){is_literal-=2;}if((is_literal==1)||(is_literal==2)){if(c==0){if(is_literal==1){throw(file,i-1,"expected end of string literal");} else{throw(file,i-1,"expected end of char literal");}} else if((is_literal==1)&&(c=='"')){} else if((is_literal==2)&&(c==39)){} else{add_to_value(file,(&value),i,c,is_literal);goto l;}}if((c==0)||isspace(c)){kind=(TokenKind){1};} else{if(c=='"'){if(is_literal==1){kind=(TokenKind){3};is_literal=0;} else{kind=(TokenKind){1};is_literal=3;}} else if(c==39){if(is_literal==2){kind=(TokenKind){4};is_literal=0;} else{kind=(TokenKind){1};is_literal=4;}} else if(c==';'){kind=(TokenKind){36};} else if(c==':'){kind=(TokenKind){37};} else if(c==','){kind=(TokenKind){38};} else if(c=='.'){uint8_t n=((file.data).buf)[(i+1)];if((is_literal!=5)||((n=='_')||isalpha(n))){kind=(TokenKind){39};}} else if(c=='?'){kind=(TokenKind){40};} else if(c=='~'){kind=(TokenKind){41};} else if(c=='#'){kind=(TokenKind){42};} else if(c=='('){kind=(TokenKind){43};} else if(c==')'){kind=(TokenKind){44};} else if(c=='{'){kind=(TokenKind){45};} else if(c=='}'){kind=(TokenKind){46};} else if(c=='['){kind=(TokenKind){47};} else if(c==']'){kind=(TokenKind){48};} else if(c=='@'){kind=(TokenKind){49};} else if(c=='$'){kind=(TokenKind){50};} else if(c=='&'){kind=(TokenKind){55};} else if(c=='|'){kind=(TokenKind){56};} else if(c=='='){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){52};i+=1;} else{kind=(TokenKind){51};}} else if(c=='!'){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){54};i+=1;} else{kind=(TokenKind){53};}} else if(c=='<'){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){58};i+=1;} else{kind=(TokenKind){57};}} else if(c=='>'){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){60};i+=1;} else{kind=(TokenKind){59};}} else if(c=='+'){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){62};i+=1;} else{kind=(TokenKind){61};}} else if(c=='-'){if(is_binary_operator(((tokens.buf)[((tokens.len)-1)]).kind)&&isdigit(((file.data).buf)[(i+1)])){goto brk_ll;}if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){64};i+=1;} else{kind=(TokenKind){63};}} else if(c=='*'){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){66};i+=1;} else{kind=(TokenKind){65};}} else if(c=='/'){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){68};i+=1;} else{kind=(TokenKind){67};}} else if(c=='%'){if(((i+1)<((file.data).len))&&((((file.data).buf)[(i+1)])=='=')){kind=(TokenKind){70};i+=1;} else{kind=(TokenKind){69};}}}brk_ll:if(kind._type==0){if(((((c=='-')||(c=='_'))||(c=='.'))||(c==':'))||isalnum(c)){if((((value.len)==0)&&isdigit(c))||(c=='-')){is_literal=5;} else if((is_literal==5)||(is_literal==6)){if((c=='.')&&(is_literal==5)){is_literal=6;} else if((c=='_')||isdigit(c)){} else{throw(file,i-(value.len),"invalid identifier name starting with a digit");}}if(((is_literal!=5)&&(is_literal!=6))||(c!='_')){add_to_value(file,(&value),i,c,is_literal);}} else{throw(file,i,"unexpected symbol %c",c);}}else{if((value.len)>0){if(kind._type==3){}else if(kind._type==4){}else{TokenKind value_kind=get_keyword(value.buf);if(value_kind._type==1){Token token;if(is_literal==5){(token.kind)=(TokenKind){5};} else if(is_literal==6){(token.kind)=(TokenKind){6};if(((value.buf)[((value.len)-1)])=='.'){throw(file,i-1,"expected a value after the decimal point");}} else{(token.kind)=(TokenKind){2};}(token.index)=(i-(value.len));(token.value)=(value.buf);vec_Token_push((&tokens),token);}else{Token token=(Token){.kind=value_kind,.index=i-get_token_length(value_kind),};vec_Token_push((&tokens),token);}value=vec_u8_new(8);vec_u8_empty((&value));is_literal=0;}}if(kind._type==1){}else{Token token=(Token){.kind=kind,};if(kind._type==3){(token.value)=(value.buf);(token.index)=(i-(value.len));value=vec_u8_new(8);vec_u8_empty((&value));}else if(kind._type==4){(token.value)=(value.buf);(token.index)=(i-(value.len));value=vec_u8_new(8);vec_u8_empty((&value));}else{(token.index)=((i-get_token_length(kind))+1);}vec_Token_push((&tokens),token);}}l:}brk_l:Token last;if((tokens.len)>0){last=((tokens.buf)[((tokens.len)-1)]);if(last.kind._type==2){(last.index)=((last.index)+strlen(last.value));}else{(last.index)=((last.index)+get_token_length(last.kind));}} else{(last.index)=0;}(last.kind)=(TokenKind){1};vec_Token_push((&tokens),last);return tokens;};void print_tokens(vec_Token tokens){printf("Tokens:\n");for(int i=0;i<(tokens.len);i+=1){TokenKind kind=((tokens.buf)[i]).kind;set_color((Color){1});printf("  %s",get_token_name(kind));set_color((Color){0});if(kind._type==2){printf("(%s)",((tokens.buf)[i]).value);}else if(kind._type==3){printf("(%s)",((tokens.buf)[i]).value);}else if(kind._type==4){printf("(%s)",((tokens.buf)[i]).value);}else if(kind._type==5){printf("(%s)",((tokens.buf)[i]).value);}else if(kind._type==6){printf("(%s)",((tokens.buf)[i]).value);}putchar('\n');}putchar('\n');};int32_t main(int32_t argc,uint8_t** argv){Command command=get_command(argc,argv);if(command._type==0){set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such command: '%s",argv[1]);for(int i=2;i<argc;i+=1){printf(" %s",argv[i]);}printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;}else if(command._type==14){goto brk_m;}else if(command._type==15){goto brk_m;}else if(command._type==16){return 1;}else if(command._type==17){return 1;}else if(command._type==18){return 1;}else if(command._type==19){return 1;}else if(command._type==20){return 1;}else if(command._type==21){return 1;}else if(command._type==22){return 1;}else if(command._type==23){return 1;}else if(command._type==24){return 1;}else if(command._type==25){return 1;}else if(command._type==1){printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;}else if(command._type==2){command_help("run","Compile and run the current package",command_options_compile);return 0;}else if(command._type==3){command_help("build","Compile the current package",command_options_compile);return 0;}else if(command._type==4){command_help("check","Analyze the current package",command_options_empty);return 0;}else if(command._type==5){command_help("new","Create a new package",command_options_empty);return 0;}else if(command._type==6){command_help("update","Update given dependency",command_options_empty);return 0;}else if(command._type==7){command_help("add","Adds given dependency",command_options_empty);return 0;}else if(command._type==8){command_help("remove","Removes given dependency",command_options_empty);return 0;}else if(command._type==9){command_help("gen docs","Generate documentation for the current package",command_options_empty);return 0;}else if(command._type==10){command_help("gen binds","Generate bindings for a given C header file",command_options_empty);return 0;}else if(command._type==11){command_help("self update","Update the Cup Toolkit",command_options_empty);return 0;}else if(command._type==12){command_help("self install","Install the Cup Toolkit",command_options_empty);return 0;}else if(command._type==13){command_help("self uninstall","Uninstall the Cup Toolkite",command_options_empty);return 0;}brk_m:uint8_t* input=(void*)0;uint8_t* output=(void*)0;for(int i=2;i<argc;i+=1){if(((argv[i])[0])=='-'){if(((argv[i])[1])=='i'){if(input==(void*)0){input=get_option((&i),argc,argv);}} else if(((argv[i])[1])=='o'){if(output==(void*)0){output=get_option((&i),argc,argv);}}} else{set_color((Color){3});printf("error: ");set_color((Color){0});printf("invalid option '%s'",argv[i]);}}if(input==(void*)0){input=".";}if(output==(void*)0){output="out.c";}vec_Expr ast=vec_Expr_new(8);lex_parse_recursive(input,(&ast));analyze(ast);uint8_t* out=generate(ast);FILE* file_point=fopen(output,"w");fprintf(file_point,"%s",out);free(out);printf("Compilation ");set_color((Color){2});printf("successful");set_color((Color){0});printf(" (%.1lfs elapsed)\n",((double)clock())/CLOCKS_PER_SEC);return 0;};uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv){if(strlen(argv[(*index)])>2){return (argv[(*index)])+1;} else if(argc>(*index)){return argv[((*index)+=1)];}return (void*)0;};void set_color(Color color){if(color._type==0){printf("\033[0m");}else if(color._type==1){printf("\033[35m");}else if(color._type==2){printf("\033[32m");}else if(color._type==3){printf("\033[0;31m");}};void lex_parse_recursive(uint8_t* path,vec_Expr* ast){DIR* dir=opendir(path);if(dir==(void*)0){set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such file or directory: '%s'\n",path);exit(1);}dirent* ent;while((ent=readdir(dir))!=(void*)0){int32_t new_length=strlen((*ent).d_name);if((new_length==1)&&((((*ent).d_name)[0])=='.')){} else if(((new_length==2)&&((((*ent).d_name)[0])=='.'))&&((((*ent).d_name)[1])=='.')){} else{int32_t length=strlen(path);uint8_t* new_path=malloc(((length+1)+new_length)+1);memcpy(new_path,path,length);(new_path[length])='/';memcpy((new_path+length)+1,(*ent).d_name,new_length);(new_path[((length+new_length)+1)])='\0';if(((*ent).d_type)==DT_DIR){lex_parse_recursive(new_path,ast);} else if(((*ent).d_type)==DT_REG){FILE* file_point=fopen(new_path,"r");fseek(file_point,(int32_t)0,SEEK_END);arr_u8 data=arr_u8_new(ftell(file_point)+1);rewind(file_point);(data.len)-=1;fread(data.buf,data.len,1,file_point);((data.buf)[(data.len)])='\0';fclose(file_point);printf("Compiling %s:\n",new_path);File file=(File){.name=new_path,.data=data,};vec_Token tokens=lex(file);vec_Expr exprs=parse(file,tokens);vec_Expr_push(ast,(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=4,.u={.u4={.body=exprs,}}},});free(data.buf);free(tokens.buf);}free(new_path);}}closedir(dir);};void REMOVE_ME(){vec_VarName_new(0);};vec_Expr parse(File file,vec_Token tokens){int32_t index=0;vec_Expr exprs=vec_Expr_new(16);for(;;) {if(((tokens.buf)[index]).kind._type==1){return exprs;}vec_Expr_push((&exprs),parse_global(file,tokens,(&index)));if(((tokens.buf)[index]).kind._type==36){}else if(((tokens.buf)[index]).kind._type==1){return exprs;}else{throw(file,((tokens.buf)[index]).index,"unexpected token after last expr");}index+=1;}};vec_Expr parse_block(File file,vec_Token tokens,int32_t* index,uint8_t local){vec_Expr exprs=vec_Expr_new(4);for(;;) {if(((tokens.buf)[(*index)]).kind._type==46){(*index)+=1;return exprs;}Expr expr;if(local){expr=parse_local(file,tokens,index,0,0);} else{expr=parse_global(file,tokens,index);}vec_Expr_push((&exprs),expr);if(((tokens.buf)[(*index)]).kind._type==36){}else if(((tokens.buf)[(*index)]).kind._type==46){(*index)+=1;return exprs;}else{throw(file,((tokens.buf)[(*index)]).index,"unexpected token after last expr");}(*index)+=1;}};Token expect_token(File file,vec_Token tokens,int32_t* index,TokenKind kind,uint8_t* error){Token token=(tokens.buf)[(*index)];if(token.kind._type==0){}else if(token.kind._type==kind._type){}else{throw(file,token.index,error);}(*index)+=1;return token;};uint8_t opt_token(vec_Token tokens,int32_t* index,TokenKind kind){if(((tokens.buf)[(*index)]).kind._type==0){}else if(((tokens.buf)[(*index)]).kind._type==kind._type){(*index)+=1;return 1;}else{return 0;}};Expr parse_local(File file,vec_Token tokens,int32_t* index,int32_t op_level,uint8_t opt){Expr expr;(expr.label)=parse_label(file,tokens,index,1);(expr.tags)=parse_tags(file,tokens,index);Token token=(tokens.buf)[(*index)];if(token.kind._type==43){(*index)+=1;expr=parse_local(file,tokens,index,0,0);expect_token(file,tokens,index,(TokenKind){44},"expected ')' after '('");}else if(token.kind._type==2){Expr* path=alloc_Expr(parse_path(file,tokens,index));if(opt_token(tokens,index,(TokenKind){43})){vec_Expr args=vec_Expr_new(2);for(;;) {if(opt_token(tokens,index,(TokenKind){44})){goto brk_ll;}vec_Expr_push((&args),parse_local(file,tokens,index,0,0));if(opt_token(tokens,index,(TokenKind){38})==0){expect_token(file,tokens,index,(TokenKind){44},"expected ')' after last argument");goto brk_ll;}ll:}brk_ll:(expr.kind)=(ExprKind){._type=16,.u={.u16={.path=path,.args=args,}}};goto brk_l;}if(opt_token(tokens,index,(TokenKind){2})){uint8_t* name=((tokens.buf)[((*index)-1)]).value;Expr* value=(void*)0;if(opt_token(tokens,index,(TokenKind){51})){value=alloc_Expr(parse_local(file,tokens,index,0,0));}(expr.kind)=(ExprKind){._type=15,.u={.u15={._type=path,.name=name,.value=value,}}};goto brk_l;}(expr.kind)=(ExprKind){._type=17,.u={.u17={.path=path,}}};}else if(token.kind._type==19){(*index)+=1;uint8_t* name=expect_token(file,tokens,index,(TokenKind){2},"expected identifier after 'var' keyword").value;Expr* value=(void*)0;if(opt_token(tokens,index,(TokenKind){51})){value=alloc_Expr(parse_local(file,tokens,index,0,0));}(expr.kind)=(ExprKind){._type=15,.u={.u15={._type=(void*)0,.name=name,.value=value,}}};}else if(token.kind._type==3){(expr.kind)=(ExprKind){._type=18,.u={.u18={.value=token.value,}}};(*index)+=1;}else if(token.kind._type==4){(expr.kind)=(ExprKind){._type=19,.u={.u19={.value=token.value,}}};(*index)+=1;}else if(token.kind._type==5){(expr.kind)=(ExprKind){._type=20,.u={.u20={.value=token.value,}}};(*index)+=1;}else if(token.kind._type==6){(expr.kind)=(ExprKind){._type=21,.u={.u21={.value=token.value,}}};(*index)+=1;}else if(token.kind._type==7){(expr.kind)=(ExprKind){._type=22,.u={.u22={.value=1,}}};(*index)+=1;}else if(token.kind._type==8){(expr.kind)=(ExprKind){._type=22,.u={.u22={.value=0,}}};(*index)+=1;}else if(token.kind._type==9){(expr.kind)=(ExprKind){23};(*index)+=1;}else if(token.kind._type==10){(expr.kind)=(ExprKind){24};(*index)+=1;}else if(token.kind._type==45){(*index)+=1;vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){._type=25,.u={.u25={.body=body,}}};}else if(token.kind._type==21){(*index)+=1;Expr* cond=alloc_Expr(parse_local(file,tokens,index,0,0));expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'if' condition");vec_Expr body=parse_block(file,tokens,index,1);Expr* _if=alloc_Expr((Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=27,.u={.u27={.cond=cond,.body=body,}}},});vec_Expr _elif=vec_Expr_new(1);while(opt_token(tokens,index,(TokenKind){22})){cond=alloc_Expr(parse_local(file,tokens,index,0,0));expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'elif' condition");vec_Expr body=parse_block(file,tokens,index,1);vec_Expr_push((&_elif),(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=27,.u={.u27={.cond=cond,.body=body,}}},});}if(opt_token(tokens,index,(TokenKind){23})){expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'else' keyword");vec_Expr body=parse_block(file,tokens,index,1);vec_Expr_push((&_elif),(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=28,.u={.u28={.body=body,}}},});}(expr.kind)=(ExprKind){._type=26,.u={.u26={._if=_if,._elif=_elif,._else=(void*)0,}}};}else if(token.kind._type==24){(*index)+=1;expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'loop' keyword");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){._type=29,.u={.u29={.body=body,}}};}else if(token.kind._type==25){(*index)+=1;Expr* cond=alloc_Expr(parse_local(file,tokens,index,0,0));expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'while' condition");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){._type=30,.u={.u30={.cond=cond,.body=body,}}};}else if(token.kind._type==26){(*index)+=1;uint8_t* iter=expect_token(file,tokens,index,(TokenKind){2},"expected 'for' iterator name").value;Expr* iter_value=(void*)0;if(opt_token(tokens,index,(TokenKind){51})){iter_value=alloc_Expr(parse_local(file,tokens,index,0,0));}expect_token(file,tokens,index,(TokenKind){38},"expected a ',' after 'for' iterator name");Expr* cond=alloc_Expr(parse_local(file,tokens,index,0,0));expect_token(file,tokens,index,(TokenKind){38},"expected a ',' after 'for' condition");Expr* _next=alloc_Expr(parse_local(file,tokens,index,0,0));expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'for' next");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){._type=31,.u={.u31={.iter=iter,.iter_value=iter_value,.cond=cond,._next=_next,.body=body,}}};}else if(token.kind._type==27){(*index)+=1;vec_VarName vars=vec_VarName_new(2);while(opt_token(tokens,index,(TokenKind){2})){vec_VarName_push((&vars),(VarName){.name=tokens.buf[(*index)-1].value,});opt_token(tokens,index,(TokenKind){38});}if((vars.len)==0){throw(file,((tokens.buf)[((*index)-1)]).index,"expected sex");}expect_token(file,tokens,index,(TokenKind){28},"expected 'in' keyword after 'each' variables");Expr* iter=alloc_Expr(parse_local(file,tokens,index,0,0));expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'each' iterator");vec_Expr body=parse_block(file,tokens,index,1);(expr.kind)=(ExprKind){._type=32,.u={.u32={.vars=vars,.iter=iter,.body=body,}}};}else if(token.kind._type==29){(*index)+=1;Expr* value=alloc_Expr(parse_local(file,tokens,index,0,0));expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'match' value");vec_Expr body=vec_Expr_new(4);for(;;) {if(opt_token(tokens,index,(TokenKind){46})){(expr.kind)=(ExprKind){._type=33,.u={.u33={.value=value,.cases=body,}}};goto brk_l;}vec_Expr values=vec_Expr_new(2);for(;;) {if(opt_token(tokens,index,(TokenKind){45})){goto b;}vec_Expr_push((&values),parse_local(file,tokens,index,0,0));if(opt_token(tokens,index,(TokenKind){38})==0){goto brk_llll;}llll:}brk_llll:expect_token(file,tokens,index,(TokenKind){45},"expected '{' after 'match' case value");while(0){b:}brk_b:vec_Expr case_body=parse_block(file,tokens,index,1);vec_Expr_push((&body),(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=34,.u={.u34={.values=values,.body=case_body,}}},});if(opt_token(tokens,index,(TokenKind){38})==0){goto brk_lll;}lll:}brk_lll:expect_token(file,tokens,index,(TokenKind){46},"expected '}' after 'match' body");(expr.kind)=(ExprKind){._type=33,.u={.u33={.value=value,.cases=body,}}};}else if(token.kind._type==30){(*index)+=1;uint8_t* label=parse_label(file,tokens,index,1);Expr value=parse_local(file,tokens,index,0,1);if(value.kind._type==0){(expr.kind)=(ExprKind){._type=35,.u={.u35={.label=label,.value=(void*)0,}}};}else{(expr.kind)=(ExprKind){._type=35,.u={.u35={.label=label,.value=alloc_Expr(value),}}};}}else if(token.kind._type==31){(*index)+=1;(expr.kind)=(ExprKind){._type=36,.u={.u36={.label=parse_label(file,tokens,index,0),}}};}else if(token.kind._type==32){(*index)+=1;(expr.kind)=(ExprKind){._type=37,.u={.u37={.label=parse_label(file,tokens,index,0),}}};}else if(token.kind._type==33){(*index)+=1;uint8_t* label=parse_label(file,tokens,index,1);Expr* value=alloc_Expr(parse_local(file,tokens,index,0,0));(expr.kind)=(ExprKind){._type=38,.u={.u38={.label=label,.value=value,}}};}else{if(opt){(expr.kind)=(ExprKind){0};return expr;} else{throw(file,token.index,"expected a local expression");}}brk_l:for(;;) {int32_t new_op_level=0;token=((tokens.buf)[(*index)]);if(token.kind._type==40){(*index)+=1;Expr valueA=parse_local(file,tokens,index,0,0);expect_token(file,tokens,index,(TokenKind){38},"expected ',' after smth");Expr valueB=parse_local(file,tokens,index,0,0);expr=(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=41,.u={.u41={.cond=alloc_Expr(expr),.valueA=alloc_Expr(valueA),.valueB=alloc_Expr(valueB),}}},};goto brk_o;}else if(token.kind._type==51){new_op_level=7;}else if(token.kind._type==62){new_op_level=7;}else if(token.kind._type==64){new_op_level=7;}else if(token.kind._type==66){new_op_level=7;}else if(token.kind._type==68){new_op_level=7;}else if(token.kind._type==70){new_op_level=7;}else if(token.kind._type==34){new_op_level=6;}else if(token.kind._type==57){new_op_level=5;}else if(token.kind._type==55){new_op_level=5;}else if(token.kind._type==56){new_op_level=5;}else if(token.kind._type==58){new_op_level=5;}else if(token.kind._type==59){new_op_level=5;}else if(token.kind._type==60){new_op_level=5;}else if(token.kind._type==52){new_op_level=5;}else if(token.kind._type==54){new_op_level=5;}else if(token.kind._type==61){new_op_level=4;}else if(token.kind._type==63){new_op_level=4;}else if(token.kind._type==65){new_op_level=3;}else if(token.kind._type==67){new_op_level=3;}else if(token.kind._type==69){new_op_level=3;}else if(token.kind._type==53){new_op_level=2;}else if(token.kind._type==49){new_op_level=2;}else if(token.kind._type==50){new_op_level=2;}else if(token.kind._type==47){if(op_level==1){goto brk_o;}(*index)+=1;goto e;}else if(token.kind._type==39){new_op_level=1;}if(new_op_level==2){if((op_level==0)||(new_op_level<op_level)){(*index)+=1;expr=(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=39,.u={.u39={.value=alloc_Expr(expr),.kind=token.kind,}}},};goto o;}goto brk_o;}if((new_op_level==0)||(((op_level!=0)&&(op_level!=6))&&(new_op_level>=op_level))){goto brk_o;}(*index)+=1;while(0){e:}brk_e:expr=(Expr){.tags=(vec_Expr){.len=0,},.label=(void*)0,.kind=(ExprKind){._type=40,.u={.u40={.lhs=alloc_Expr(expr),.rhs=alloc_Expr(parse_local(file,tokens,index,new_op_level,0)),.kind=token.kind,}}},};if(token.kind._type==47){expect_token(file,tokens,index,(TokenKind){48},"expected ']' after '['");}o:}brk_o:return expr;};Expr parse_global(File file,vec_Token tokens,int32_t* index){Expr expr;(expr.label)=parse_label(file,tokens,index,1);(expr.tags)=parse_tags(file,tokens,index);Token token=(tokens.buf)[(*index)];if(token.kind._type==11){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){43},"expected '(' after 'tag' path");vec_Expr args=parse_fields(file,tokens,index);vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,1);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=3,.u={.u3={.path=path,.args=args,.body=body,}}};}else if(token.kind._type==45){(*index)+=1;(expr.kind)=(ExprKind){._type=4,.u={.u4={.body=parse_block(file,tokens,index,0),}}};}else if(token.kind._type==12){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,0);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=5,.u={.u5={.path=path,.body=body,}}};}else if(token.kind._type==13){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));(expr.kind)=(ExprKind){._type=6,.u={.u6={.path=path,}}};}else if(token.kind._type==14){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){43},"expected '(' after 'comp' path");vec_Expr fields=parse_fields(file,tokens,index);vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,0);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=8,.u={.u8={.path=path,.fields=fields,.body=body,}}};}else if(token.kind._type==15){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){43},"expected '(' after 'enum' path");vec_Expr opts=parse_options(file,tokens,index);vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,0);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=9,.u={.u9={.path=path,.opts=opts,.body=body,}}};}else if(token.kind._type==16){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,0);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=11,.u={.u11={.path=path,.body=body,}}};}else if(token.kind._type==17){(*index)+=1;Expr* _prop=alloc_Expr(parse_path(file,tokens,index));Expr* _target=(void*)0;if(opt_token(tokens,index,(TokenKind){38})){_target=alloc_Expr(parse_path(file,tokens,index));}vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,0);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=12,.u={.u12={._prop=_prop,.target=_target,.body=body,}}};}else if(token.kind._type==18){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));expect_token(file,tokens,index,(TokenKind){43},"expected '(' after 'sub' path");vec_Expr args=parse_fields(file,tokens,index);vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,1);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=13,.u={.u13={.ret_type=(void*)0,.path=path,.args=args,.body=body,}}};}else if(token.kind._type==19){(*index)+=1;Expr* path=alloc_Expr(parse_path(file,tokens,index));Expr* value=(void*)0;if(opt_token(tokens,index,(TokenKind){51})){(*index)+=1;value=alloc_Expr(parse_local(file,tokens,index,0,0));}(expr.kind)=(ExprKind){._type=14,.u={.u14={._type=(void*)0,.path=path,.value=value,}}};}else if(token.kind._type==2){Expr* _type=alloc_Expr(parse_path(file,tokens,index));Expr* path=alloc_Expr(parse_path(file,tokens,index));token=((tokens.buf)[(*index)]);if(token.kind._type==43){(*index)+=1;vec_Expr args=parse_fields(file,tokens,index);vec_Expr body;if(opt_token(tokens,index,(TokenKind){45})){body=parse_block(file,tokens,index,1);} else{(body.len)=0;}(expr.kind)=(ExprKind){._type=13,.u={.u13={.ret_type=_type,.path=path,.args=args,.body=body,}}};}else{Expr* value=(void*)0;if(opt_token(tokens,index,(TokenKind){51})){(*index)+=1;value=alloc_Expr(parse_local(file,tokens,index,0,0));}(expr.kind)=(ExprKind){._type=14,.u={.u14={._type=_type,.path=path,.value=value,}}};}}else{throw(file,token.index,"expected a global expression");}return expr;};uint8_t* parse_label(File file,vec_Token tokens,int32_t* index,uint8_t opt){if(opt&&(opt_token(tokens,index,(TokenKind){41})==0)){return (void*)0;} else if(opt==0){expect_token(file,tokens,index,(TokenKind){41},"expected a label");}uint8_t* label=expect_token(file,tokens,index,(TokenKind){2},"expected identifier after label declaration").value;return label;};vec_Expr parse_tags(File file,vec_Token tokens,int32_t* index){vec_Expr tags=vec_Expr_new(2);for(;;) {if(((tokens.buf)[(*index)]).kind._type==42){Token token=(tokens.buf)[((*index)+=1)];if(token.kind._type==2){uint8_t* name=token.value;vec_Expr args=vec_Expr_new(1);token=((tokens.buf)[((*index)+=1)]);if(token.kind._type==43){(*index)+=1;for(;;) {token=((tokens.buf)[(*index)]);if(opt_token(tokens,index,(TokenKind){44})){goto brk_ll;}vec_Expr_push((&args),parse_local(file,tokens,index,0,0));if(opt_token(tokens,index,(TokenKind){38})){goto ll;} else{expect_token(file,tokens,index,(TokenKind){44},"expected ')' after last tag arg");goto brk_ll;}ll:}brk_ll:}vec_Expr_push((&tags),(Expr){.kind=(ExprKind){._type=1,.u={.u1={.name=name,.args=args,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,});goto l;}else{throw(file,token.index,"expected identifier after tag declaration");}}else{goto brk_l;}l:}brk_l:return tags;};Expr parse_path(File file,vec_Token tokens,int32_t* index){if(((tokens.buf)[(*index)]).kind._type==2){return parse_opt_path(file,tokens,index);}else{throw(file,((tokens.buf)[(*index)]).index,"expected a path");}};Expr parse_opt_path(File file,vec_Token tokens,int32_t* index){vec_PathPart path=vec_PathPart_new(2);uint8_t need_colon=0;for(;;) {Token token=(tokens.buf)[(*index)];if(need_colon){if(token.kind._type==37){need_colon=0;}else{goto brk_l;}} else{if(token.kind._type==2){PathPart part=(PathPart){.name=token.value,.gens=vec_Expr_new(2),};if(((tokens.buf)[((*index)+1)]).kind._type==57){int32_t old_index=(*index);(*index)+=2;for(;;) {token=((tokens.buf)[(*index)]);if(token.kind._type==59){goto brk_ll;}else{}Expr gen=parse_opt_path(file,tokens,index);if(gen.kind._type==2){vec_PathPart gen_path=gen.kind.u.u2.path;if((gen_path.len)==0){(*index)=old_index;goto brk_ll;}}vec_Expr_push((&(part.gens)),gen);opt_token(tokens,index,(TokenKind){38});ll:}brk_ll:}vec_PathPart_push((&path),part);need_colon=1;}else{if((path.len)>0){throw(file,token.index,"expected identifier after ':'");} else{goto brk_l;}}}(*index)+=1;l:}brk_l:return (Expr){.kind=(ExprKind){._type=2,.u={.u2={.path=path,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,};};vec_Expr parse_fields(File file,vec_Token tokens,int32_t* index){vec_Expr fields=vec_Expr_new(2);for(;;) {if(opt_token(tokens,index,(TokenKind){44})){return fields;}Expr field=(Expr){.kind=(ExprKind){._type=7,.u={.u7={._type=alloc_Expr(parse_path(file,tokens,index)),.name=expect_token(file,tokens,index,(TokenKind){2},"expected field name in 'comp' definition").value,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,};vec_Expr_push((&fields),field);if(opt_token(tokens,index,(TokenKind){38})==0){goto brk_l;}l:}brk_l:expect_token(file,tokens,index,(TokenKind){44},"expected ')' after last field");return fields;};vec_Expr parse_options(File file,vec_Token tokens,int32_t* index){vec_Expr opts=vec_Expr_new(2);for(;;) {if(opt_token(tokens,index,(TokenKind){44})){return opts;}uint8_t* name=expect_token(file,tokens,index,(TokenKind){2},"expected option name in 'enum' definition").value;vec_Expr fields;if(opt_token(tokens,index,(TokenKind){43})){fields=parse_fields(file,tokens,index);} else{(fields.len)=0;}vec_Expr_push((&opts),(Expr){.kind=(ExprKind){._type=10,.u={.u10={.name=name,.fields=fields,}}},.tags=(vec_Expr){.len=0,},.label=(void*)0,});if(opt_token(tokens,index,(TokenKind){38})==0){goto brk_l;}l:}brk_l:expect_token(file,tokens,index,(TokenKind){44},"expected ')' after last option");return opts;};void print_exprs(vec_Expr exprs){printf("Exprs:");print_expr_vec(exprs,0);putchar('\n');};void print_expr_vec(vec_Expr exprs,int32_t depth){for(int i=0;i<(exprs.len);i+=1){putchar('\n');indent(depth);print_expr((exprs.buf)[i],depth);}putchar('\n');};void print_opt_expr_vec(vec_Expr exprs,int32_t depth,uint8_t* name,uint8_t _next){if((exprs.len)>0){if(_next){printf(", ");}printf("%s = [",name);print_expr_vec(exprs,depth+1);indent(depth);putchar(']');}};void print_expr(Expr expr,int32_t depth){set_color((Color){2});printf("%s",get_expr_name(expr.kind));set_color((Color){0});putchar('(');if((expr.label)!=(void*)0){printf("label = %s, ",expr.label);}print_opt_expr_vec(expr.tags,depth,"tags",0);if(((expr.tags).len)!=0){printf(", ");}if(expr.kind._type==1){uint8_t* name=expr.kind.u.u1.name;vec_Expr args=expr.kind.u.u1.args;printf("name = %s",name);print_opt_expr_vec(args,depth,"args",1);}else if(expr.kind._type==2){vec_PathPart path=expr.kind.u.u2.path;for(int i=0;i<(path.len);i+=1){PathPart part=(path.buf)[i];if(i!=0){printf(", ");}printf("name = %s",part.name);print_opt_expr_vec(part.gens,depth,"gens",1);}}else if(expr.kind._type==3){Expr* path=expr.kind.u.u3.path;vec_Expr args=expr.kind.u.u3.args;vec_Expr body=expr.kind.u.u3.body;print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==4){vec_Expr body=expr.kind.u.u4.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind._type==5){Expr* path=expr.kind.u.u5.path;vec_Expr body=expr.kind.u.u5.body;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind._type==6){Expr* path=expr.kind.u.u6.path;printf("path = ");print_expr((*path),depth);}else if(expr.kind._type==7){Expr* _type=expr.kind.u.u7._type;uint8_t* name=expr.kind.u.u7.name;printf("type = ");print_expr((*_type),depth);printf(", name = %s",name);}else if(expr.kind._type==8){Expr* path=expr.kind.u.u8.path;vec_Expr fields=expr.kind.u.u8.fields;vec_Expr body=expr.kind.u.u8.body;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(fields,depth,"fields",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==9){Expr* path=expr.kind.u.u9.path;vec_Expr opts=expr.kind.u.u9.opts;vec_Expr body=expr.kind.u.u9.body;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(opts,depth,"opts",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==10){uint8_t* name=expr.kind.u.u10.name;vec_Expr fields=expr.kind.u.u10.fields;printf("name = %s",name);print_opt_expr_vec(fields,depth,"fields",1);}else if(expr.kind._type==11){Expr* path=expr.kind.u.u11.path;vec_Expr body=expr.kind.u.u11.body;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==12){Expr* _prop=expr.kind.u.u12._prop;Expr* target=expr.kind.u.u12.target;vec_Expr body=expr.kind.u.u12.body;printf("prop = ");print_expr((*_prop),depth);if(target!=(void*)0){printf(", target = ");print_expr((*target),depth);}print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==13){Expr* ret_type=expr.kind.u.u13.ret_type;Expr* path=expr.kind.u.u13.path;vec_Expr args=expr.kind.u.u13.args;vec_Expr body=expr.kind.u.u13.body;if(ret_type!=(void*)0){printf("ret_type = ");print_expr((*ret_type),depth);printf(", ");}printf("path = ");print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==14){Expr* _type=expr.kind.u.u14._type;Expr* path=expr.kind.u.u14.path;Expr* value=expr.kind.u.u14.value;if(_type!=(void*)0){printf("type = ");print_expr((*_type),depth);printf(", ");}printf("path = ");print_expr((*path),depth);if(value!=(void*)0){printf(", value = ");print_expr((*value),depth);}}else if(expr.kind._type==15){Expr* _type=expr.kind.u.u15._type;uint8_t* name=expr.kind.u.u15.name;Expr* value=expr.kind.u.u15.value;if(_type!=(void*)0){printf("type = ");print_expr((*_type),depth);printf(", ");}printf("name = %s",name);if(value!=(void*)0){printf(", value = ");print_expr((*value),depth);}}else if(expr.kind._type==16){Expr* path=expr.kind.u.u16.path;vec_Expr args=expr.kind.u.u16.args;printf("path = ");print_expr((*path),depth);print_opt_expr_vec(args,depth,"args",1);}else if(expr.kind._type==17){Expr* path=expr.kind.u.u17.path;printf("path = ");print_expr((*path),depth);}else if(expr.kind._type==18){uint8_t* value=expr.kind.u.u18.value;printf("%s",value);}else if(expr.kind._type==19){uint8_t* value=expr.kind.u.u19.value;printf("%s",value);}else if(expr.kind._type==20){uint8_t* value=expr.kind.u.u20.value;printf("%s",value);}else if(expr.kind._type==21){uint8_t* value=expr.kind.u.u21.value;printf("%s",value);}else if(expr.kind._type==22){uint8_t value=expr.kind.u.u22.value;if(value){printf("true");} else{printf("false");}}else if(expr.kind._type==23){}else if(expr.kind._type==24){}else if(expr.kind._type==25){vec_Expr body=expr.kind.u.u25.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind._type==26){Expr* _if=expr.kind.u.u26._if;vec_Expr _elif=expr.kind.u.u26._elif;Expr* _else=expr.kind.u.u26._else;printf("if = ");print_expr((*_if),depth);print_opt_expr_vec(_elif,depth,"elif",1);if(_else!=(void*)0){printf(", else = ");print_expr((*_else),depth);}}else if(expr.kind._type==27){Expr* cond=expr.kind.u.u27.cond;vec_Expr body=expr.kind.u.u27.body;printf("cond = ");print_expr((*cond),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==28){vec_Expr body=expr.kind.u.u28.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind._type==29){vec_Expr body=expr.kind.u.u29.body;print_opt_expr_vec(body,depth,"body",0);}else if(expr.kind._type==30){Expr* cond=expr.kind.u.u30.cond;vec_Expr body=expr.kind.u.u30.body;print_expr((*cond),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==31){uint8_t* iter=expr.kind.u.u31.iter;Expr* iter_value=expr.kind.u.u31.iter_value;Expr* cond=expr.kind.u.u31.cond;Expr* _next=expr.kind.u.u31._next;vec_Expr body=expr.kind.u.u31.body;printf("iter = %s",iter);if(iter_value!=(void*)0){printf(", iter_value = ");print_expr((*iter_value),depth);}printf(", cond = ");print_expr((*cond),depth);printf(", next = ");print_expr((*_next),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==32){vec_VarName vars=expr.kind.u.u32.vars;Expr* iter=expr.kind.u.u32.iter;vec_Expr body=expr.kind.u.u32.body;printf("vars = [");for(int i=0;i<(vars.len);i+=1){if(i!=0){printf(", ");}printf("%s",(vars.buf)[i]);}printf("], iter = ");print_expr((*iter),depth);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==33){Expr* value=expr.kind.u.u33.value;vec_Expr cases=expr.kind.u.u33.cases;printf("value = ");print_expr((*value),depth);print_opt_expr_vec(cases,depth,"cases",1);}else if(expr.kind._type==34){vec_Expr values=expr.kind.u.u34.values;vec_Expr body=expr.kind.u.u34.body;print_opt_expr_vec(values,depth,"values",0);print_opt_expr_vec(body,depth,"body",1);}else if(expr.kind._type==35){uint8_t* label=expr.kind.u.u35.label;Expr* value=expr.kind.u.u35.value;if(label!=(void*)0){printf("label = %s",label);}if(value!=(void*)0){printf(", value = ");print_expr((*value),depth);}}else if(expr.kind._type==36){uint8_t* label=expr.kind.u.u36.label;if(label!=(void*)0){printf("label = %s",label);}}else if(expr.kind._type==37){uint8_t* label=expr.kind.u.u37.label;if(label!=(void*)0){printf("label = %s",label);}}else if(expr.kind._type==38){uint8_t* label=expr.kind.u.u38.label;Expr* value=expr.kind.u.u38.value;if(label!=(void*)0){printf("label = %s, ",label);}printf("value = ");print_expr((*value),depth);}else if(expr.kind._type==39){Expr* value=expr.kind.u.u39.value;TokenKind kind=expr.kind.u.u39.kind;print_expr((*value),depth);}else if(expr.kind._type==40){Expr* lhs=expr.kind.u.u40.lhs;Expr* rhs=expr.kind.u.u40.rhs;TokenKind kind=expr.kind.u.u40.kind;printf("lhs = ");print_expr((*lhs),depth);printf(", rhs = ");print_expr((*rhs),depth);}else if(expr.kind._type==41){Expr* cond=expr.kind.u.u41.cond;Expr* valueA=expr.kind.u.u41.valueA;Expr* valueB=expr.kind.u.u41.valueB;printf("cond = ");print_expr((*cond),depth);printf(", valueA = ");print_expr((*valueA),depth);printf(", valueB = ");print_expr((*valueB),depth);}putchar(')');};uint8_t* get_expr_name(ExprKind kind){if(kind._type==1){return "TAG";}else if(kind._type==2){return "PATH";}else if(kind._type==3){return "TAG_DEF";}else if(kind._type==4){return "BLOCK";}else if(kind._type==5){return "MOD";}else if(kind._type==6){return "USE";}else if(kind._type==7){return "FIELD";}else if(kind._type==8){return "COMP";}else if(kind._type==9){return "ENUM";}else if(kind._type==10){return "OPTION";}else if(kind._type==11){return "PROP";}else if(kind._type==12){return "DEF";}else if(kind._type==13){return "SUB_DEF";}else if(kind._type==14){return "VAR_DEF";}else if(kind._type==15){return "LOCAL_VAR_DEF";}else if(kind._type==16){return "SUB_CALL";}else if(kind._type==17){return "VAR_USE";}else if(kind._type==18){return "STRING_LIT";}else if(kind._type==19){return "CHAR_LIT";}else if(kind._type==20){return "INT_LIT";}else if(kind._type==21){return "FLOAT_LIT";}else if(kind._type==22){return "BOOL_LIT";}else if(kind._type==23){return "THIS_LIT";}else if(kind._type==24){return "TYPE_LIT";}else if(kind._type==25){return "LOCAL_BLOCK";}else if(kind._type==26){return "IF";}else if(kind._type==27){return "IF_BRANCH";}else if(kind._type==28){return "ELSE_BRANCH";}else if(kind._type==29){return "LOOP";}else if(kind._type==30){return "WHILE";}else if(kind._type==31){return "FOR";}else if(kind._type==32){return "EACH";}else if(kind._type==33){return "MATCH";}else if(kind._type==34){return "CASE";}else if(kind._type==35){return "RET";}else if(kind._type==36){return "NEXT";}else if(kind._type==37){return "JUMP";}else if(kind._type==38){return "TRY";}else if(kind._type==39){return "UNARY_OP";}else if(kind._type==40){return "BINARY_OP";}else if(kind._type==41){return "TERNARY_OP";}};void indent(int32_t depth){for(int i=0;i<=depth;i+=1){printf("  ");}};Location get_location(uint8_t* file,int32_t index){Location loc;(loc.line)=1;(loc.column)=1;for(int i=0;i<index;i+=1){if((file[i])=='\n'){(loc.line)+=1;(loc.column)=1;} else{(loc.column)+=1;}}return loc;};void print_snippet(arr_u8 file,Location location){printf(" %i | ",location.line);int32_t i=location.line;int32_t length=2;while(i!=0){length+=1;i/=10;}int32_t line_index=1;for(int i=0;i<(file.len);i+=1){uint8_t c=(file.buf)[i];if(c=='\n'){line_index+=1;if(line_index>(location.line)){goto brk_l;}} else if(line_index==(location.line)){putchar(c);}l:}brk_l:putchar('\n');for(int i=0;i<length;i+=1){putchar(' ');}putchar('|');for(int i=0;i<(location.column);i+=1){putchar(' ');}set_color((Color){3});putchar('^');set_color((Color){0});putchar('\n');};void throw(File file,int32_t index,uint8_t* error,...){va_list args;va_start(args,error);Location loc=get_location((file.data).buf,index);printf("%s:%i:%i: ",file.name,loc.line,loc.column);set_color((Color){3});printf("error: ");set_color((Color){0});vprintf(error,args);printf("\n");print_snippet(file.data,loc);exit(1);va_end(args);};void push_char(vec_u8* v,uint8_t c){(((*v).buf)[((*v).len)])=c;((*v).len)+=1;if(((*v).len)==((*v).cap)){((*v).cap)*=2;((*v).buf)=realloc((*v).buf,sizeof(uint8_t)*((*v).cap));}(((*v).buf)[((*v).len)])=0;};