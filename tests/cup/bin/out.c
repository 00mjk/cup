#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>
typedef struct vec_Expr vec_Expr;void generate_vector(vec_Expr ast);void command_help(uint8_t* n,uint8_t* d,uint8_t* o);typedef struct Command Command;Command get_command(int32_t argc,uint8_t** argv);typedef struct vec_u8 vec_u8;vec_u8 vec_u8_new(int32_t cap);void vec_u8_push(vec_u8* this,uint8_t item);typedef struct TokenKind TokenKind;int32_t get_length(TokenKind kind);uint8_t* get_name(TokenKind kind);typedef struct Token Token;typedef struct arr_u8 arr_u8;void add_to_value(arr_u8 file,uint8_t* file_name,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal);TokenKind get_keyword(uint8_t* value);typedef struct vec_Token vec_Token;vec_Token lex(arr_u8 file);vec_Token vec_Token_new(int32_t cap);void vec_Token_push(vec_Token* this,Token item);void print_tokens(vec_Token tokens);int32_t main(int32_t argc,uint8_t** argv);arr_u8 arr_u8_new(int32_t len);uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv);typedef struct Color Color;void set_color(Color color);typedef struct Expr Expr;vec_Expr parse(vec_Token tokens);vec_Expr vec_Expr_new(int32_t cap);typedef struct Location Location;Location get_location(uint8_t* file,int32_t index);void print_snippet(arr_u8 file,Location location);void throw(arr_u8 file,uint8_t* file_name,int32_t index,uint8_t* error,...);void push_char(vec_u8* v,uint8_t c);void empty(vec_u8* v);struct vec_Expr{Expr* buf;int32_t len;int32_t cap;};union CommandUnion{char _;};struct Command{int type;union CommandUnion u;};struct vec_u8{uint8_t* buf;int32_t len;int32_t cap;};union TokenKindUnion{char _;};struct TokenKind{int type;union TokenKindUnion u;};struct Token{TokenKind kind;int32_t index;uint8_t* value;};struct arr_u8{uint8_t* buf;int32_t len;};struct vec_Token{Token* buf;int32_t len;int32_t cap;};union ColorUnion{char _;};struct Color{int type;union ColorUnion u;};struct Expr{uint8_t _;};struct Location{int32_t line;int32_t column;};vec_u8 vec_u8_new(int32_t cap){return (vec_u8){malloc(sizeof(uint8_t)*cap),0,cap,};};void vec_u8_push(vec_u8* this,uint8_t item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(uint8_t)*((*this).cap));}};vec_Token vec_Token_new(int32_t cap){return (vec_Token){malloc(sizeof(Token)*cap),0,cap,};};void vec_Token_push(vec_Token* this,Token item){(((*this).buf)[((*this).len)])=item;((*this).len)+=1;if (((*this).len)==((*this).cap)) {((*this).cap)*=2;((*this).buf)=realloc((*this).buf,sizeof(Token)*((*this).cap));}};arr_u8 arr_u8_new(int32_t len){return (arr_u8){malloc(sizeof(uint8_t)*len),len,};};vec_Expr vec_Expr_new(int32_t cap){return (vec_Expr){malloc(sizeof(Expr)*cap),0,cap,};};void generate_vector(vec_Expr ast){};void command_help(uint8_t* n,uint8_t* d,uint8_t* o){printf(d);printf("\n\nUSAGE:\n    cup ");printf(n);printf(" [OPTIONS]\n\nOPTIONS:");printf(o);printf("\n");};uint8_t* command_options_empty="\n    No options are available for this command";uint8_t* command_options_compile="\n    -i, --input     Specify the input file name\n    -o, --output    Specify the output file name\n    -cg, --gcc     Use GCC as a compiler\n    -cm, --msvc    Use MSVC as a compiler\n    -cc, --clang   use Clang as a compiler\n    -ct, --tcc     Use TinyCC as a compiler";Command get_command(int32_t argc,uint8_t** argv){if (argc==1) {return (Command){1};}uint8_t is_command=0;vec_u8 vector=vec_u8_new(16);for(int i=1;i<argc;i+=1) {if (i==4) {goto brk_l;}if (((argv[i])[0])=='-') {if (is_command) {goto brk_l;}goto l;}is_command=1;int32_t length=strlen(argv[i]);for(int c=0;c<length;c+=1) {vec_u8_push((&vector),(argv[i])[c]);}l:}brk_l:vec_u8_push((&vector),'\0');uint8_t* input=vector.buf;if (strcmp(input,"help")==0) {return (Command){1};} else if (strcmp(input,"helprun")==0) {return (Command){2};} else if (strcmp(input,"helpbuild")==0) {return (Command){3};} else if (strcmp(input,"helpcheck")==0) {return (Command){4};} else if (strcmp(input,"helpupdate")==0) {return (Command){6};} else if (strcmp(input,"helpadd")==0) {return (Command){7};} else if (strcmp(input,"helpremove")==0) {return (Command){8};} else if (strcmp(input,"helpgendocs")==0) {return (Command){9};} else if (strcmp(input,"helpgenbinds")==0) {return (Command){10};} else if (strcmp(input,"helpselfupdate")==0) {return (Command){11};} else if (strcmp(input,"helpselfinstall")==0) {return (Command){12};} else if (strcmp(input,"helpselfuninstall")==0) {return (Command){13};} else if (strcmp(input,"run")==0) {return (Command){14};} else if (strcmp(input,"build")==0) {return (Command){15};} else if (strcmp(input,"check")==0) {return (Command){16};} else if (strcmp(input,"update")==0) {return (Command){18};} else if (strcmp(input,"add")==0) {return (Command){19};} else if (strcmp(input,"remove")==0) {return (Command){20};} else if (strcmp(input,"gendocs")==0) {return (Command){21};} else if (strcmp(input,"genbinds")==0) {return (Command){22};} else if (strcmp(input,"selfupdate")==0) {return (Command){23};} else if (strcmp(input,"selfinstall")==0) {return (Command){24};} else if (strcmp(input,"selfuninstall")==0) {return (Command){25};}return (Command){0};};int32_t get_length(TokenKind kind){switch(kind.type){case 7:{return 4;break;}case 8:{return 5;break;}case 9:{return 4;break;}case 10:{return 4;break;}case 11:{return 4;break;}case 12:{return 3;break;}case 13:{return 3;break;}case 14:{return 3;break;}case 15:{return 4;break;}case 16:{return 4;break;}case 17:{return 4;break;}case 18:{return 3;break;}case 19:{return 3;break;}case 20:{return 3;break;}case 21:{return 5;break;}case 22:{return 2;break;}case 23:{return 4;break;}case 24:{return 4;break;}case 25:{return 4;break;}case 26:{return 5;break;}case 27:{return 3;break;}case 28:{return 4;break;}case 29:{return 5;break;}case 30:{return 3;break;}case 31:{return 4;break;}case 32:{return 4;break;}case 33:{return 3;break;}case 34:{return 2;break;}case 35:{return 1;break;}case 36:{return 1;break;}case 37:{return 1;break;}case 38:{return 1;break;}case 39:{return 1;break;}case 40:{return 1;break;}case 41:{return 1;break;}case 42:{return 1;break;}case 43:{return 1;break;}case 44:{return 1;break;}case 45:{return 1;break;}case 46:{return 1;break;}case 47:{return 1;break;}case 48:{return 1;break;}case 49:{return 1;break;}case 50:{return 1;break;}case 51:{return 2;break;}case 52:{return 1;break;}case 53:{return 2;break;}case 54:{return 1;break;}case 55:{return 1;break;}case 56:{return 1;break;}case 57:{return 2;break;}case 58:{return 1;break;}case 59:{return 2;break;}case 60:{return 1;break;}case 61:{return 2;break;}case 62:{return 1;break;}case 63:{return 2;break;}case 64:{return 1;break;}case 65:{return 2;break;}case 66:{return 1;break;}case 67:{return 2;break;}case 68:{return 1;break;}case 69:{return 2;break;}}};uint8_t* get_name(TokenKind kind){switch(kind.type){case 2:{return "IDENT";break;}case 3:{return "STRING_LIT";break;}case 4:{return "CHAR_LIT";break;}case 5:{return "INT_LIT";break;}case 6:{return "FLOAT_LIT";break;}case 7:{return "TRUE";break;}case 8:{return "FALSE";break;}case 9:{return "NONE";break;}case 10:{return "THIS";break;}case 11:{return "TYPE";break;}case 12:{return "TAG";break;}case 13:{return "MOD";break;}case 14:{return "USE";break;}case 15:{return "COMP";break;}case 16:{return "ENUM";break;}case 17:{return "PROP";break;}case 18:{return "DEF";break;}case 19:{return "SUB";break;}case 20:{return "VAR";break;}case 21:{return "WHERE";break;}case 22:{return "IF";break;}case 23:{return "ELIF";break;}case 24:{return "ELSE";break;}case 25:{return "LOOP";break;}case 26:{return "WHILE";break;}case 27:{return "FOR";break;}case 28:{return "EACH";break;}case 29:{return "MATCH";break;}case 30:{return "RET";break;}case 31:{return "NEXT";break;}case 32:{return "JUMP";break;}case 33:{return "TRY";break;}case 34:{return "AS";break;}case 35:{return "SEMICOLON";break;}case 36:{return "COLON";break;}case 37:{return "COMMA";break;}case 38:{return "DOT";break;}case 39:{return "QUESTION_MARK";break;}case 40:{return "TILDE";break;}case 41:{return "HASH";break;}case 42:{return "LEFT_PAREN";break;}case 43:{return "RIGHT_PAREN";break;}case 44:{return "LEFT_BRACE";break;}case 45:{return "RIGHT_BRACE";break;}case 46:{return "LEFT_BRACKET";break;}case 47:{return "RIGHT_BRACKET";break;}case 48:{return "DEREF";break;}case 49:{return "ADDRESS";break;}case 50:{return "ASSIGN";break;}case 51:{return "EQUAL";break;}case 52:{return "NOT";break;}case 53:{return "NOT_EQUAL";break;}case 54:{return "AND";break;}case 55:{return "OR";break;}case 56:{return "LESS";break;}case 57:{return "LESS_EQUAL";break;}case 58:{return "GREATER";break;}case 59:{return "GREATER_EQUAL";break;}case 60:{return "ADD";break;}case 61:{return "ADD_ASSIGN";break;}case 62:{return "SUBTRACT";break;}case 63:{return "SUBTRACT_ASSIGN";break;}case 64:{return "MULTIPLY";break;}case 65:{return "MULTIPLY_ASSIGN";break;}case 66:{return "DIVIDE";break;}case 67:{return "DIVIDE_ASSIGN";break;}case 68:{return "MODULO";break;}case 69:{return "MODULO_ASSIGN";break;}}};void add_to_value(arr_u8 file,uint8_t* file_name,vec_u8* value,int32_t i,uint8_t c,uint8_t is_literal){if ((is_literal==2)&&(((*value).len)==4)) {throw(file,file_name,i,"too many characters in character literal");}push_char(value,c);};TokenKind get_keyword(uint8_t* value){if (strcmp(value,"tag")==0) {return (TokenKind){12};} else if (strcmp(value,"mod")==0) {return (TokenKind){13};} else if (strcmp(value,"use")==0) {return (TokenKind){14};} else if (strcmp(value,"comp")==0) {return (TokenKind){15};} else if (strcmp(value,"enum")==0) {return (TokenKind){16};} else if (strcmp(value,"prop")==0) {return (TokenKind){17};} else if (strcmp(value,"def")==0) {return (TokenKind){18};} else if (strcmp(value,"sub")==0) {return (TokenKind){19};} else if (strcmp(value,"var")==0) {return (TokenKind){20};} else if (strcmp(value,"this")==0) {return (TokenKind){10};} else if (strcmp(value,"type")==0) {return (TokenKind){11};} else if (strcmp(value,"where")==0) {return (TokenKind){21};} else if (strcmp(value,"true")==0) {return (TokenKind){7};} else if (strcmp(value,"false")==0) {return (TokenKind){8};} else if (strcmp(value,"none")==0) {return (TokenKind){9};} else if (strcmp(value,"if")==0) {return (TokenKind){22};} else if (strcmp(value,"elif")==0) {return (TokenKind){23};} else if (strcmp(value,"else")==0) {return (TokenKind){24};} else if (strcmp(value,"loop")==0) {return (TokenKind){25};} else if (strcmp(value,"while")==0) {return (TokenKind){26};} else if (strcmp(value,"for")==0) {return (TokenKind){27};} else if (strcmp(value,"each")==0) {return (TokenKind){28};} else if (strcmp(value,"match")==0) {return (TokenKind){29};} else if (strcmp(value,"ret")==0) {return (TokenKind){30};} else if (strcmp(value,"next")==0) {return (TokenKind){31};} else if (strcmp(value,"jump")==0) {return (TokenKind){32};} else if (strcmp(value,"try")==0) {return (TokenKind){33};} else if (strcmp(value,"as")==0) {return (TokenKind){34};}return (TokenKind){1};};vec_Token lex(arr_u8 file){vec_Token tokens=vec_Token_new(32);uint8_t is_comment=0;uint8_t is_literal=0;vec_u8 value=vec_u8_new(8);empty((&value));for(int i=0;i<=(file.len);i+=1) {uint8_t c=(file.buf)[i];if (((((is_literal!=1)&&(is_literal!=2))&&(is_literal!=3))&&(is_literal!=4))&&(c=='`')) {is_comment=1;goto l;}if (is_comment!=0) {if (c=='\n') {is_comment=0;}goto l;}TokenKind kind=(TokenKind){0};if ((is_literal==3)||(is_literal==4)) {is_literal-=2;}if ((is_literal==1)||(is_literal==2)) {if (c==0) {if (is_literal==1) {throw(file,"test_name",i-1,"expected end of %s literal","string");} else {throw(file,"test_name",i-1,"expected end of %s literal","char");}} else if ((is_literal==1)&&(c=='"')) {} else if ((is_literal==2)&&(c==39)) {} else {add_to_value(file,"test_name",(&value),i,c,is_literal);goto l;}}if (isspace(c)) {kind=(TokenKind){1};} else {if (c=='"') {if (is_literal==1) {kind=(TokenKind){3};is_literal=0;} else {kind=(TokenKind){1};is_literal=3;}} else if (c==39) {if (is_literal==2) {kind=(TokenKind){4};is_literal=0;} else {kind=(TokenKind){1};is_literal=4;}} else if (c==';') {kind=(TokenKind){35};} else if (c==':') {kind=(TokenKind){36};} else if (c==',') {kind=(TokenKind){37};} else if (c=='.') {uint8_t n=(file.buf)[(i+1)];if ((is_literal!=5)||((n=='_')||isalpha(n))) {kind=(TokenKind){38};}} else if (c=='?') {kind=(TokenKind){39};} else if (c=='~') {kind=(TokenKind){40};} else if (c=='#') {kind=(TokenKind){41};} else if (c=='(') {kind=(TokenKind){42};} else if (c==')') {kind=(TokenKind){43};} else if (c=='{') {kind=(TokenKind){44};} else if (c=='}') {kind=(TokenKind){45};} else if (c=='[') {kind=(TokenKind){46};} else if (c==']') {kind=(TokenKind){47};} else if (c=='@') {kind=(TokenKind){48};} else if (c=='$') {kind=(TokenKind){49};} else if (c=='&') {kind=(TokenKind){54};} else if (c=='|') {kind=(TokenKind){55};} else if (c=='=') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){51};i+=1;} else {kind=(TokenKind){50};}} else if (c=='!') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){53};i+=1;} else {kind=(TokenKind){52};}} else if (c=='<') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){57};i+=1;} else {kind=(TokenKind){56};}} else if (c=='>') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){59};i+=1;} else {kind=(TokenKind){58};}} else if (c=='+') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){61};i+=1;} else {kind=(TokenKind){60};}} else if (c=='-') {} else if (c=='*') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){65};i+=1;} else {kind=(TokenKind){64};}} else if (c=='/') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){67};i+=1;} else {kind=(TokenKind){66};}} else if (c=='%') {if (((i+1)<(file.len))&&(((file.buf)[(i+1)])=='=')) {kind=(TokenKind){69};i+=1;} else {kind=(TokenKind){68};}}}switch(kind.type){case 0:{if (((((c=='-')||(c=='_'))||(c=='.'))||(c==':'))||isalnum(c)) {if ((((value.len)==0)&&isdigit(c))||(c=='-')) {is_literal=5;} else if ((is_literal==5)||(is_literal==6)) {if ((c=='.')&&(is_literal==5)) {is_literal=6;} else if ((c=='_')||isdigit(c)) {} else {throw(file,"test_name",i-(value.len),"invalid identifier name starting with a digit");}}if (((is_literal!=5)&&(is_literal!=6))||(c!='_')) {add_to_value(file,"test_name",(&value),i,c,is_literal);}} else {throw(file,"test_name",i,"unexpected symbol %c",c);}break;}default:{if ((value.len)>0) {switch(kind.type){case 3:{break;}case 4:{break;}default:{TokenKind value_kind=get_keyword(value.buf);switch(value_kind.type){case 1:{Token token;if (is_literal==5) {(token.kind)=(TokenKind){5};} else if (is_literal==6) {(token.kind)=(TokenKind){6};if (((value.buf)[((value.len)-1)])=='.') {throw(file,"test_name",i-1,"expected a value after the decimal point");}} else {(token.kind)=(TokenKind){2};}(token.index)=(i-(value.len));(token.value)=(value.buf);vec_Token_push((&tokens),token);break;}default:{Token token=(Token){value_kind,i-get_length(value_kind),};vec_Token_push((&tokens),token);break;}}value=vec_u8_new(8);empty((&value));is_literal=0;break;}}}switch(kind.type){case 1:{break;}default:{Token token=(Token){kind,};switch(kind.type){case 3:{(token.value)=(value.buf);(token.index)=(i-(value.len));empty((&value));break;}case 4:{(token.value)=(value.buf);(token.index)=(i-(value.len));empty((&value));break;}default:{(token.index)=((i-get_length(kind))+1);break;}}vec_Token_push((&tokens),token);break;}}break;}}l:}brk_l:return tokens;};void print_tokens(vec_Token tokens){printf("Tokens:\n");for(int i=0;i<(tokens.len);i+=1) {TokenKind kind=((tokens.buf)[i]).kind;set_color((Color){1});printf("  %s",get_name(kind));set_color((Color){0});switch(kind.type){case 2:{printf("(%s)",((tokens.buf)[i]).value);break;}case 3:{printf("(%s)",((tokens.buf)[i]).value);break;}case 4:{printf("(%s)",((tokens.buf)[i]).value);break;}case 5:{printf("(%s)",((tokens.buf)[i]).value);break;}case 6:{printf("(%s)",((tokens.buf)[i]).value);break;}}putchar('\n');}putchar('\n');};uint8_t* file_name=(void*)0;int32_t file_size;int32_t main(int32_t argc,uint8_t** argv){Command command=get_command(argc,argv);switch(command.type){case 0:{set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such command: '%s",argv[1]);for(int i=2;i<argc;i+=1) {printf(" %s",argv[i]);}printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;break;}case 14:{goto brk_m;break;}case 15:{goto brk_m;break;}case 16:{return 1;break;}case 17:{return 1;break;}case 18:{return 1;break;}case 19:{return 1;break;}case 20:{return 1;break;}case 21:{return 1;break;}case 22:{return 1;break;}case 23:{return 1;break;}case 24:{return 1;break;}case 25:{return 1;break;}case 1:{printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;break;}case 2:{command_help("run","Compile and run the current package",command_options_compile);return 0;break;}case 3:{command_help("build","Compile the current package",command_options_compile);return 0;break;}case 4:{command_help("check","Analyze the current package",command_options_empty);return 0;break;}case 5:{command_help("new","Create a new package",command_options_empty);return 0;break;}case 6:{command_help("update","Update given dependency",command_options_empty);return 0;break;}case 7:{command_help("add","Adds given dependency",command_options_empty);return 0;break;}case 8:{command_help("remove","Removes given dependency",command_options_empty);return 0;break;}case 9:{command_help("gen docs","Generate documentation for the current package",command_options_empty);return 0;break;}case 10:{command_help("gen binds","Generate bindings for a given C header file",command_options_empty);return 0;break;}case 11:{command_help("self update","Update the Cup Toolkit",command_options_empty);return 0;break;}case 12:{command_help("self install","Install the Cup Toolkit",command_options_empty);return 0;break;}case 13:{command_help("self uninstall","Uninstall the Cup Toolkite",command_options_empty);return 0;break;}}brk_m:uint8_t* output=(void*)0;for(int i=2;i<argc;i+=1) {if (((argv[i])[0])=='-') {if (((argv[i])[1])=='i') {if (file_name==(void*)0) {file_name=get_option((&i),argc,argv);}} else if (((argv[i])[1])=='o') {if (output==(void*)0) {output=get_option((&i),argc,argv);}}} else {set_color((Color){3});printf("error: ");set_color((Color){0});printf("invalid option '%s'",argv[i]);}}FILE* file_point=fopen(file_name,"rb");if (file_point==(void*)0) {set_color((Color){3});printf("error: ");set_color((Color){0});printf("no such file or directory: '%s'",file_name);return 1;}fseek(file_point,(int32_t)0,SEEK_END);file_size=ftell(file_point);rewind(file_point);arr_u8 file=arr_u8_new(file_size);fread(file.buf,file_size,1,file_point);fclose(file_point);vec_Token tokens=lex(file);print_tokens(tokens);vec_Expr ast=parse(tokens);printf("Compilation successful (%.3lfs elapsed)\n",((double)clock())/CLOCKS_PER_SEC);return 0;};uint8_t* get_option(int32_t* index,int32_t argc,uint8_t** argv){if (strlen(argv[(*index)])>2) {return (argv[(*index)])+1;} else if (argc>(*index)) {return argv[((*index)+=1)];}return (void*)0;};void set_color(Color color){switch(color.type){case 0:{printf("\033[0m");break;}case 1:{printf("\033[35m");break;}case 2:{printf("\033[32m");break;}case 3:{printf("\033[0;31m");break;}}};vec_Expr parse(vec_Token tokens){return vec_Expr_new(1);};Location get_location(uint8_t* file,int32_t index){Location loc;(loc.line)=1;(loc.column)=1;for(int i=0;i<index;i+=1) {if ((file[i])=='\n') {(loc.line)+=1;(loc.column)=1;} else {(loc.column)+=1;}}return loc;};void print_snippet(arr_u8 file,Location location){printf(" %i | ",location.line);int32_t i=location.line;int32_t length=2;while(i!=0) {length+=1;i/=10;}int32_t line_index=1;for(int i=0;i<(file.len);i+=1) {uint8_t c=(file.buf)[i];if (c=='\n') {line_index+=1;if (line_index>(location.line)) {goto brk_l;}} else if (line_index==(location.line)) {putchar(c);}l:}brk_l:putchar('\n');for(int i=0;i<length;i+=1) {putchar(' ');}putchar('|');for(int i=0;i<(location.column);i+=1) {putchar(' ');}set_color((Color){3});putchar('^');set_color((Color){0});putchar('\n');};void throw(arr_u8 file,uint8_t* file_name,int32_t index,uint8_t* error,...){va_list args;va_start(args,error);Location loc=get_location(file.buf,index);printf("%s:%i:%i: ",file_name,loc.line,loc.column);set_color((Color){3});printf("error: ");set_color((Color){0});vprintf(error,args);printf("\n");print_snippet(file,loc);exit(1);va_end(args);};void push_char(vec_u8* v,uint8_t c){(((*v).buf)[((*v).len)])=c;((*v).len)+=1;if (((*v).len)==((*v).cap)) {((*v).cap)*=2;((*v).buf)=realloc((*v).buf,sizeof(uint8_t)*((*v).cap));}(((*v).buf)[((*v).len)])=0;};void empty(vec_u8* v){(((*v).buf)[0])=(((*v).len)=0);};