#bind("int") comp isize ();
#bind("unsigned int") comp usize ();
#bind("int") comp bsize ();

use i32 as int;
use u32 as uint;
use b8 as bool;

#req("stdint.h")
{
    #bind("int8_t") comp i8 ();
    #bind("int16_t") comp i16 ();
    #bind("int32_t") comp i32 ();
    #bind("int64_t") comp i64 ();

    #bind("uint8_t") comp u8 ();
    #bind("uint16_t") comp u16 ();
    #bind("uint32_t") comp u32 ();
    #bind("uint64_t") comp u64 ();

    #bind("int8_t") comp b8 ();
    #bind("int16_t") comp b16 ();
    #bind("int32_t") comp b32 ();
    #bind("int64_t") comp b64 ();

    #bind("uint32_t") comp char ();
};

use f64 as float;

#bind("float") comp f32 ();
#bind("double") comp f64 ();

mod mem {
    comp ptr ();
    
    #req("stdlib.h") {
        #bind("malloc")
        #pub ptr alloc (isize size);

        #bind("realloc")
        #pub ptr realloc (ptr block, isize size);
    };

    #req("string.h")
    {
        #bind("memcpy")
        #pub sub copy (ptr dest, ptr src, isize size);

        #bind("memmove")
        #pub sub move (ptr dest, ptr src, isize size);
    };

    #bind("sizeof")
    #pub isize size<type T> (); 
};

comp ref<type T> () {
    #pub ref<T> alloc () {
        ret mem:alloc(mem:size<T>()) as ref<T>;
    };
};

comp str (
    ptr<char> buf,
    int len,
);

comp arr<type T> (
    ptr<T> buf,
    int len,
);

#req("stdio.h")
#bind("printf")
sub fmt:print ();

`` comp arr<type T> (
``     mem:ptr buf,
``     int len,
`` ) {
``     arr<T> new_with_len (int len) {
``         ret arr<T>(mem:alloc_bytes(mem:size<T>() * len), len);
``     };
`` 
``     arr<T> new_from_ptr (c:ptr buf, int len) {
``         ret arr<T>(buf, len);
``     };
`` 
``     #self darr<T> to_darr () {
``         ret darr<T>(this.buf, this.len, this.len);
``     };
`` };
`` 
`` def op:Index<T> for arr<type T> {
``     #self T index(int i) {
``         ret this.buf[i] as ref<T>;
``     };
`` };
`` 
`` def op:Index<ref<T>> for ref<arr<type T>> {
``     #self ref<T> index(int i) {
``         ret this.buf[i] as ref<T>;
``     };
`` };
`` 
`` comp darr<type T> (
``     mem:ptr buf,
``     int len,
``     int cap,
`` ) {
``     darr<T> new_with_cap (int cap) {
``         ret darr<T>(mem:alloc_bytes(mem:size<T>() * cap), 0, cap);
``     };
`` 
``     #self sub push (T item) {
``         this[this.len] = item;
``         this.len += 1;
`` 
``         if this.len == this.cap {
``             this.cap *= 4;
``             this.buf = mem:realloc(this.buf, mem:size<T>() * this.cap);
``         };
``     };
`` 
``     #self sub push_back (T item) {
``         this.len += 1;
`` 
``         if this.len == this.cap {
``             this.cap *= 4;
``             this.buf = mem:realloc(this.buf, mem:size<T>() * this.cap);
``         };
`` 
``         mem:move(this.buf + 1, this.buf, mem:size<T>() * (this.len - 1));
``         this[0] = item;
``     };
`` 
``     #self T pop () {
``         this.len -= 1;
``         ret this[this.len];
``     };
`` 
``     #self T pop_back () {
``         T item = this[0];
``         this.len -= 1;
``         mem:move(this.buf, this.buf + 1, mem:size<T>() * this.len);
``         ret item;    
``     };
`` 
``     #self sub join (darr<T> other) {
``         if other.len == 0 {
``             ret;
``         };
``         int old_len = this.len;
``         this.len += other.len;
``         while this.len >= this.cap {
``             this.cap *= 4;
``             this.buf = mem:realloc(this.buf, mem:size<T>() * this.cap);
``         };
``         mem:copy(this.buf + old_len, other.buf, mem:size<T>() * other.len);
``     };
`` 
``     #self sub join_back (darr<T> other) {
``         if other.len == 0 {
``             ret;
``         };
``         int old_len = this.len;
``         this.len += other.len;
``         while this.len >= this.cap {
``             this.cap *= 4;
``             this.buf = mem:realloc(this.buf, mem:size<T>() * this.cap);
``         };
``         mem:move(this.buf + other.len, this.buf, mem:size<T>() * old_len);
``         mem:copy(this.buf, other.buf, mem:size<T>() * other.len);
``     };
`` 
``     #self arr<T> to_arr () {
``         ret arr<T>(this.buf, this.len);
``     };
`` };
`` 
`` def op:Index<T> for darr<type T> {
``     #self T index(int i) {
``         ret this.buf[i] as ref<T>;
``     };
`` };
`` 
`` def op:Index<ref<T>> for darr<arr<type T>> {
``     #self ref<T> index(int i) {
``         ret this.buf[i] as ref<T>;
``     };
`` };