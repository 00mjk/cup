comp MangledExpr (
    Expr expr,
    Path path,
    str name,
);

comp Use (
    Path path,
    Path alias,
);

int mangle_index;
darr<darr<MangledExpr>> paths;
darr<Use> uses;
darr<Expr> local_vars;
darr<PathPart> mods;

sub init_analyzer() {
    mangle_index = 0;
    paths = darr<darr<MangledExpr>>:new_with_cap(4);
    uses = darr<Use>:new_with_cap(4);
    local_vars = darr<Expr>:new_with_cap(4);
    mods = darr<PathPart>:new_with_cap(4);
};

sub analyze_globals(File file, darr<Expr> exprs) {
    for i = 0, i < exprs.len, i += 1 {
        analyze_global(file, exprs[i]$);
    };
};

sub analyze_global(File file, ptr<Expr> expr) {
    opt<Tag> pub = opt<Tag>:None;
    opt<Tag> bind = opt<Tag>:None;
    for i = 0, i < expr@.tags.len, i += 1 {
        Tag _tag = expr@.tags[i];
        if cmp_path_to_str(_tag.path, "pub") {
            if pub != opt<Tag>:None {
                file.throw(_tag.index, "only one #pub is allowed per path");
            };
            pub = opt<Tag>:Some(_tag);
        } elif cmp_path_to_str(_tag.path, "bind") {
            if bind != opt<Tag>:None {
                file.throw(_tag.index, "only one #bind is allowed per path");
            };
            bind = opt<Tag>:Some(_tag);
        };
    };

    ptr<Path> path;
    match expr@.kind {
        ExprKind:Block(darr<Expr> body) {
            analyze_globals(file, body);
            ret;
        },
        ExprKind:Mod(#ref Path _path, darr<Expr> body) {
            try_apply_pub(pub, _path@);
            darr<PathPart> old_mods = mods;
            mods.join(_path@.parts);
            Path old_path = Path:clone(_path);
            darr<PathPart>:join_back(_path@.parts$, old_mods);
            analyze_globals(file, body);
            mods.len = old_mods.len;
            uses.push(new Use {
                path = _path@,
                alias = old_path,
            });
        },
        ExprKind:Use(Path _path) {
            Path alias = new Path {
                parts = darr<PathPart>:new_with_cap(1),
                index = _path.index,
            };
            darr<PathPart>:push(alias.parts$, _path.parts[_path.parts.len - 1]);
            uses.push(new Use {
                path = _path,
                alias = alias,
            });
            ret;
        },
        ExprKind:Comp(#ref Path _path) {
            try_apply_pub(pub, _path@);
            Path old_path = Path:clone(_path);
            darr<PathPart>:join_back(_path@.parts$, mods);
            uses.push(new Use {
                path = _path@,
                alias = old_path,
            });
            path = _path;
        },
        ExprKind:Enum(#ref Path _path) {
            try_apply_pub(pub, _path@);
            Path old_path = Path:clone(_path);
            darr<PathPart>:join_back(_path@.parts$, mods);
            uses.push(new Use {
                path = _path@,
                alias = old_path,
            });
            path = _path;
        },
        ExprKind:Def(Path _prop, _, darr<Expr> body) {
            try_apply_pub(pub, _prop);
            int old_mods_len = mods.len;
            mods.join(_prop.parts);
            analyze_globals(file, body);
            mods.len = old_mods_len;
        },
        ExprKind:SubDef(_, #ref Path _path) {
            try_apply_pub(pub, _path@);
            Path old_path = Path:clone(_path);
            darr<PathPart>:join_back(_path@.parts$, mods);
            uses.push(new Use {
                path = _path@,
                alias = old_path,
            });
            path = _path;
        },
        ExprKind:VarDef(opt<Path> _type, #ref Path _path) {
            try_apply_pub(pub, _path@);
            Path old_path = Path:clone(_path);
            darr<PathPart>:join_back(_path@.parts$, mods);
            uses.push(new Use {
                path = _path@,
                alias = old_path,
            });
            path = _path;
        },
    };

    match pub {
        opt<Tag>:Some(Tag _tag) {
            match expr@.kind {
                ExprKind:Mod,
                ExprKind:Comp,
                ExprKind:Enum,
                ExprKind:Def,
                ExprKind:SubDef,
                ExprKind:VarDef {},
                _ {
                    file.throw(_tag.index, "#pub cannot be applied to this expr");
                },
            };
        },
    };

    bool gen = has_generics(path@);

    match bind {
        opt<Tag>:Some(Tag _tag) {
            match expr@.kind {
                ExprKind:Comp,
                ExprKind:Enum,
                ExprKind:SubDef,
                ExprKind:VarDef {
                    if gen {
                        file.throw(_tag.index, "#bind cannot be applied to generic expressions");
                    };
                },
                _ {
                    file.throw(_tag.index, "#bind cannot be applied to this expression");
                },
            };
        },
    };

    match expr@.kind {
        ExprKind:Comp,
        ExprKind:Enum,
        ExprKind:SubDef,
        ExprKind:VarDef {
            if path@.parts.len <= paths.len {
                if is_path_defined(path@) {
                    file.throw(path@.index, "path already defined");
                };
            };

            match bind {
                opt<Tag>:Some(Tag _tag) {
                    match expr@.kind {
                        ExprKind:Comp,
                        ExprKind:Enum,
                        ExprKind:SubDef,
                        ExprKind:VarDef {
                            if _tag.args.len != 1 {
                                file.throw(_tag.index, "#bind requires one argument of type string");
                            };
                            match _tag.args[0].kind {
                                ExprKind:StringLit(str value) {
                                    add_mangled_expr(expr@, path@, value);
                                },
                                _ {
                                    file.throw(_tag.index, "#bind requires one argument of type string");
                                },
                            };
                        },
                    };
                },
                opt<Tag>:None {
                    add_mangled_expr(expr@, path@, new_mangle(mangle_index += 1, false, 0));
                },
            };
        },
    };
};

sub analyze_locals(File file, darr<Expr> exprs) {
    for i = 0, i < exprs.len, i += 1 {
        analyze_local(file, exprs[i]$);
    };
};

sub analyze_local(File file, ptr<Expr> expr) {
    match expr@.kind {
        ExprKind:Block(darr<Expr> body) {
            analyze_locals(file, body);
        },
        ExprKind:Mod(Path path, darr<Expr> body) {
            analyze_locals(file, body);
        },
        ExprKind:Use(#ref Path path) {
            apply_uses(path);
            if is_path_defined(path@) == false {
                file.throw(path@.index, "path not defined");
            };
        },
        ExprKind:Field(#ref Path _type, str name) {
            apply_uses(_type);
            if is_path_defined(_type@) == false {
                file.throw(_type@.index, "path not defined");
            };
        },
        ExprKind:Comp(Path path, darr<Expr> fields, darr<Expr> body) {
            analyze_locals(file, fields);
            analyze_locals(file, body);
        },
        ExprKind:Enum(Path path, darr<Expr> opts, darr<Expr> body) {
            analyze_locals(file, opts);
            analyze_locals(file, body);
        },
        ExprKind:Option(str name, darr<Expr> fields) {
            analyze_locals(file, fields);
        },
        ExprKind:Prop(Path path, darr<Expr> body) {
            analyze_locals(file, body);
        },
        ExprKind:Def(Path _prop, opt<Path> target, darr<Expr> body) {},
        ExprKind:SubDef(opt<Path> ret_type, Path path, darr<Expr> args, darr<Expr> body) {},
        ExprKind:VarDef(opt<Path> _type, Path path, opt<ptr<Expr>> value) {},
        ExprKind:LocalVarDef(opt<Path> _type, str name, opt<ptr<Expr>> value) {},
        ExprKind:SubCall(Path path, darr<Expr> args) {},
        ExprKind:VarUse(Path path) {},
        ExprKind:CompInst(Path _type, darr<FieldValue> field_vals) {},
        ExprKind:EnumInst(Path _type, Path path, int opt_index, darr<Expr> args) {},
        ExprKind:LocalBlock(darr<Expr> body) {},
        ExprKind:If(IfBranch _if, darr<IfBranch> _elif, opt<ElseBranch> _else) {},
        ExprKind:Loop(darr<Expr> body) {},
        ExprKind:While(ptr<Expr> cond, darr<Expr> body) {},
        ExprKind:For(str iter, opt<ptr<Expr>> iter_value, ptr<Expr> cond, ptr<Expr> _next, darr<Expr> body) {},
        ExprKind:Each(darr<str> vars, ptr<Expr> iter, darr<Expr> body) {},
        ExprKind:Match(ptr<Expr> value, darr<Expr> cases) {},
        ExprKind:Case(darr<Expr> values, darr<Expr> body) {},
        ExprKind:Echo(ptr<Expr> value) {},
        ExprKind:Ret(opt<str> label, opt<ptr<Expr>> value) {},
        ExprKind:Try(opt<str> label, ptr<Expr> value) {},
        ExprKind:UnaryOp(ptr<Expr> value, TokenKind kind) {},
        ExprKind:BinaryOp(ptr<Expr> lhs, ptr<Expr> rhs, TokenKind kind) {},
        ExprKind:TernaryOp(ptr<Expr> cond, ptr<Expr> valueA, ptr<Expr> valueB) {},
    };
};

bool is_path_defined(Path path) {
    darr<MangledExpr> len_paths = paths[path.parts.len - 1];
    for i = 0, i < len_paths.len, i += 1 {
        if compare_paths(path, len_paths[i].path) {
            ret true;
        };
    };
    ret false;
};

bool has_generics(Path path) {
    for i = 0, i < path.parts.len, i += 1 {
        if path.parts[i].gens.len > 0 {
            ret true;
        };
    };
    ret false;
};

sub try_apply_pub(opt<Tag> pub, Path path) {
    if pub != opt<Tag>:None {
        for i = 0, i < path.parts.len, i += 1 {
            path.parts[i].pub = true;
        };
    };
};

sub apply_uses(ptr<Path> path) {
    ~l loop {
        for i = 0, i < uses.len, i += 1 {
            if compare_paths(path@, uses[i].alias) {
                path@ = uses[i].path;
                next ~l;
            };
        };
        ret;
    };
};

str mangle(Path path, bool gens, bool _new) {
    ` if (path.parts.len == 1) & (path.parts[0].gens.len == 0) {
    `     for i = 0, i < mangled_local_names.len, i += 1 {
    `         if str:cmp(path.parts[0].name, mangled_local_names[i].local_name) == 0 {
    `             ret mangled_local_names[i].name;
    `         };
    `     };
    ` };
    if path.parts.len <= paths.len {
        darr<MangledExpr> len_paths = paths[path.parts.len - 1];
        ~l for i = 0, i < len_paths.len, i += 1 {
            ` if compare_paths(path, paths[i].path, gens) {
            `     if _new {
            `         ret none;
            `     } else {
            `         ptr<u8> name = paths[i].name;
            `         if pointer_count > 0 {
            `             int len = str:len(name);
            `             vec<u8> _name = vec<u8>:new(len + pointer_count + 1);
            `             mem:copy(_name.buf, name, len * mem:size<u8>());
            `             _name.len = len;
            `             for i = 0, (i) < pointer_count, i += 1 {
            `                 _name.push('*');
            `             };
            `             _name.buf[_name.len] = '\0';
            `             ret (_name.buf);
            `         } else {
            `             ret name;
            `         };
            `     };
            ` };
        };
    } else {
        while path.parts.len > paths.len {
            paths.push(darr<MangledExpr>:new_with_cap(16));
        };
    };

    int pointer_count = 0;
    Path ptr_path = path;
    ` FIXME:
    ` while (ptr_path.parts[0].gens.len == 1) & cmp_path_to_str(ptr_path, "ptr") {
    `     ptr_path = ptr_path.parts[0].gens[0];
    `     pointer_count += 1;
    ` };

    `` dstr name = new_mangle(mangle_index += 1, false);

    `` darr<MangledExpr>:push(paths[path.parts.len - 1]$, new MangledExpr {
    ``     ` expr = expr,
    ``     path = path,
    ``     name = name.to_str(),
    `` });

    `` if pointer_count > 0 {
    ``     str old_name = name.to_str();
    ``     name = dstr:new_with_cap(name.len + pointer_count);
    ``     name.join(old_name);
    ``     for i = 0, i < pointer_count, i += 1 {
    ``         name.push('*');
    ``     };
    `` };

    `` ret name.to_str();
};

str new_mangle(int index, bool local, int pointer_count) {
    dstr _name = dstr:new_with_cap(4);
    
    _name.push('_');
    if local {
        _name.push('_');
    };

    while index > 0 {
        int i = index % 62;
        if i < 10 {
            i += 48;
        } elif i < 36 {
            i += 55;
        } else {
            i += 61;
        };
        _name.push(i);
        index /= 62;
    };

    for i = 0, i < pointer_count, i += 1 {
        _name.push('*');
    };

    ret _name.to_str();
};

bool cmp_path_to_str(Path path, ptr<u8> name) {
    ret (path.parts.len == 1) & (cstr:cmp(path.parts[0].name.buf, name) == 0);
};

bool compare_paths(Path a, Path b) {
    if a.parts.len != b.parts.len {
        ret false;
    };
    
    ~l for i = 0, i < a.parts.len, i += 1 {
        PathPart aPart = a.parts[i];
        PathPart bPart = b.parts[i];
        if cstr:cmp(aPart.name.buf, bPart.name.buf) == 0 {
            next ~l;
        };
        ret false;
    };
    ret true;
};

` bool compare_gens(darr<Path> a, darr<Path> b) {
`     if a.len != b.len {
`         ret false;
`     };
` 
`     for i = 0, i < a.len, i += 1 {
`         if compare_paths(a[i], b[i], true) == false {
`             ret false;
`         };
`     };
`     ret true;
` };

sub add_mangled_expr(Expr expr, Path path, str name) {
    while path.parts.len > paths.len {
        paths.push(darr<MangledExpr>:new_with_cap(16));
    };
    darr<MangledExpr>:push(paths[path.parts.len - 1]$, new MangledExpr {
        expr = expr,
        path = path,
        name = name,
    });
};