#include "stdint.h"
#include "stdlib.h"
#include "string.h"
#include "stdio.h"
#include "time.h"
typedef struct _c _c;typedef struct _k _k;typedef struct _m _m;typedef struct _e _e;typedef struct _o _o;typedef struct _h _h;typedef struct _r _r;int main(int __1,uint8_t** __2);_c _d(int __4);void _l();_m _n(int __2);void _i(uint8_t* __1,uint8_t* __2,uint8_t* __3);_e _f(_c __1);_o _p(int __4);uint8_t* _q(_o* this,int __4);double _j();void _g(_h __1);uint8_t* _1="\n    No options are available for this command";uint8_t* _2="\n    -i, --input     Specify the input file name\n    -o, --output    Specify the output file name\n    -cg, --gcc     Use GCC as a compiler\n    -cm, --msvc    Use MSVC as a compiler\n    -cc, --clang   use Clang as a compiler\n    -ct, --tcc     Use TinyCC as a compiler";typedef struct _c{uint8_t** buf;int len;}_c;typedef struct _k{uint8_t* buf;int len;}_k;typedef struct _m{_k* buf;int len;}_m;typedef struct _e{int t;union{}u;}_e;typedef struct _o{uint8_t* buf;int len;int cap;}_o;typedef struct _h{int t;union{}u;}_h;typedef struct _r{uint8_t* buf;int len;}_r;_c _d(int __4){return (_c){.buf=malloc(sizeof(uint8_t*)*__4),.len=__4,};};int main(int __1,uint8_t** __2){_c __3=_d(__1);_e __4=_f(__3);if(__4.t==0){_g((_h){.t=3});printf("error: ");_g((_h){.t=0});printf("'\n\nSee 'cup help' for the list of available commands.\n");return 1;}else if(__4.t==14){goto ret_m;}else if(__4.t==15){goto ret_m;}else if(__4.t==16){return 1;}else if(__4.t==17){return 1;}else if(__4.t==18){return 1;}else if(__4.t==19){return 1;}else if(__4.t==20){return 1;}else if(__4.t==21){return 1;}else if(__4.t==22){return 1;}else if(__4.t==23){return 1;}else if(__4.t==24){return 1;}else if(__4.t==25){return 1;}else if(__4.t==1){printf("Cup Toolkit v0.0.1\n\n");printf("USAGE:\n    cup [COMMAND] [OPTIONS]");printf("\n\nCOMMANDS:");printf("\n    run                  Compile and run the current package");printf("\n    build                Compile the current package");printf("\n    check                Analyze the current package");printf("\n    new [PACKAGE]        Create a new package");printf("\n    update [PACKAGE]     Update given dependency");printf("\n    add [PACKAGE]        Adds given dependency");printf("\n    remove [PACKAGE]     Removes given dependency");printf("\n    gen docs             Generate documentation for the current package");printf("\n    gen binds [HEADER]   Generate bindings for a given C header file");printf("\n    self update          Update the Cup Toolkit");printf("\n    self install         Install the Cup Toolkit");printf("\n    self uninstall       Uninstall the Cup Toolkit");printf("\n\nSee 'cup help [COMMAND]' for more info about a specific command and it's available options.\n");return 0;}else if(__4.t==2){_i("run","Compile and run the current package",_2);return 0;}else if(__4.t==3){_i("build","Compile the current package",_2);return 0;}else if(__4.t==4){_i("check","Analyze the current package",_1);return 0;}else if(__4.t==5){_i("new","Create a new package",_1);return 0;}else if(__4.t==6){_i("update","Update given dependency",_1);return 0;}else if(__4.t==7){_i("add","Adds given dependency",_1);return 0;}else if(__4.t==8){_i("remove","Removes given dependency",_1);return 0;}else if(__4.t==9){_i("gen docs","Generate documentation for the current package",_1);return 0;}else if(__4.t==10){_i("gen binds","Generate bindings for a given C header file",_1);return 0;}else if(__4.t==11){_i("self update","Update the Cup Toolkit",_1);return 0;}else if(__4.t==12){_i("self install","Install the Cup Toolkit",_1);return 0;}else if(__4.t==13){_i("self uninstall","Uninstall the Cup Toolkite",_1);return 0;}ret_m:for(int __5=2;__5<__1;__5+=1){}printf("Compilation ");_g((_h){.t=2});printf("successful");_g((_h){.t=0});printf(" (%.2lfs elapsed)\n",_j());return 0;};_m _n(int __2){return (_m){.buf=malloc(sizeof(_k)*__2),.len=__2,};};void _l(){_m __1=_n(2);};void _i(uint8_t* __1,uint8_t* __2,uint8_t* __3){printf(__2);printf("\n\nUSAGE:\n    cup ");printf(__1);printf(" [OPTIONS]\n\nOPTIONS:");printf(__3);printf("\n");};_o _p(int __4){return (_o){.buf=malloc(sizeof(uint8_t)*__4),.len=0,.cap=__4,};};uint8_t* _q(_o* this,int __4){return ((*this).buf)+__4;};_e _f(_c __1){if((__1.len)==1){return (_e){.t=1};}uint8_t __2=0;_o __3=_p(16);for(int __4=1;__4<(__1.len);__4+=1){if(__4==4){goto ret_l;}l:}ret_l:(*_q((&__3),__3.len))='\0';uint8_t* __4=__3.buf;if(strcmp(__4,"help")==0){return (_e){.t=1};}else if(strcmp(__4,"helprun")==0){return (_e){.t=2};}else if(strcmp(__4,"helpbuild")==0){return (_e){.t=3};}else if(strcmp(__4,"helpcheck")==0){return (_e){.t=4};}else if(strcmp(__4,"helpupdate")==0){return (_e){.t=6};}else if(strcmp(__4,"helpadd")==0){return (_e){.t=7};}else if(strcmp(__4,"helpremove")==0){return (_e){.t=8};}else if(strcmp(__4,"helpgendocs")==0){return (_e){.t=9};}else if(strcmp(__4,"helpgenbinds")==0){return (_e){.t=10};}else if(strcmp(__4,"helpselfupdate")==0){return (_e){.t=11};}else if(strcmp(__4,"helpselfinstall")==0){return (_e){.t=12};}else if(strcmp(__4,"helpselfuninstall")==0){return (_e){.t=13};}else if(strcmp(__4,"run")==0){return (_e){.t=14};}else if(strcmp(__4,"build")==0){return (_e){.t=15};}else if(strcmp(__4,"check")==0){return (_e){.t=16};}else if(strcmp(__4,"update")==0){return (_e){.t=18};}else if(strcmp(__4,"add")==0){return (_e){.t=19};}else if(strcmp(__4,"remove")==0){return (_e){.t=20};}else if(strcmp(__4,"gendocs")==0){return (_e){.t=21};}else if(strcmp(__4,"genbinds")==0){return (_e){.t=22};}else if(strcmp(__4,"selfupdate")==0){return (_e){.t=23};}else if(strcmp(__4,"selfinstall")==0){return (_e){.t=24};}else if(strcmp(__4,"selfuninstall")==0){return (_e){.t=25};}return (_e){.t=0};};double _j(){return ((double)clock())/CLOCKS_PER_SEC;};void _g(_h __1){if(__1.t==0){printf("\033[0m");}else if(__1.t==1){printf("\033[35m");}else if(__1.t==2){printf("\033[32m");}else if(__1.t==3){printf("\033[0;31m");}};