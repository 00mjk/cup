` general
    ` [?] rename `enum` -> `union`
    ` [?] rename `|` -> `^`
` lexer
    ` [] raw strings
` parser
    ` [] Path -> Expr
    ` [] chaining ops
    ` [?] combo var_defs
    ` [?] combo match/case
` analyzer
    ` [âœ“] binds
    ` [] check number of args for
        ` [] tag
        ` [] sub_call
        ` [] enum_inst
        ` [] comp_inst
    ` [] check type
        ` [] when assigning check if type matches
        ` [] when giving to sub_call check
        ` [] when giving to comp_inst
        ` [] when ops
    ` [] check if label defined
    ` [] check if comp_inst fields exist
    ` [] apply transformations
        ` [] custom ops
        ` [] enum compare == !=
        ` [] #self
            ` [] check if its allowed for currrent expr
            ` [] this
            ` [] sub_calls (.)
        ` [] try keyword
    ` [] type inference for var_defs
` generator
    ` [] locals
    ` [] mangle labels
` playground
    ` multiple files
    ` line numbers
` language server
    ` parser error tolerance

#req("stdio.h")
#bind("printf")
sub fmt:print() {};

sub main() {
    fmt:print("Hello, World!");
};

` enum Test (
`     comp A (),
`     comp B (),
` );

` mod foo<type AAA> {
`     enum SomeEnum<type T> (
`         int,
`         f32,
`         comp NewType (),
`     );
` };

` comp int ();
` 
` mod a {
` 
`     echo b:c:d;
` 
`     mod b {
`         int c;
`     };
` 
`     mod b:c {
`         #pub int d;
`     };
` 
` };