` general
    ` [?] rename `enum` -> `sum`
    ` [?] rename `|` -> `^`
    ` [?] #mut
` lexer
    ` [] add @=
    ` [] raw strings
    ` [] string interpolation ($, $(abc + 2))
` parser
    ` [] Path -> Expr
    ` [] chaining ops
    ` [?] combo var_defs
    ` [?] combo match/case
` analyzer
    ` [] type inference
    ` [] check number of args for
        ` [] tag
        ` [] sub_call
        ` [] enum_inst
        ` [] comp_inst
    ` [] check type
        ` [] when assigning check if type matches
        ` [] when giving to sub_call check
        ` [] when giving to comp_inst
        ` [] when ops
    ` [] check if label defined
    ` [] apply transformations
        ` [] auto deref and address
        ` [] custom ops
        ` [] enum compare == !=
        ` [] #self
            ` [] check if its allowed for currrent expr
            ` [+] this
            ` [] sub_calls (.)
        ` [] try keyword
    ` [] generic aliases
` generator
    ` [] mangle labels
` playground
    ` multiple files
    ` line numbers
` language server
    ` parser error tolerance

comp SomeComp (int a) {
    #pub int foo () {

    };
};

` #single prop ops:Add<T> {
`     #self T add (This rhs);
` };
` 
` def ops:Add<int> for int {
`     #self int add (This rhs) {
`         ret self + rhs;
`     };
` };

sub main () {
    SomeComp:foo();
}; 