` general
    ` [] rename `enum` -> `union`
` lexer
    ` [] raw strings
` parser
    ` [] gens: darr<Path> -> darr<Expr>
    ` Path -> Expr
    ` combo ops
    ` combo var_defs
` analyzer
    ` local
        ` [âœ“] binds
        ` [] check number of args for
            ` [] tag
            ` [] sub_call
            ` [] enum_inst
            ` [] comp_inst
        ` [] check type
            ` [] when assigning check if type matches
            ` [] when giving to sub_call check
            ` [] when giving to comp_inst
            ` [] when giving to enum_inst
            ` [] when ops
        ` [] check if label defined
        ` [] check if comp_inst fields exist
        ` [] apply transformations
            ` [] custom ops
            ` [] enum_inst (==, !=)
            ` [] #self
                ` [] this
                ` [] sub_calls (.)
            ` [] try keyword
        ` [] type inference for var_defs
` generator
` playground
    ` multiple files
    ` line numbers
` language server
    ` parser error tolerance

#self sub foo() {
    echo 1 + 1;
};

enum Test (
    comp A (),
    comp B (),
);

` mod foo<type AAA> {
`     enum SomeEnum<type T> (
`         int,
`         f32,
`         comp NewType (),
`     );
` };

` comp int ();
` 
` mod a {
` 
`     echo b:c:d;
` 
`     mod b {
`         int c;
`     };
` 
`     mod b:c {
`         #pub int d;
`     };
` 
` };