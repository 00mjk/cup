/// Decide
    `label` or `label
    "rest" keyword or tag
    conditional compilation
    exception handling
    arrays

sub<T> something() -> i32 where 
f32: AddAssign<T>,
{
    var a_pointer: const ptr<const int>;
}

/// Keywords
    (3) tag // defines a tag
    (3) mod // defines a module
    (3) use // use a certain module or item
    (6) struct // defines a struct
    (4) enum // defines a enum
    (5) union // defines a union
    (4) prop // defines a property
    (3) def // defines a property or subroutines for a struct/enum/union
    (3) sub // defines a subroutine
    (4) this // current instance
    (4) type // current type
    (5) where // constrains generics
    (4) rest // used to define rest args
    (5) const // indicate a constant type
    (4) true
    (5) false
    (4) null // null pointer value
    (2) if
    (4) elif
    (4) else
    (2) do // infinite loop
    (5) while
    (3) for // defines a for-loop
    (2) in // used with "for"
    (5) match
    (4) case // used inside "match"
    (2) back // returns from a loop/sub
    (4) next // continues the execution of a loop
    (5) delay // delays the execution of a block
    (4) jump // jumps to the specified label
    (2) as // type casting

/// Tags
    #pub // marks item as public
    #inl // marks sub to be inlined by the compiler
    #exh // exhaustive "match"
    #self // marks sub to act on a instance
    #os(os_name: str)
    #def(def_name: str, value: int)
    #if(def_name: str)
    #bind(fn_name: str)
    #gen(gen_name: str)
    #req(header: str)

/// Basic types
    isize i8 i16 i32 i64, int = i32
    usize u8 u16 u32 u64, uint = u32
    bsize b8 b16 b32 b64, bool = b8
    f32 f64, float = f64
    c8 c16 c32, char = c32
    s8 s16 s32, str = s32