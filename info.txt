sub<T> something() -> i32 where 
f32: AddAssign<T>,
{
    
}

# Features
    generics<T>
    #tags
    ~labels
    `comments
    SomeComp { field1 = 1, field2 = 2 }
    into<T> prop

# Operator presedence
    foo[], (), foo()
    foo.bar, foo@, foo$, foo!
    *, /, %
    +, -
    <, <=, >, >=
    ==, !=
    &
    |
    ?
    :=, =, @=, +=, -=, *=, /=, %=

# Keywords (avg ~3.77) (total 26)
    (3) tag - defines a tag
    (3) mod - defines a module
    (3) use - use a certain module or item
    (4) comp - defines a compound
    (4) enum - defines a enum
    (4) prop - defines a property
    (3) def - defines a property or subroutines for a comp/enum
    (3) sub - defines a subroutine
    (4) this - current instance
    (4) type - current type
    (5) where - constrains generics
    (4) true - true value
    (5) false - false value
    (4) none - none value
    (2) if
    (4) elif
    (4) else
    (4) loop - infinite loop
    (5) while - while loop
    (3) for - for loop
    (4) each - each loop
    (5) match
    (4) next - continues the execution of a loop
    (4) jump - jumps to the specified label
    (3) ret - returns from a sub
    (3) try - tries to unwrap a "res"

# Basic types
    isize i8 i16 i32 i64, int = i32
    usize u8 u16 u32 u64, uint = u32
    bsize b8 b16 b32 b64, bool = b8
    f32 f64, float = f64
    c8 c16 c32, char = c32
    s8 s16 s32, str = s32
    any
    
# Basic tags
    #con - marks variable as constant
    #cmp - marks expression as compile time
    #pub - marks item as public
    #inl - marks "sub"/"var" to be inlined by the compiler
    #uni - unified "comp"
    #exh - exhaustive "match"
    #del - delay execution of a "local"
    #self - marks sub to act on a instance
    #rest - marks arg as a rest arg
    #os(os_name: str)
    #def(def_name: str, value: int)
    #if(def_name: str) #if(def_name: str, value: int)
    #bind(fn_name: str)
    #gen(gen_name: str)
    #req(header: str)

# Expressions
    literal: bool_lit, num_lit, char_lit, str_lit, null_lit, arr_lit, this_lit, type_lit
    value: op, sub_call, var_use, literal
    local: if, do, while, for, match, back, next, jump, delay, local_var_def, value
    global: use, mod, comp, enum, prop, def, sub_def, var_def

    tag:
        name: str
        args: arr<literal>

    mod:
        pub: bool
        name: str
        body: arr<global>

    use:
        path: arr<str>

    type:
        mut: bool
        path: arr<str>
        gens: arr<type>

    constr_type:
        name: str
        constr: arr<type>

    comp:
        pub: bool
        uni: bool
        name: str
        gens: arr<constr_type>
        body: arr<field>

    enum:
        pub: bool
        name: str
        gens: arr<constr_type>
        body: arr<option>

    option:
        name: str
        body: arr<field>

    prop:
        pub: bool
        name: str
        gens: arr<constr_type>
        body: arr<sub_def>

    def:
        pub: bool
        gens: arr<constr_type>
        prop: type
        target: type
        body: arr<sub_def>

    sub_def:
        pub: bool
        inl: bool
        name: str
        gens: arr<constr_type>
        args: arr<arg>
        retType: arr<type>
        body: arr<local>

    arg:
        rest: bool
        name: str
        type: type

    var_def:
        pub: bool
        inl: bool
        name: str
        type: type
        value: value

    local_var_def:
        name: str
        type: type
        value: value

    sub_call:
        path: arr<str>
        args: arr<value>

    var_use:
        path: arr<str>

    comp_inst:
        path: arr<str>
        args: arr<field_inst>
    
    field_inst:
        name: str
        value: value

    string_lit:
    array_lit:
        value: arr<value>

    num_lit:
        value: str

    bool_lit:
        value: bool

    char_lit:
        value: char

    null_lit:
    self_lit:

    loop:
    block:
        body: arr<local>

    if:
        if: while
        elif: arr<while>
        else: arr<local>

    while:
        cond: value
        body: arr<local>

    for:
        loop_var: str
        cond: value
        next: value
        body: arr<local>

    each:
        loop_var: str
        iter: value
        body: arr<local>

    match:
        value: value
        body: arr<case>

    case:
        value: value
        body: arr<local>

    next:
    jump:
        target: str

    ret:
    try:
        target: str
        value: value

    cond_op:
        cond: value
        lhs: value
        rhs: value
    
    range_op:
    equal_op:
    not_equal_op:
    and_op:
    or_op:
    less_op:
    less_equal_op:
    greater_op:
    greater_equal_op:
    add_op:
    sub_op:
    mul_op:
    div_op:
    mod_op:
        lhs: value
        rhs: value

    deref_op:
    address_op:
    not_op:
        value: value

    assign_op:
    add_assign_op:
    sub_assign_op:
    mul_assign_op:
    div_assign_op:
    mod_assign_op:
        lhs: var_use
        rhs: value