# main() {
    # struct SomeStruct {
    #     a: int,
    #     b: f32,
    # }

    # enum SomeEnum {
    #     Option1(foobar: i32),
    #     Option2(x: i32, y: f32, z: u8),
    #     Option3(),
    # }

    # 13 % a + 2 + 3 / 2 * foo;
    
    # while 1 + 1 { }

    # if 2 + 3 { } elif 1 { } else { }

    ## generics
    # fn some_func<T, U, V>(arg: T) {}
    # struct SomeStruct<T, U, V>
    # enum SomeEnum<T, U, V>

    ## pointers
    # ptr<T>
    # deref with *
    # addr with &

    ## break with value
    # let a = loop {
    #     break 2 + 2;
    # }

    ## string interpolation
    # "hello $a";

    ## match
    # match number {
    #     -1..1 => println!("Some range!"),
    #     2 or 3 => println!("Two or three!"),
    # }

    ## for in
    # use while if you dont like it
    # for item in items {
    #     print(item);
    # }

    ## do/while
    # standalone "do" for a infinite loop

    ## null

    ## C constants

    ## self, Self
    # self is C# "this"
    # Self is typeof(self)

    ## unions

    ## struct inititialization
    # foo := v2 {
    #    x = 1.0,
    #    y = 1.0,
    # };
    
    ## inline keyword
    # for vars ("statics")
    # for funcs

    ## conversion/casting
    # into<T> trait for conversion (when something is done only)
    # as keyword for casting

    ## `labels`

    ## rest
    # is an arr<void> by default

    ## closures
    # |x| { print(x); }
# }

## C externs

## type abstraction (type NewType = SomeOtherType)

## did you mean 'some command' ?

## try compile with tcc, gcc, clang, msvc
# notify what compiler is used
# error when no compiler found

## combo declarations
# let a, b = 0, c;

## don't allow elif or else without if
# elif 5 { }
# else { }

## restrict expr to certain scopes
# struct, enum, fn - only globals
# rest only in functions

## analyze globals first

## fn checks
# 1. fn not defined 
# 2. fn already defined
# 3. wrong number of args in fn call

## check for types
# 1. fn return type
# 2. operator types
# 3. fn call types

## greek question mark ;