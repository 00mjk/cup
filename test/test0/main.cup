fn main() {
    ## generics
    # fn some_func<T, U, V>(arg: T) {}
    # struct SomeStruct<T, U, V>
    # enum SomeEnum<T, U, V>

    ## pointers
    # ptr<T>
    # deref with *
    # addr with &

    ## break with value
    # let a = loop {
    #     break 2 + 2;
    # }

    ## string interpolation
    # "hello $a";

    ## match
    # match number {
    #     -1..1 => println!("Some range!"),
    #     2 or 3 => println!("Two or three!"),
    # }

    ## for in
    # use while if you dont like it
    # for item in items {
    #     print(item);
    # }

    ## do/while
    # or just do for a infinite loop

    ## and, or

    ## null

    ## C constants

    ## self, Self

    ## static
    # globals need to be marked static explicitly

    ## unions

    ## struct inititialization
    # foo := v2 { 
    #    x = 1.0,
    #    y = 1.0, 
    # };
    
    ## inline

    ## full struct inheritance with 'use'

#######################
#      POINTERS       #
#######################

foo := alloc<SomeStruct>();
foo: ptr<SomeStruct> = alloc_size(size_of(SomeStruct));

foo: ptr<int>;
foo: const ptr<int>;
foo: ptr<const int>;
foo: const ptr<const int>;

#######################
#        CONST        #
#######################

const foo := 1;
foo: ptr<const ptr<const int>> = alloc();

func(const self, foo: const int) -> const int {
    
}

other_func(self, bar: i32) {
    
}

#######################
#      CLOSURES       #
#######################

(x) { print(x); }
|x| { print(x); }

#######################
#     INHERITANCE     #
#######################

struct Entity {
    id: i32,
}

struct Light {
    use Entity,
    size int,
    intensity: f32,
}

#######################
#      FREEING        #
#######################

struct string {
    pointer: ptr<u8>,
    pub size: int,
    pub capacity: int,
}

impl std::mem::free for string {
    free(s: Self) {
        free(s.pointer);
    }
}

#######################
#      TO DECIDE      #
#######################

## inheritance for enums

## arrays/vectors/seqs/lists
# array<T> (alloca?)
# vector<T>
# vector<T> `as` array<T>

# views
# multiple return values
# labels (break label;)
# errors (error handling)
# externs
# license (zlib?)
# macros

}

## did you mean 'some command' ?

## try compile with tcc, gcc, clang, msvc
# notify what compiler is used
# error when no compiler found

## combo declarations
# let a, b = 0, c;

## don't allow elif or else without if
# elif 5 { }
# else { }

## restrict expr to certain scopes
# struct, enum, fn - only globals
# rest only in functions

## analyze globals first

## fn checks
# 1. fn not defined 
# 2. fn already defined
# 3. wrong number of args in fn call

## check for types
# 1. fn return type
# 2. operator types
# 3. fn call types

## greek question mark ;