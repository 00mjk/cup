fn main() {
    ## generics
    # fn some_func<T, U, V>(arg: T) {}
    # struct SomeStruct<T, U, V>
    # enum SomeEnum<T, U, V>

    ## pointers
    # ptr<T>
    # deref with *
    # addr with &

    ## break with value
    # let a = loop {
    #     break 2 + 2;
    # }

    ## string interpolation
    # "hello $a";

    ## match
    # match number {
    #     -1..1 => println!("Some range!"),
    #     2 or 3 => println!("Two or three!"),
    # }

    ## for in
    # use while if you dont like it
    # for item in items {
    #     print(item);
    # }

    ## do/while
    # standalone "do" for a infinite loop

    ## null

    ## C constants

    ## self, Self
    # self is C# "this"
    # Self is typeof(self)

    ## unions

    ## struct inititialization
    # foo := v2 { 
    #    x = 1.0,
    #    y = 1.0, 
    # };
    
    ## inline keyword
    # for vars ("statics")
    # for funcs

    ## conversion/casting
    # into<T> trait for conversion
    # as keyword for casting

#######################
#      POINTERS       #
#######################

foo := alloc<SomeStruct>();
foo: ptr<SomeStruct> = alloc_size(size_of(SomeStruct));

foo: ptr<int>;
foo: const ptr<int>;
foo: ptr<const int>;
foo: const ptr<const int>;

#######################
#        CONST        #
#######################

const foo := 1;
foo: ptr<const ptr<const int>> = alloc();

func(const self, foo: const int) -> const int {
    
}

other_func(self, bar: i32) {
    
}

#######################
#      CLOSURES       #
#######################

(x) { print(x); }
|x| { print(x); }

#######################
#      FREEING        #
#######################

struct string {
    pointer: ptr<u8>,
    pub size: int,
    pub capacity: int,
}

impl std::mem::free for string {
    free(s: Self) {
        free(s.pointer);
    }
}

string impl std::mem::free {
    free(s: Self) {
        free(s.pointer);
    }
}

#######################
#      TO DECIDE      #
#######################

# and, or
# const (casting)
# type NewType = SomeOtherType;
# rest args
# multiple return values
# labels (break label;)
# errors (error handling)
# closures
# impl syntax (for or no for)
# externs

}

## did you mean 'some command' ?

## try compile with tcc, gcc, clang, msvc
# notify what compiler is used
# error when no compiler found

## combo declarations
# let a, b = 0, c;

## don't allow elif or else without if
# elif 5 { }
# else { }

## restrict expr to certain scopes
# struct, enum, fn - only globals
# rest only in functions

## analyze globals first

## fn checks
# 1. fn not defined 
# 2. fn already defined
# 3. wrong number of args in fn call

## check for types
# 1. fn return type
# 2. operator types
# 3. fn call types

## greek question mark ;