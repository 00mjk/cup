fn main() {
    ## generics
    # fn some_func<T, U, V>(arg: T) {}
    # struct SomeStruct<T, U, V>
    # enum SomeEnum<T, U, V>

    ## pointers
    # ptr<T>

    ## break with value
    # let a = loop {
    #     break 2 + 2;
    # }

    ## string interpolation
    # "hello $a";

    ## match
    # match number {
    #     -1..1 => println!("Some range!"),
    #     2 or 3 => println!("Two or three!"),
    # }

    ## for in
    # use while if you dont like it
    # for item in items {
    #     print(item);
    # }

    ## do/while
    # or just do for a infinite loop

    ## and, or

    ## null

    ## C constants

    ## self, Self

    ## static
    # globals need to be marked static explicitly

    ## unions

#######################
#      POINTERS       #
#######################

foo := alloc<SomeStruct>();
foo: ptr<SomeStruct> = alloc_size(size_of(SomeStruct));

foo: ptr<int>;
foo: const ptr<int>;
foo: ptr<const int>;
foo: const ptr<const int>;

#######################
#       STATICS       #
#######################

## outside impl

# variables can only be static
static foo := 42;

# functions can only be static
static some_func() {}

impl SomeStruct {
    ## inside impl

    # variables can only be static
    static foo := 69;

    # functions can be static
    static func() {}
    non_static_func() {}

    test() {
        ## inside functions

        # variables can be static
        static foo := 42;
        foo := 22;
    }
}

#######################
#      CLOSURES       #
#######################

(x) { print(x); }
|x| { print(x); }

#######################
#     INHERITANCE     #
#######################

struct SomeStruct {
    use SomeOtherStruct,
    a: int,
    b: f32,
    use SomeOtherOtherStruct,
    c: string,
}

enum SomeEnum {
    use SomeOtherEnum,
    Option1(),
    Option2,
    Option3,
    use SomeOtherOtherEnum,
    Option4,
}

#######################
#      FREEING        #
#######################

struct string {
    pointer: ptr<u8>,
    pub size: int,
    pub capacity: int,
}

impl free for string {
    free() {
        free(self.pointer);
    }
}

struct SomeStruct {
    a: int,
    b: ref<string>,
}

*b = "asdasds";

#######################
#       DECIDE        #
#######################

## inheritance for structs (enums too?)
# `use` inside `struct`

## deref and address
# * for deref and & for adress

# arrays/vectors/seqs/lists
# array views
# struct inititialization (= or :)
# multiple return values
# labels (break label;)
# errors (error handling)
# externs
# license (zlib?)
# macros

}

## did you mean 'some command' ?

## try compile with tcc, gcc, clang, msvc
# notify what compiler is used
# error when no compiler found

## combo declarations
# let a, b = 0, c;

## don't allow elif or else without if
# elif 5 { }
# else { }

## restrict expr to certain scopes
# struct, enum, fn - only globals
# rest only in functions

## analyze globals first

## fn checks
# 1. fn not defined 
# 2. fn already defined
# 3. wrong number of args in fn call

## check for types
# 1. fn return type
# 2. operator types
# 3. fn call types

## greek question mark ;